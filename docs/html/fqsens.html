<!DOCTYPE html>
<html>
<head>	<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
	<meta name="viewport" content="width=device-width,initial-scale=1.0,minimum-scale=1.0,maximum-scale=1.0,user-scalable=no">
	<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/3.3.7/css/bootstrap.min.css">
	<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/8.6/styles/foundation.min.css">
	<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/typeahead.js-bootstrap-css/1.2.1/typeaheadjs.min.css">
	<link rel="stylesheet" type="text/css" data-href="common.css">
	<script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
	<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/8.6/highlight.min.js"></script>
	<script src="https://cdnjs.cloudflare.com/ajax/libs/bootstrap-3-typeahead/3.1.1/bootstrap3-typeahead.min.js"></script>
	<script data-src="common.js"></script>

	<script>
        (function () {
            var cachekey;
            try {
                cachekey = window.parent.CACHEKEY;
            }
            catch (e) {
                cachekey = 'nocache';
            }
            $('link[data-href]').attr('href', function () {
                return this.dataset.href + '?' + cachekey;
            });
            $('script[data-src]').attr('src', function () {
                return this.dataset.src + '?' + cachekey;
            });

            $(document).on('click', 'a[href]:not([target="_blank"]):not(.cachekey)', function () {
                this.classList.add('cachekey');
                this.href = this.href.replace('.html', '.html?' + cachekey);
            });
        })();
	</script>
    </head>
<body class="fqsen">
<a id="anchor" href="./" style="display: none"></a>
<h1 class="ellipsis fixed">
	All Fqsen (for search Ctrl+F)
	<span class="pull-right">
		<small class="frame-switch">
		<a target="_parent">frame</a> | <a target="_parent">noframe</a>
		</small>
	</span>
</h1>
<div class="main-wrapper">
            	<h4 class="fqsen-title">namespace		<small></small>
		<a href="ryunosuke-$namespace.html#ryunosuke\">
            ryunosuke                        		</a>	</h4>
	<div class="description"></div>
                	<h4 class="fqsen-title">namespace		<small></small>
		<a href="ryunosuke-Functions-$namespace.html#ryunosuke\Functions\">
            ryunosuke\Functions                        		</a>	</h4>
	<div class="description"></div>
                	<h4 class="fqsen-title">namespace		<small></small>
		<a href="ryunosuke-Functions-Package-$namespace.html#ryunosuke\Functions\Package\">
            ryunosuke\Functions\Package                        		</a>	</h4>
	<div class="description"></div>
                
                	<h4 class="fqsen-title">class		<small></small>
		<a href="ryunosuke-Functions-Package-Arrays$typespace.html#ryunosuke\Functions\Package\Arrays">
                                    ryunosuke\Functions\Package::Arrays		</a>	</h4>
	<div class="description"><p>配列関連のユーティリティ</p>
</div>
                	<h4 class="fqsen-title">method		<small></small>
		<a href="ryunosuke-Functions-Package-Arrays$typespace.html#ryunosuke\Functions\Package\Arrays::arrays()">
                                    ryunosuke\Functions\Package\Arrays::arrays		</a>	<small>($array) : <a href="http://php.net/manual/ja/class.generator.php" class="fqsen" target="_blank">\Generator</a></small>
		</h4>
	<div class="description"><p>配列をシーケンシャルに走査するジェネレータを返す</p>
<p>「シーケンシャルに」とは要するに数値連番が得られるように走査するということ。<br />
0ベースの連番を作ってインクリメントしながら foreach するのと全く変わらない。</p>
<p>キーは連番、値は [$key, $value] で返す。<br />
つまり、 Example のように foreach の list 構文を使えば「連番、キー、値」でループを回すことが可能になる。<br />
「foreach で回したいんだけど連番も欲しい」という状況はまれによくあるはず。</p>
<p>Example:</p>
<pre><code class="language-php">$array = ['a' =&gt; 'A', 'b' =&gt; 'B', 'c' =&gt; 'C'];
$nkv = [];
foreach (arrays($array) as $n =&gt; [$k, $v]) {
    $nkv[] = "$n,$k,$v";
}
that($nkv)-&gt;isSame(['0,a,A', '1,b,B', '2,c,C']);
</code></pre>
</div>
    	<h4 class="fqsen-title">method		<small></small>
		<a href="ryunosuke-Functions-Package-Arrays$typespace.html#ryunosuke\Functions\Package\Arrays::arrayize()">
                                    ryunosuke\Functions\Package\Arrays::arrayize		</a>	<small>(...$variadic) : array</small>
		</h4>
	<div class="description"><p>引数の配列を生成する。</p>
<p>配列以外を渡すと配列化されて追加される。<br />
連想配列は未対応。あくまで普通の配列化のみ。<br />
iterable や Traversable は考慮せずあくまで「配列」としてチェックする。</p>
<p>Example:</p>
<pre><code class="language-php">that(arrayize(1, 2, 3))-&gt;isSame([1, 2, 3]);
that(arrayize([1], [2], [3]))-&gt;isSame([1, 2, 3]);
$object = new \stdClass();
that(arrayize($object, false, [1, 2, 3]))-&gt;isSame([$object, false, 1, 2, 3]);
</code></pre>
</div>
    	<h4 class="fqsen-title">method		<small></small>
		<a href="ryunosuke-Functions-Package-Arrays$typespace.html#ryunosuke\Functions\Package\Arrays::is_indexarray()">
                                    ryunosuke\Functions\Package\Arrays::is_indexarray		</a>	<small>($array) : bool</small>
		</h4>
	<div class="description"><p>配列が数値配列か調べる</p>
<p>空の配列も数値配列とみなす。<br />
さらにいわゆる「連番配列」ではなく「キーが数値のみか？」で判定する。</p>
<p>つまり、 is_hasharray とは排他的ではない。</p>
<p>Example:</p>
<pre><code class="language-php">that(is_indexarray([]))-&gt;isTrue();
that(is_indexarray([1, 2, 3]))-&gt;isTrue();
that(is_indexarray(['x' =&gt; 'X']))-&gt;isFalse();
// 抜け番があっても true になる（これは is_hasharray も true になる）
that(is_indexarray([1 =&gt; 1, 2 =&gt; 2, 3 =&gt; 3]))-&gt;isTrue();
</code></pre>
</div>
    	<h4 class="fqsen-title">method		<small></small>
		<a href="ryunosuke-Functions-Package-Arrays$typespace.html#ryunosuke\Functions\Package\Arrays::is_hasharray()">
                                    ryunosuke\Functions\Package\Arrays::is_hasharray		</a>	<small>($array) : bool</small>
		</h4>
	<div class="description"><p>配列が連想配列か調べる</p>
<p>空の配列は普通の配列とみなす。</p>
<p>Example:</p>
<pre><code class="language-php">that(is_hasharray([]))-&gt;isFalse();
that(is_hasharray([1, 2, 3]))-&gt;isFalse();
that(is_hasharray(['x' =&gt; 'X']))-&gt;isTrue();
</code></pre>
</div>
    	<h4 class="fqsen-title">method		<small></small>
		<a href="ryunosuke-Functions-Package-Arrays$typespace.html#ryunosuke\Functions\Package\Arrays::first_key()">
                                    ryunosuke\Functions\Package\Arrays::first_key		</a>	<small>($array, $default = null) : mixed</small>
		</h4>
	<div class="description"><p>配列の最初のキーを返す</p>
<p>空の場合は $default を返す。</p>
<p>Example:</p>
<pre><code class="language-php">that(first_key(['a', 'b', 'c']))-&gt;isSame(0);
that(first_key([], 999))-&gt;isSame(999);
</code></pre>
</div>
    	<h4 class="fqsen-title">method		<small></small>
		<a href="ryunosuke-Functions-Package-Arrays$typespace.html#ryunosuke\Functions\Package\Arrays::first_value()">
                                    ryunosuke\Functions\Package\Arrays::first_value		</a>	<small>($array, $default = null) : mixed</small>
		</h4>
	<div class="description"><p>配列の最初の値を返す</p>
<p>空の場合は $default を返す。</p>
<p>Example:</p>
<pre><code class="language-php">that(first_value(['a', 'b', 'c']))-&gt;isSame('a');
that(first_value([], 999))-&gt;isSame(999);
</code></pre>
</div>
    	<h4 class="fqsen-title">method		<small></small>
		<a href="ryunosuke-Functions-Package-Arrays$typespace.html#ryunosuke\Functions\Package\Arrays::first_keyvalue()">
                                    ryunosuke\Functions\Package\Arrays::first_keyvalue		</a>	<small>($array, $default = null) : array</small>
		</h4>
	<div class="description"><p>配列の最初のキー/値ペアをタプルで返す</p>
<p>空の場合は $default を返す。</p>
<p>Example:</p>
<pre><code class="language-php">that(first_keyvalue(['a', 'b', 'c']))-&gt;isSame([0, 'a']);
that(first_keyvalue([], 999))-&gt;isSame(999);
</code></pre>
</div>
    	<h4 class="fqsen-title">method		<small></small>
		<a href="ryunosuke-Functions-Package-Arrays$typespace.html#ryunosuke\Functions\Package\Arrays::last_key()">
                                    ryunosuke\Functions\Package\Arrays::last_key		</a>	<small>($array, $default = null) : mixed</small>
		</h4>
	<div class="description"><p>配列の最後のキーを返す</p>
<p>空の場合は $default を返す。</p>
<p>Example:</p>
<pre><code class="language-php">that(last_key(['a', 'b', 'c']))-&gt;isSame(2);
that(last_key([], 999))-&gt;isSame(999);
</code></pre>
</div>
    	<h4 class="fqsen-title">method		<small></small>
		<a href="ryunosuke-Functions-Package-Arrays$typespace.html#ryunosuke\Functions\Package\Arrays::last_value()">
                                    ryunosuke\Functions\Package\Arrays::last_value		</a>	<small>($array, $default = null) : mixed</small>
		</h4>
	<div class="description"><p>配列の最後の値を返す</p>
<p>空の場合は $default を返す。</p>
<p>Example:</p>
<pre><code class="language-php">that(last_value(['a', 'b', 'c']))-&gt;isSame('c');
that(last_value([], 999))-&gt;isSame(999);
</code></pre>
</div>
    	<h4 class="fqsen-title">method		<small></small>
		<a href="ryunosuke-Functions-Package-Arrays$typespace.html#ryunosuke\Functions\Package\Arrays::last_keyvalue()">
                                    ryunosuke\Functions\Package\Arrays::last_keyvalue		</a>	<small>($array, $default = null) : array</small>
		</h4>
	<div class="description"><p>配列の最後のキー/値ペアをタプルで返す</p>
<p>空の場合は $default を返す。</p>
<p>Example:</p>
<pre><code class="language-php">that(last_keyvalue(['a', 'b', 'c']))-&gt;isSame([2, 'c']);
that(last_keyvalue([], 999))-&gt;isSame(999);
</code></pre>
</div>
    	<h4 class="fqsen-title">method		<small></small>
		<a href="ryunosuke-Functions-Package-Arrays$typespace.html#ryunosuke\Functions\Package\Arrays::prev_key()">
                                    ryunosuke\Functions\Package\Arrays::prev_key		</a>	<small>($array, $key) : string<span class="type-separator"></span><wbr>int<span class="type-separator"></span><wbr>bool<span class="type-separator"></span><wbr>null</small>
		</h4>
	<div class="description"><p>配列の指定キーの前のキーを返す</p>
<p>$key が最初のキーだった場合は null を返す。<br />
$key が存在しない場合は false を返す。</p>
<p>Example:</p>
<pre><code class="language-php">$array = ['a' =&gt; 'A', 'b' =&gt; 'B', 'c' =&gt; 'C'];
// 'b' キーの前は 'a'
that(prev_key($array, 'b'))-&gt;isSame('a');
// 'a' キーの前は無いので null
that(prev_key($array, 'a'))-&gt;isSame(null);
// 'x' キーはそもそも存在しないので false
that(prev_key($array, 'x'))-&gt;isSame(false);
</code></pre>
</div>
    	<h4 class="fqsen-title">method		<small></small>
		<a href="ryunosuke-Functions-Package-Arrays$typespace.html#ryunosuke\Functions\Package\Arrays::next_key()">
                                    ryunosuke\Functions\Package\Arrays::next_key		</a>	<small>($array, $key = null) : string<span class="type-separator"></span><wbr>int<span class="type-separator"></span><wbr>bool<span class="type-separator"></span><wbr>null</small>
		</h4>
	<div class="description"><p>配列の指定キーの次のキーを返す</p>
<p>$key が最後のキーだった場合は null を返す。<br />
$key が存在しない場合は false を返す。<br />
$key が未指定だと「次に生成されるキー」（$array[]='hoge' で生成されるキー）を返す。</p>
<p>$array[] = 'hoge' で作成されるキーには完全準拠しない（標準は unset すると結構乱れる）。公式マニュアルを参照。</p>
<p>Example:</p>
<pre><code class="language-php">$array = [9 =&gt; 9, 'a' =&gt; 'A', 'b' =&gt; 'B', 'c' =&gt; 'C'];
// 'b' キーの次は 'c'
that(next_key($array, 'b'))-&gt;isSame('c');
// 'c' キーの次は無いので null
that(next_key($array, 'c'))-&gt;isSame(null);
// 'x' キーはそもそも存在しないので false
that(next_key($array, 'x'))-&gt;isSame(false);
// 次に生成されるキーは 10
that(next_key($array, null))-&gt;isSame(10);
</code></pre>
</div>
    	<h4 class="fqsen-title">method		<small></small>
		<a href="ryunosuke-Functions-Package-Arrays$typespace.html#ryunosuke\Functions\Package\Arrays::in_array_and()">
                                    ryunosuke\Functions\Package\Arrays::in_array_and		</a>	<small>($needle, $haystack, $strict = false) : bool</small>
		</h4>
	<div class="description"><p>in_array の複数版（AND）</p>
<p>配列 $haystack が $needle の「すべてを含む」ときに true を返す。</p>
<p>$needle が非配列の場合は配列化される。<br />
$needle が空の場合は常に false を返す。</p>
<p>Example:</p>
<pre><code class="language-php">that(in_array_and([1], [1, 2, 3]))-&gt;isTrue();
that(in_array_and([9], [1, 2, 3]))-&gt;isFalse();
that(in_array_and([1, 9], [1, 2, 3]))-&gt;isFalse();
</code></pre>
</div>
    	<h4 class="fqsen-title">method		<small></small>
		<a href="ryunosuke-Functions-Package-Arrays$typespace.html#ryunosuke\Functions\Package\Arrays::in_array_or()">
                                    ryunosuke\Functions\Package\Arrays::in_array_or		</a>	<small>($needle, $haystack, $strict = false) : bool</small>
		</h4>
	<div class="description"><p>in_array の複数版（OR）</p>
<p>配列 $haystack が $needle の「どれかを含む」ときに true を返す。</p>
<p>$needle が非配列の場合は配列化される。<br />
$needle が空の場合は常に false を返す。</p>
<p>Example:</p>
<pre><code class="language-php">that(in_array_or([1], [1, 2, 3]))-&gt;isTrue();
that(in_array_or([9], [1, 2, 3]))-&gt;isFalse();
that(in_array_or([1, 9], [1, 2, 3]))-&gt;isTrue();
</code></pre>
</div>
    	<h4 class="fqsen-title">method		<small></small>
		<a href="ryunosuke-Functions-Package-Arrays$typespace.html#ryunosuke\Functions\Package\Arrays::kvsort()">
                                    ryunosuke\Functions\Package\Arrays::kvsort		</a>	<small>($array, $comparator = null) : array</small>
		</h4>
	<div class="description"><p>比較関数にキーも渡ってくる安定ソート</p>
<p>比較関数は ($avalue, $bvalue, $akey, $bkey) という引数を取る。<br />
「値で比較して同値だったらキーも見たい」という状況はまれによくあるはず。<br />
さらに安定ソートであり、同値だとしても元の並び順は維持される。</p>
<p>$comparator は省略できる。省略した場合、型に基づいてよしなにソートする。<br />
（が、比較のたびに型チェックが入るので指定したほうが高速に動く）。</p>
<p>ただし、標準のソート関数とは異なり、参照渡しではなくソートして返り値で返す。<br />
また、いわゆる asort であり、キー・値は常に維持される。</p>
<p>Example:</p>
<pre><code class="language-php">$array = [
    'a'  =&gt; 3,
    'b'  =&gt; 1,
    'c'  =&gt; 2,
    'x1' =&gt; 9,
    'x2' =&gt; 9,
    'x3' =&gt; 9,
];
// 普通のソート
that(kvsort($array))-&gt;isSame([
    'b'  =&gt; 1,
    'c'  =&gt; 2,
    'a'  =&gt; 3,
    'x1' =&gt; 9,
    'x2' =&gt; 9,
    'x3' =&gt; 9,
]);
// キーを使用したソート
that(kvsort($array, function($av, $bv, $ak, $bk){return strcmp($bk, $ak);}))-&gt;isSame([
    'x3' =&gt; 9,
    'x2' =&gt; 9,
    'x1' =&gt; 9,
    'c'  =&gt; 2,
    'b'  =&gt; 1,
    'a'  =&gt; 3,
]);
</code></pre>
</div>
    	<h4 class="fqsen-title">method		<small></small>
		<a href="ryunosuke-Functions-Package-Arrays$typespace.html#ryunosuke\Functions\Package\Arrays::array_add()">
                                    ryunosuke\Functions\Package\Arrays::array_add		</a>	<small>(...$variadic) : array</small>
		</h4>
	<div class="description"><p>配列の+演算子の関数版</p>
<p>Example:</p>
<pre><code class="language-php">// ただの加算の関数版なので同じキーは上書きされない
that(array_add(['a', 'b', 'c'], ['X']))-&gt;isSame(['a', 'b', 'c']);
// 異なるキーは生える
that(array_add(['a', 'b', 'c'], ['x' =&gt; 'X']))-&gt;isSame(['a', 'b', 'c', 'x' =&gt; 'X']);
</code></pre>
</div>
    	<h4 class="fqsen-title">method		<small></small>
		<a href="ryunosuke-Functions-Package-Arrays$typespace.html#ryunosuke\Functions\Package\Arrays::array_merge2()">
                                    ryunosuke\Functions\Package\Arrays::array_merge2		</a>	<small>(...$arrays) : array</small>
		</h4>
	<div class="description"><p>配列をマージして通常配列＋αで返す</p>
<p>キー・値が維持される点で array_merge とは異なる（振り直しをせず数値配列で返す）。<br />
きちんと0からの連番で構成される点で配列の加算とは異なる。<br />
要するに「できるだけキーが自然数（の並び）になるように」マージする。</p>
<p>歯抜けはそのまま維持され、文字キーは後ろに追加される（負数キーも同様）。</p>
<p>Example:</p>
<pre><code class="language-php">// キーが入り乱れているがよく見ると通し番号が振られている配列をマージ
that(array_merge2([4 =&gt; 4, 1 =&gt; 1], [0 =&gt; 0], [5 =&gt; 5, 2 =&gt; 2, 3 =&gt; 3]))-&gt;isSame([0, 1, 2, 3, 4, 5]);
// 歯抜けの配列をマージ
that(array_merge2([4 =&gt; 4, 1 =&gt; 1], [0 =&gt; 0], [5 =&gt; 5, 3 =&gt; 3]))-&gt;isSame([0, 1, 3 =&gt; 3, 4 =&gt; 4, 5 =&gt; 5]);
// 負数や文字キーは後ろに追いやられる
that(array_merge2(['a' =&gt; 'A', 1 =&gt; 1], [0 =&gt; 0], [-1 =&gt; 'X', 2 =&gt; 2, 3 =&gt; 3]))-&gt;isSame([0, 1, 2, 3, -1 =&gt; 'X', 'a' =&gt; 'A']);
// 同じキーは後ろ優先
that(array_merge2([0, 'a' =&gt; 'A0'], [1, 'a' =&gt; 'A1'], [2, 'a' =&gt; 'A2']))-&gt;isSame([2, 'a' =&gt; 'A2']);
</code></pre>
</div>
    	<h4 class="fqsen-title">method		<small></small>
		<a href="ryunosuke-Functions-Package-Arrays$typespace.html#ryunosuke\Functions\Package\Arrays::array_mix()">
                                    ryunosuke\Functions\Package\Arrays::array_mix		</a>	<small>(...$variadic) : array</small>
		</h4>
	<div class="description"><p>配列を交互に追加する</p>
<p>引数の配列を横断的に追加して返す。<br />
数値キーは振り直される。文字キーはそのまま追加される（同じキーは後方上書き）。</p>
<p>配列の長さが異なる場合、短い方に対しては何もしない。そのまま追加される。</p>
<p>Example:</p>
<pre><code class="language-php">// 奇数配列と偶数配列をミックスして自然数配列を生成
that(array_mix([1, 3, 5], [2, 4, 6]))-&gt;isSame([1, 2, 3, 4, 5, 6]);
// 長さが異なる場合はそのまま追加される（短い方の足りない分は無視される）
that(array_mix([1], [2, 3, 4]))-&gt;isSame([1, 2, 3, 4]);
that(array_mix([1, 3, 4], [2]))-&gt;isSame([1, 2, 3, 4]);
// 可変引数なので3配列以上も可
that(array_mix([1], [2, 4], [3, 5, 6]))-&gt;isSame([1, 2, 3, 4, 5, 6]);
that(array_mix([1, 4, 6], [2, 5], [3]))-&gt;isSame([1, 2, 3, 4, 5, 6]);
// 文字キーは維持される
that(array_mix(['a' =&gt; 'A', 1, 3], ['b' =&gt; 'B', 2]))-&gt;isSame(['a' =&gt; 'A', 'b' =&gt; 'B', 1, 2, 3]);
</code></pre>
</div>
    	<h4 class="fqsen-title">method		<small></small>
		<a href="ryunosuke-Functions-Package-Arrays$typespace.html#ryunosuke\Functions\Package\Arrays::array_zip()">
                                    ryunosuke\Functions\Package\Arrays::array_zip		</a>	<small>(...$arrays) : array</small>
		</h4>
	<div class="description"><p>配列の各要素値で順番に配列を作る</p>
<p><code>array_map(null, ...$arrays)</code> とほぼ同義。ただし</p>
<ul>
<li>文字キーは保存される（数値キーは再割り振りされる）</li>
<li>一つだけ配列を与えても構造は壊れない（array_map(null) は壊れる）</li>
</ul>
<p>Example:</p>
<pre><code class="language-php">// 普通の zip
that(array_zip(
    [1, 2, 3],
    ['hoge', 'fuga', 'piyo']
))-&gt;is([[1, 'hoge'], [2, 'fuga'], [3, 'piyo']]);
// キーが維持される
that(array_zip(
    ['a' =&gt; 1, 2, 3],
    ['hoge', 'b' =&gt; 'fuga', 'piyo']
))-&gt;is([['a' =&gt; 1, 'hoge'], [2, 'b' =&gt; 'fuga'], [3, 'piyo']]);
</code></pre>
</div>
    	<h4 class="fqsen-title">method		<small></small>
		<a href="ryunosuke-Functions-Package-Arrays$typespace.html#ryunosuke\Functions\Package\Arrays::array_cross()">
                                    ryunosuke\Functions\Package\Arrays::array_cross		</a>	<small>(...$arrays) : array</small>
		</h4>
	<div class="description"><p>配列の直積を返す</p>
<p>文字キーは保存されるが数値キーは再割り振りされる。<br />
ただし、文字キーが重複すると例外を投げる。</p>
<p>Example:</p>
<pre><code class="language-php">// 普通の直積
that(array_cross(
    [1, 2],
    [3, 4]
))-&gt;isSame([[1, 3], [1, 4], [2, 3], [2, 4]]);
// キーが維持される
that(array_cross(
    ['a' =&gt; 1, 2],
    ['b' =&gt; 3, 4]
))-&gt;isSame([['a' =&gt; 1, 'b' =&gt; 3], ['a' =&gt; 1, 4], [2, 'b' =&gt; 3], [2, 4]]);
</code></pre>
</div>
    	<h4 class="fqsen-title">method		<small></small>
		<a href="ryunosuke-Functions-Package-Arrays$typespace.html#ryunosuke\Functions\Package\Arrays::array_implode()">
                                    ryunosuke\Functions\Package\Arrays::array_implode		</a>	<small>($array, $glue) : array</small>
		</h4>
	<div class="description"><p>配列の各要素の間に要素を差し込む</p>
<p>歴史的な理由はないが、引数をどちらの順番でも受けつけることが可能。<br />
ただし、$glue を先に渡すパターンの場合は配列指定が可変引数渡しになる。</p>
<p>文字キーは保存されるが数値キーは再割り振りされる。</p>
<p>Example:</p>
<pre><code class="language-php">// (配列, 要素) の呼び出し
that(array_implode(['a', 'b', 'c'], 'X'))-&gt;isSame(['a', 'X', 'b', 'X', 'c']);
// (要素, ...配列) の呼び出し
that(array_implode('X', 'a', 'b', 'c'))-&gt;isSame(['a', 'X', 'b', 'X', 'c']);
</code></pre>
</div>
    	<h4 class="fqsen-title">method		<small></small>
		<a href="ryunosuke-Functions-Package-Arrays$typespace.html#ryunosuke\Functions\Package\Arrays::array_explode()">
                                    ryunosuke\Functions\Package\Arrays::array_explode		</a>	<small>($array, $condition, $limit = PHP_INT_MAX) : array</small>
		</h4>
	<div class="description"><p>配列を指定条件で分割する</p>
<p>文字列の explode を更に一階層掘り下げたイメージ。<br />
$condition で指定された要素は結果配列に含まれない。</p>
<p>$condition にはクロージャが指定できる。クロージャの場合は true 相当を返した場合に分割要素とみなされる。<br />
引数は (値, キー)の順番。</p>
<p>$limit に負数を与えると「その絶対値-1までを結合したものと残り」を返す。<br />
端的に言えば「正数を与えると後詰めでその個数で返す」「負数を与えると前詰めでその（絶対値）個数で返す」という動作になる。</p>
<p>Example:</p>
<pre><code class="language-php">// null 要素で分割
that(array_explode(['a', null, 'b', 'c'], null))-&gt;isSame([['a'], [2 =&gt; 'b', 3 =&gt; 'c']]);
// クロージャで分割（大文字で分割）
that(array_explode(['a', 'B', 'c', 'D', 'e'], function($v){return ctype_upper($v);}))-&gt;isSame([['a'], [2 =&gt; 'c'], [4 =&gt; 'e']]);
// 負数指定
that(array_explode(['a', null, 'b', null, 'c'], null, -2))-&gt;isSame([[0 =&gt; 'a', 1 =&gt; null, 2 =&gt; 'b'], [4 =&gt; 'c']]);
</code></pre>
</div>
    	<h4 class="fqsen-title">method		<small></small>
		<a href="ryunosuke-Functions-Package-Arrays$typespace.html#ryunosuke\Functions\Package\Arrays::array_sprintf()">
                                    ryunosuke\Functions\Package\Arrays::array_sprintf		</a>	<small>($array, $format = null, $glue = null) : array<span class="type-separator"></span><wbr>string</small>
		</h4>
	<div class="description"><p>キーと値で sprintf する</p>
<p>配列の各要素を文字列化して返すイメージ。<br />
$glue を与えるとさらに implode して返す（返り値が文字列になる）。</p>
<p>$format は書式文字列（$v, $k）。<br />
callable を与えると sprintf ではなくコールバック処理になる（$v, $k）。<br />
省略（null）するとキーを format 文字列、値を引数として <strong>vsprintf</strong> する。</p>
<p>Example:</p>
<pre><code class="language-php">$array = ['key1' =&gt; 'val1', 'key2' =&gt; 'val2'];
// key, value を利用した sprintf
that(array_sprintf($array, '%2$s=%1$s'))-&gt;isSame(['key1=val1', 'key2=val2']);
// 第3引数を与えるとさらに implode される
that(array_sprintf($array, '%2$s=%1$s', ' '))-&gt;isSame('key1=val1 key2=val2');
// クロージャを与えるとコールバック動作になる
$closure = function($v, $k){return "$k=" . strtoupper($v);};
that(array_sprintf($array, $closure, ' '))-&gt;isSame('key1=VAL1 key2=VAL2');
// 省略すると vsprintf になる
that(array_sprintf([
    'str:%s,int:%d' =&gt; ['sss', '3.14'],
    'single:%s'     =&gt; 'str',
], null, '|'))-&gt;isSame('str:sss,int:3|single:str');
</code></pre>
</div>
    	<h4 class="fqsen-title">method		<small></small>
		<a href="ryunosuke-Functions-Package-Arrays$typespace.html#ryunosuke\Functions\Package\Arrays::array_strpad()">
                                    ryunosuke\Functions\Package\Arrays::array_strpad		</a>	<small>($array, $key_prefix, $val_prefix = &quot;&quot;) : array</small>
		</h4>
	<div class="description"><p>配列のキー・要素に文字列を付加する</p>
<p>$key_prefix, $val_prefix でそれぞれ「キーに付与する文字列」「値に付与する文字列」が指定できる。<br />
配列を与えると [サフィックス, プレフィックス] という意味になる。<br />
デフォルト（ただの文字列）はプレフィックス（値だけに付与したいなら array_map で十分なので）。</p>
<p>Example:</p>
<pre><code class="language-php">$array = ['key1' =&gt; 'val1', 'key2' =&gt; 'val2'];
// キーにプレフィックス付与
that(array_strpad($array, 'prefix-'))-&gt;isSame(['prefix-key1' =&gt; 'val1', 'prefix-key2' =&gt; 'val2']);
// 値にサフィックス付与
that(array_strpad($array, '', ['-suffix']))-&gt;isSame(['key1' =&gt; 'val1-suffix', 'key2' =&gt; 'val2-suffix']);
</code></pre>
</div>
    	<h4 class="fqsen-title">method		<small></small>
		<a href="ryunosuke-Functions-Package-Arrays$typespace.html#ryunosuke\Functions\Package\Arrays::array_pos()">
                                    ryunosuke\Functions\Package\Arrays::array_pos		</a>	<small>($array, $position, $return_key = false) : mixed</small>
		</h4>
	<div class="description"><p>配列・連想配列を問わず「N番目(0ベース)」の要素を返す</p>
<p>負数を与えると逆から N 番目となる。</p>
<p>Example:</p>
<pre><code class="language-php">that(array_pos([1, 2, 3], 1))-&gt;isSame(2);
that(array_pos([1, 2, 3], -1))-&gt;isSame(3);
that(array_pos(['a' =&gt; 'A', 'b' =&gt; 'B', 'c' =&gt; 'C'], 1))-&gt;isSame('B');
that(array_pos(['a' =&gt; 'A', 'b' =&gt; 'B', 'c' =&gt; 'C'], 1, true))-&gt;isSame('b');
</code></pre>
</div>
    	<h4 class="fqsen-title">method		<small></small>
		<a href="ryunosuke-Functions-Package-Arrays$typespace.html#ryunosuke\Functions\Package\Arrays::array_pos_key()">
                                    ryunosuke\Functions\Package\Arrays::array_pos_key		</a>	<small>($array, $key, $default = null) : mixed</small>
		</h4>
	<div class="description"><p>配列の指定キーの位置を返す</p>
<p>Example:</p>
<pre><code class="language-php">that(array_pos_key(['a' =&gt; 'A', 'b' =&gt; 'B', 'c' =&gt; 'C'], 'c'))-&gt;isSame(2);
that(array_pos_key(['a' =&gt; 'A', 'b' =&gt; 'B', 'c' =&gt; 'C'], 'x', -1))-&gt;isSame(-1);
</code></pre>
</div>
    	<h4 class="fqsen-title">method		<small></small>
		<a href="ryunosuke-Functions-Package-Arrays$typespace.html#ryunosuke\Functions\Package\Arrays::array_of()">
                                    ryunosuke\Functions\Package\Arrays::array_of		</a>	<small>($key, $default = null) : <a href="http://php.net/manual/ja/class.closure.php" class="fqsen" target="_blank">\Closure</a></small>
		</h4>
	<div class="description"><p>配列を与えると指定キーの値を返すクロージャを返す</p>
<p>存在しない場合は $default を返す。</p>
<p>$key に配列を与えるとそれらの値の配列を返す（lookup 的な動作）。<br />
その場合、$default が活きるのは「全て無かった場合」となる。<br />
さらに $key が配列の場合に限り、 $default を省略すると空配列として動作する。</p>
<p>Example:</p>
<pre><code class="language-php">$fuga_of_array = array_of('fuga');
that($fuga_of_array(['hoge' =&gt; 'HOGE', 'fuga' =&gt; 'FUGA']))-&gt;isSame('FUGA');
</code></pre>
</div>
    	<h4 class="fqsen-title">method		<small></small>
		<a href="ryunosuke-Functions-Package-Arrays$typespace.html#ryunosuke\Functions\Package\Arrays::array_get()">
                                    ryunosuke\Functions\Package\Arrays::array_get		</a>	<small>($array, $key, $default = null) : mixed</small>
		</h4>
	<div class="description"><p>デフォルト値付きの配列値取得</p>
<p>存在しない場合は $default を返す。</p>
<p>$key に配列を与えるとそれらの値の配列を返す（lookup 的な動作）。<br />
その場合、$default が活きるのは「全て無かった場合」となる。</p>
<p>さらに $key が配列の場合に限り、 $default を省略すると空配列として動作する。</p>
<p>同様に、$key にクロージャを与えると、その返り値が true 相当のものを返す。<br />
その際、 $default が配列なら一致するものを配列で返し、配列でないなら単値で返す。</p>
<p>Example:</p>
<pre><code class="language-php">// 単純取得
that(array_get(['a', 'b', 'c'], 1))-&gt;isSame('b');
// 単純デフォルト
that(array_get(['a', 'b', 'c'], 9, 999))-&gt;isSame(999);
// 配列取得
that(array_get(['a', 'b', 'c'], [0, 2]))-&gt;isSame([0 =&gt; 'a', 2 =&gt; 'c']);
// 配列部分取得
that(array_get(['a', 'b', 'c'], [0, 9]))-&gt;isSame([0 =&gt; 'a']);
// 配列デフォルト（null ではなく [] を返す）
that(array_get(['a', 'b', 'c'], [9]))-&gt;isSame([]);
// クロージャ指定＆単値（コールバックが true を返す最初の要素）
that(array_get(['a', 'b', 'c'], function($v){return in_array($v, ['b', 'c']);}))-&gt;isSame('b');
// クロージャ指定＆配列（コールバックが true を返すもの）
that(array_get(['a', 'b', 'c'], function($v){return in_array($v, ['b', 'c']);}, []))-&gt;isSame([1 =&gt; 'b', 2 =&gt; 'c']);
</code></pre>
</div>
    	<h4 class="fqsen-title">method		<small></small>
		<a href="ryunosuke-Functions-Package-Arrays$typespace.html#ryunosuke\Functions\Package\Arrays::array_set()">
                                    ryunosuke\Functions\Package\Arrays::array_set		</a>	<small>(&amp;$array, $value, $key = null, $require_return = true) : string<span class="type-separator"></span><wbr>int</small>
		</h4>
	<div class="description"><p>キー指定の配列値設定</p>
<p>第3引数を省略すると（null を与えると）言語機構を使用して配列の最後に設定する（$array[] = $value）。<br />
第3引数に配列を指定すると潜って設定する。</p>
<p>Example:</p>
<pre><code class="language-php">$array = ['a' =&gt; 'A', 'B'];
// 第3引数省略（最後に連番キーで設定）
that(array_set($array, 'Z'))-&gt;isSame(1);
that($array)-&gt;isSame(['a' =&gt; 'A', 'B', 'Z']);
// 第3引数でキーを指定
that(array_set($array, 'Z', 'z'))-&gt;isSame('z');
that($array)-&gt;isSame(['a' =&gt; 'A', 'B', 'Z', 'z' =&gt; 'Z']);
that(array_set($array, 'Z', 'z'))-&gt;isSame('z');
// 第3引数で配列を指定
that(array_set($array, 'Z', ['x', 'y', 'z']))-&gt;isSame('z');
that($array)-&gt;isSame(['a' =&gt; 'A', 'B', 'Z', 'z' =&gt; 'Z', 'x' =&gt; ['y' =&gt; ['z' =&gt; 'Z']]]);
</code></pre>
</div>
    	<h4 class="fqsen-title">method		<small></small>
		<a href="ryunosuke-Functions-Package-Arrays$typespace.html#ryunosuke\Functions\Package\Arrays::array_put()">
                                    ryunosuke\Functions\Package\Arrays::array_put		</a>	<small>(&amp;$array, $value, $key = null, $condition = null) : string<span class="type-separator"></span><wbr>int<span class="type-separator"></span><wbr>false</small>
		</h4>
	<div class="description"><p>キー指定の配列値設定</p>
<p>array_set とほとんど同じ。<br />
第3引数を省略すると（null を与えると）言語機構を使用して配列の最後に設定する（$array[] = $value）。<br />
また、<strong>int を与えても同様の動作</strong>となる。<br />
第3引数に配列を指定すると潜って設定する。</p>
<p>第4引数で追加する条件クロージャを指定できる。<br />
クロージャには <code>(追加する要素, 追加するキー, 追加される元配列)</code> が渡ってくる。<br />
このクロージャが false 相当を返した時は追加されないようになる。</p>
<p>array_set における $require_return は廃止している。<br />
これはもともと end や last_key が遅かったのでオプショナルにしていたが、もう改善しているし、7.3 から array_key_last があるので、呼び元で適宜使えば良い。</p>
<p>Example:</p>
<pre><code class="language-php">$array = ['a' =&gt; 'A', 'B'];
// 第3引数 int
that(array_put($array, 'Z', 999))-&gt;isSame(1);
that($array)-&gt;isSame(['a' =&gt; 'A', 'B', 'Z']);
// 第3引数省略（最後に連番キーで設定）
that(array_put($array, 'Z'))-&gt;isSame(2);
that($array)-&gt;isSame(['a' =&gt; 'A', 'B', 'Z', 'Z']);
// 第3引数でキーを指定
that(array_put($array, 'Z', 'z'))-&gt;isSame('z');
that($array)-&gt;isSame(['a' =&gt; 'A', 'B', 'Z', 'Z', 'z' =&gt; 'Z']);
that(array_put($array, 'Z', 'z'))-&gt;isSame('z');
// 第3引数で配列を指定
that(array_put($array, 'Z', ['x', 'y', 'z']))-&gt;isSame('z');
that($array)-&gt;isSame(['a' =&gt; 'A', 'B', 'Z', 'Z', 'z' =&gt; 'Z', 'x' =&gt; ['y' =&gt; ['z' =&gt; 'Z']]]);
// 第4引数で条件を指定（キーが存在するなら追加しない）
that(array_put($array, 'Z', 'z', function ($v, $k, $array){return !isset($array[$k]);}))-&gt;isSame(false);
// 第4引数で条件を指定（値が存在するなら追加しない）
that(array_put($array, 'Z', null, function ($v, $k, $array){return !in_array($v, $array);}))-&gt;isSame(false);
</code></pre>
</div>
    	<h4 class="fqsen-title">method		<small></small>
		<a href="ryunosuke-Functions-Package-Arrays$typespace.html#ryunosuke\Functions\Package\Arrays::array_unset()">
                                    ryunosuke\Functions\Package\Arrays::array_unset		</a>	<small>(&amp;$array, $key, $default = null) : mixed</small>
		</h4>
	<div class="description"><p>伏せると同時にその値を返す</p>
<p>$key に配列を与えると全て伏せて配列で返す。<br />
その場合、$default が活きるのは「全て無かった場合」となる。</p>
<p>さらに $key が配列の場合に限り、 $default を省略すると空配列として動作する。</p>
<p>配列を与えた場合の返り値は与えた配列の順番・キーが活きる。<br />
これを利用すると list の展開の利便性が上がったり、連想配列で返すことができる。</p>
<p>同様に、$key にクロージャを与えると、その返り値が true 相当のものを伏せて配列で返す。<br />
callable ではなくクロージャのみ対応する。</p>
<p>Example:</p>
<pre><code class="language-php">$array = ['a' =&gt; 'A', 'b' =&gt; 'B'];
// ない場合は $default を返す
that(array_unset($array, 'x', 'X'))-&gt;isSame('X');
// 指定したキーを返す。そのキーは伏せられている
that(array_unset($array, 'a'))-&gt;isSame('A');
that($array)-&gt;isSame(['b' =&gt; 'B']);

$array = ['a' =&gt; 'A', 'b' =&gt; 'B', 'c' =&gt; 'C'];
// 配列を与えるとそれらを返す。そのキーは全て伏せられている
that(array_unset($array, ['a', 'b', 'x']))-&gt;isSame(['A', 'B']);
that($array)-&gt;isSame(['c' =&gt; 'C']);

$array = ['a' =&gt; 'A', 'b' =&gt; 'B', 'c' =&gt; 'C'];
// 配列のキーは返されるキーを表す。順番も維持される
that(array_unset($array, ['x2' =&gt; 'b', 'x1' =&gt; 'a']))-&gt;isSame(['x2' =&gt; 'B', 'x1' =&gt; 'A']);

$array = ['hoge' =&gt; 'HOGE', 'fuga' =&gt; 'FUGA', 'piyo' =&gt; 'PIYO'];
// 値に "G" を含むものを返す。その要素は伏せられている
that(array_unset($array, function($v){return strpos($v, 'G') !== false;}))-&gt;isSame(['hoge' =&gt; 'HOGE', 'fuga' =&gt; 'FUGA']);
that($array)-&gt;isSame(['piyo' =&gt; 'PIYO']);
</code></pre>
</div>
    	<h4 class="fqsen-title">method		<small></small>
		<a href="ryunosuke-Functions-Package-Arrays$typespace.html#ryunosuke\Functions\Package\Arrays::array_dive()">
                                    ryunosuke\Functions\Package\Arrays::array_dive		</a>	<small>($array, $path, $default = null, $delimiter = &quot;.&quot;) : mixed</small>
		</h4>
	<div class="description"><p>パス形式で配列値を取得</p>
<p>存在しない場合は $default を返す。</p>
<p>Example:</p>
<pre><code class="language-php">$array = [
    'a' =&gt; [
        'b' =&gt; [
            'c' =&gt; 'vvv'
        ]
    ]
];
that(array_dive($array, 'a.b.c'))-&gt;isSame('vvv');
that(array_dive($array, 'a.b.x', 9))-&gt;isSame(9);
// 配列を与えても良い。その場合 $delimiter 引数は意味をなさない
that(array_dive($array, ['a', 'b', 'c']))-&gt;isSame('vvv');
</code></pre>
</div>
    	<h4 class="fqsen-title">method		<small></small>
		<a href="ryunosuke-Functions-Package-Arrays$typespace.html#ryunosuke\Functions\Package\Arrays::array_keys_exist()">
                                    ryunosuke\Functions\Package\Arrays::array_keys_exist		</a>	<small>($keys, $array) : bool</small>
		</h4>
	<div class="description"><p>array_key_exists の複数版</p>
<p>指定キーが全て存在するなら true を返す。<br />
配列ではなく単一文字列を与えても動作する（array_key_exists と全く同じ動作になる）。</p>
<p>$keys に空を与えると例外を投げる。<br />
$keys に配列を与えるとキーで潜ってチェックする（Example 参照）。</p>
<p>Example:</p>
<pre><code class="language-php">// すべて含むので true
that(array_keys_exist(['a', 'b', 'c'], ['a' =&gt; 'A', 'b' =&gt; 'B', 'c' =&gt; 'C']))-&gt;isTrue();
// N は含まないので false
that(array_keys_exist(['a', 'b', 'N'], ['a' =&gt; 'A', 'b' =&gt; 'B', 'c' =&gt; 'C']))-&gt;isFalse();
// 配列を与えると潜る（日本語で言えば「a というキーと、x というキーとその中に x1, x2 というキーがあるか？」）
that(array_keys_exist(['a', 'x' =&gt; ['x1', 'x2']], ['a' =&gt; 'A', 'x' =&gt; ['x1' =&gt; 'X1', 'x2' =&gt; 'X2']]))-&gt;isTrue();
</code></pre>
</div>
    	<h4 class="fqsen-title">method		<small></small>
		<a href="ryunosuke-Functions-Package-Arrays$typespace.html#ryunosuke\Functions\Package\Arrays::array_find()">
                                    ryunosuke\Functions\Package\Arrays::array_find		</a>	<small>($array, $callback, $is_key = true) : mixed</small>
		</h4>
	<div class="description"><p>array_search のクロージャ版のようなもの</p>
<p>コールバックの返り値が true 相当のものを返す。<br />
$is_key に true を与えるとそのキーを返す（デフォルトの動作）。<br />
$is_key に false を与えるとコールバックの結果を返す。</p>
<p>この関数は論理値 FALSE を返す可能性がありますが、FALSE として評価される値を返す可能性もあります。</p>
<p>Example:</p>
<pre><code class="language-php">// 最初に見つかったキーを返す
that(array_find(['a', 'b', '9'], 'ctype_digit'))-&gt;isSame(2);
that(array_find(['a', 'b', '9'], function($v){return $v === 'b';}))-&gt;isSame(1);
// 最初に見つかったコールバック結果を返す（最初の数字の2乗を返す）
$ifnumeric2power = function($v){return ctype_digit($v) ? $v * $v : false;};
that(array_find(['a', 'b', '9'], $ifnumeric2power, false))-&gt;isSame(81);
</code></pre>
</div>
    	<h4 class="fqsen-title">method		<small></small>
		<a href="ryunosuke-Functions-Package-Arrays$typespace.html#ryunosuke\Functions\Package\Arrays::array_rekey()">
                                    ryunosuke\Functions\Package\Arrays::array_rekey		</a>	<small>($array, $keymap) : array</small>
		</h4>
	<div class="description"><p>キーをマップ配列・callable で置換する</p>
<p>変換先・返り値が null だとその要素は取り除かれる。<br />
callable 指定時の引数は <code>(キー, 値, 連番インデックス, 対象配列そのもの)</code> が渡ってくる。</p>
<p>Example:</p>
<pre><code class="language-php">$array = ['a' =&gt; 'A', 'b' =&gt; 'B', 'c' =&gt; 'C'];
// a は x に c は z に置換される
that(array_rekey($array, ['a' =&gt; 'x', 'c' =&gt; 'z']))-&gt;isSame(['x' =&gt; 'A', 'b' =&gt; 'B', 'z' =&gt; 'C']);
// b は削除され c は z に置換される
that(array_rekey($array, ['b' =&gt; null, 'c' =&gt; 'z']))-&gt;isSame(['a' =&gt; 'A', 'z' =&gt; 'C']);
// キーの交換にも使える（a ⇔ c）
that(array_rekey($array, ['a' =&gt; 'c', 'c' =&gt; 'a']))-&gt;isSame(['c' =&gt; 'A', 'b' =&gt; 'B', 'a' =&gt; 'C']);
// callable
that(array_rekey($array, 'strtoupper'))-&gt;isSame(['A' =&gt; 'A', 'B' =&gt; 'B', 'C' =&gt; 'C']);
</code></pre>
</div>
    	<h4 class="fqsen-title">method		<small></small>
		<a href="ryunosuke-Functions-Package-Arrays$typespace.html#ryunosuke\Functions\Package\Arrays::array_grep_key()">
                                    ryunosuke\Functions\Package\Arrays::array_grep_key		</a>	<small>($array, $regex, $not = false) : array</small>
		</h4>
	<div class="description"><p>キーを正規表現でフィルタする</p>
<p>Example:</p>
<pre><code class="language-php">that(array_grep_key(['a' =&gt; 'A', 'aa' =&gt; 'AA', 'b' =&gt; 'B'], '#^a#'))-&gt;isSame(['a' =&gt; 'A', 'aa' =&gt; 'AA']);
that(array_grep_key(['a' =&gt; 'A', 'aa' =&gt; 'AA', 'b' =&gt; 'B'], '#^a#', true))-&gt;isSame(['b' =&gt; 'B']);
</code></pre>
</div>
    	<h4 class="fqsen-title">method		<small></small>
		<a href="ryunosuke-Functions-Package-Arrays$typespace.html#ryunosuke\Functions\Package\Arrays::array_map_recursive()">
                                    ryunosuke\Functions\Package\Arrays::array_map_recursive		</a>	<small>($array, $callback, $iterable = true) : array</small>
		</h4>
	<div class="description"><p>array_map の再帰版</p>
<p>下記の点で少し array_map とは挙動が異なる。</p>
<ul>
<li>配列だけでなく iterable も対象になる（引数で指定可能。デフォルト true）<ul>
<li>つまりオブジェクト構造は維持されず、結果はすべて配列になる</li>
</ul>
</li>
<li>値だけでなくキーも渡ってくる</li>
</ul>
<p>Example:</p>
<pre><code class="language-php">// array_walk 等と同様に葉のみが渡ってくる（iterable も対象になる）
that(array_map_recursive([
    'k' =&gt; 'v',
    'c' =&gt; new \ArrayObject([
        'k1' =&gt; 'v1',
        'k2' =&gt; 'v2',
    ]),
], 'strtoupper'))-&gt;isSame([
    'k' =&gt; 'V',
    'c' =&gt; [
        'k1' =&gt; 'V1',
        'k2' =&gt; 'V2',
    ],
]);

// ただし、その挙動は引数で変更可能
that(array_map_recursive([
    'k' =&gt; 'v',
    'c' =&gt; new \ArrayObject([
        'k1' =&gt; 'v1',
        'k2' =&gt; 'v2',
    ]),
], 'gettype', false))-&gt;isSame([
    'k' =&gt; 'string',
    'c' =&gt; 'object',
]);
</code></pre>
</div>
    	<h4 class="fqsen-title">method		<small></small>
		<a href="ryunosuke-Functions-Package-Arrays$typespace.html#ryunosuke\Functions\Package\Arrays::array_map_key()">
                                    ryunosuke\Functions\Package\Arrays::array_map_key		</a>	<small>($array, $callback) : array</small>
		</h4>
	<div class="description"><p>キーをマップして変換する</p>
<p>$callback が null を返すとその要素は取り除かれる。</p>
<p>Example:</p>
<pre><code class="language-php">that(array_map_key(['a' =&gt; 'A', 'b' =&gt; 'B'], 'strtoupper'))-&gt;isSame(['A' =&gt; 'A', 'B' =&gt; 'B']);
that(array_map_key(['a' =&gt; 'A', 'b' =&gt; 'B'], function(){}))-&gt;isSame([]);
</code></pre>
</div>
    	<h4 class="fqsen-title">method		<small></small>
		<a href="ryunosuke-Functions-Package-Arrays$typespace.html#ryunosuke\Functions\Package\Arrays::array_filter_key()">
                                    ryunosuke\Functions\Package\Arrays::array_filter_key		</a>	<small>($array, $callback) : array</small>
		</h4>
	<div class="description"><p>キーを主軸とした array_filter</p>
<p>$callback が要求するなら値も渡ってくる。 php 5.6 の array_filter の ARRAY_FILTER_USE_BOTH と思えばよい。<br />
ただし、完全な互換ではなく、引数順は ($k, $v) なので注意。</p>
<p>Example:</p>
<pre><code class="language-php">that(array_filter_key(['a', 'b', 'c'], function ($k, $v) { return $k !== 1; }))-&gt;isSame([0 =&gt; 'a', 2 =&gt; 'c']);
that(array_filter_key(['a', 'b', 'c'], function ($k, $v) { return $v !== 'b'; }))-&gt;isSame([0 =&gt; 'a', 2 =&gt; 'c']);
</code></pre>
</div>
    	<h4 class="fqsen-title">method		<small></small>
		<a href="ryunosuke-Functions-Package-Arrays$typespace.html#ryunosuke\Functions\Package\Arrays::array_where()">
                                    ryunosuke\Functions\Package\Arrays::array_where		</a>	<small>($array, $column = null, $callback = null) : array</small>
		</h4>
	<div class="description"><p>指定キーの要素で array_filter する</p>
<p>array_column があるなら array_where があってもいいはず。</p>
<p>$column はコールバックに渡ってくる配列のキー名を渡す。null を与えると行全体が渡ってくる。<br />
$callback は絞り込み条件を渡す。null を与えると true 相当の値でフィルタする。<br />
つまり $column も $callback も省略した場合、実質的に array_filter と同じ動作になる。</p>
<p>$column は配列を受け入れる。配列を渡した場合その値の共通項がコールバックに渡る。<br />
連想配列の場合は「キーのカラム == 値」で filter する（それぞれで AND。厳密かどうかは $callback で指定。説明が難しいので Example を参照）。</p>
<p>$callback が要求するならキーも渡ってくる。</p>
<p>Example:</p>
<pre><code class="language-php">$array = [
    0 =&gt; ['id' =&gt; 1, 'name' =&gt; 'hoge', 'flag' =&gt; false],
    1 =&gt; ['id' =&gt; 2, 'name' =&gt; 'fuga', 'flag' =&gt; true],
    2 =&gt; ['id' =&gt; 3, 'name' =&gt; 'piyo', 'flag' =&gt; false],
];
// 'flag' が true 相当のものだけ返す
that(array_where($array, 'flag'))-&gt;isSame([
    1 =&gt; ['id' =&gt; 2, 'name' =&gt; 'fuga', 'flag' =&gt; true],
]);
// 'name' に 'h' を含むものだけ返す
$contain_h = function($name){return strpos($name, 'h') !== false;};
that(array_where($array, 'name', $contain_h))-&gt;isSame([
    0 =&gt; ['id' =&gt; 1, 'name' =&gt; 'hoge', 'flag' =&gt; false],
]);
// $callback が引数2つならキーも渡ってくる（キーが 2 のものだけ返す）
$equal_2 = function($row, $key){return $key === 2;};
that(array_where($array, null, $equal_2))-&gt;isSame([
    2 =&gt; ['id' =&gt; 3, 'name' =&gt; 'piyo', 'flag' =&gt; false],
]);
// $column に配列を渡すと共通項が渡ってくる
$idname_is_2fuga = function($idname){return ($idname['id'] . $idname['name']) === '2fuga';};
that(array_where($array, ['id', 'name'], $idname_is_2fuga))-&gt;isSame([
    1 =&gt; ['id' =&gt; 2, 'name' =&gt; 'fuga', 'flag' =&gt; true],
]);
// $column に連想配列を渡すと「キーのカラム == 値」で filter する（要するに「name が piyo かつ flag が false」で filter）
that(array_where($array, ['name' =&gt; 'piyo', 'flag' =&gt; false]))-&gt;isSame([
    2 =&gt; ['id' =&gt; 3, 'name' =&gt; 'piyo', 'flag' =&gt; false],
]);
// 上記において値に配列を渡すと in_array で判定される
that(array_where($array, ['id' =&gt; [2, 3]]))-&gt;isSame([
    1 =&gt; ['id' =&gt; 2, 'name' =&gt; 'fuga', 'flag' =&gt; true],
    2 =&gt; ['id' =&gt; 3, 'name' =&gt; 'piyo', 'flag' =&gt; false],
]);
// $column の連想配列の値にはコールバックが渡せる（それぞれで AND）
that(array_where($array, [
    'id'   =&gt; function($id){return $id &gt;= 3;},                       // id が 3 以上
    'name' =&gt; function($name){return strpos($name, 'o') !== false;}, // name に o を含む
]))-&gt;isSame([
    2 =&gt; ['id' =&gt; 3, 'name' =&gt; 'piyo', 'flag' =&gt; false],
]);
</code></pre>
</div>
    	<h4 class="fqsen-title">method		<small></small>
		<a href="ryunosuke-Functions-Package-Arrays$typespace.html#ryunosuke\Functions\Package\Arrays::array_map_filter()">
                                    ryunosuke\Functions\Package\Arrays::array_map_filter		</a>	<small>($array, $callback, $strict = false) : array</small>
		</h4>
	<div class="description"><p>array_map + array_filter する</p>
<p>コールバックを適用して、結果が true 相当の要素のみ取り出す。<br />
$strict に true を与えると「null でない」要素のみ返される。</p>
<p>$callback が要求するならキーも渡ってくる。</p>
<p>Example:</p>
<pre><code class="language-php">that(array_map_filter([' a ', ' b ', ''], 'trim'))-&gt;isSame(['a', 'b']);
that(array_map_filter([' a ', ' b ', ''], 'trim', true))-&gt;isSame(['a', 'b', '']);
</code></pre>
</div>
    	<h4 class="fqsen-title">method		<small></small>
		<a href="ryunosuke-Functions-Package-Arrays$typespace.html#ryunosuke\Functions\Package\Arrays::array_map_method()">
                                    ryunosuke\Functions\Package\Arrays::array_map_method		</a>	<small>($array, $method, $args = [], $ignore = false) : array</small>
		</h4>
	<div class="description"><p>メソッドを指定できるようにした array_map</p>
<p>配列内の要素は全て同一（少なくともシグネチャが同じ $method が存在する）オブジェクトでなければならない。<br />
スルーする場合は $ignore=true とする。スルーした場合 map ではなく filter される（結果配列に含まれない）。<br />
$ignore=null とすると 何もせずそのまま要素を返す。</p>
<p>Example:</p>
<pre><code class="language-php">$exa = new \Exception('a');
$exb = new \Exception('b');
$std = new \stdClass();
// getMessage で map される
that(array_map_method([$exa, $exb], 'getMessage'))-&gt;isSame(['a', 'b']);
// getMessage で map されるが、メソッドが存在しない場合は取り除かれる
that(array_map_method([$exa, $exb, $std, null], 'getMessage', [], true))-&gt;isSame(['a', 'b']);
// getMessage で map されるが、メソッドが存在しない場合はそのまま返す
that(array_map_method([$exa, $exb, $std, null], 'getMessage', [], null))-&gt;isSame(['a', 'b', $std, null]);
</code></pre>
</div>
    	<h4 class="fqsen-title">method		<small></small>
		<a href="ryunosuke-Functions-Package-Arrays$typespace.html#ryunosuke\Functions\Package\Arrays::array_maps()">
                                    ryunosuke\Functions\Package\Arrays::array_maps		</a>	<small>($array, ...$callbacks) : array</small>
		</h4>
	<div class="description"><p>複数コールバックを指定できる array_map</p>
<p>指定したコールバックで複数回回してマップする。<br />
<code>array_maps($array, $f, $g)</code> は <code>array_map($g, array_map($f, $array))</code> とほぼ等しい。<br />
ただし、引数は順番が違う（可変引数のため）し、コールバックが要求するならキーも渡ってくる。<br />
さらに文字列関数で "..." から始まっているなら可変引数としてコールする。</p>
<p>少し変わった仕様として、コールバックに [$method =&gt; $args] を付けるとそれはメソッド呼び出しになる。<br />
つまり各要素 $v に対して <code>$v-&gt;$method(...$args)</code> がマップ結果になる。<br />
さらに引数が不要なら <code>@method</code> とするだけで良い。</p>
<p>Example:</p>
<pre><code class="language-php">// 値を3乗したあと16進表記にして大文字化する
that(array_maps([1, 2, 3, 4, 5], rbind('pow', 3), 'dechex', 'strtoupper'))-&gt;isSame(['1', '8', '1B', '40', '7D']);
// キーも渡ってくる
that(array_maps(['a' =&gt; 'A', 'b' =&gt; 'B'], function($v, $k){return "$k:$v";}))-&gt;isSame(['a' =&gt; 'a:A', 'b' =&gt; 'b:B']);
// ... で可変引数コール
that(array_maps([[1, 3], [1, 5, 2]], '...range'))-&gt;isSame([[1, 2, 3], [1, 3, 5]]);
// メソッドコールもできる（引数不要なら `@method` でも同じ）
that(array_maps([new \Exception('a'), new \Exception('b')], ['getMessage' =&gt; []]))-&gt;isSame(['a', 'b']);
that(array_maps([new \Exception('a'), new \Exception('b')], '@getMessage'))-&gt;isSame(['a', 'b']);
</code></pre>
</div>
    	<h4 class="fqsen-title">method		<small></small>
		<a href="ryunosuke-Functions-Package-Arrays$typespace.html#ryunosuke\Functions\Package\Arrays::array_kvmap()">
                                    ryunosuke\Functions\Package\Arrays::array_kvmap		</a>	<small>($array, $callback) : array</small>
		</h4>
	<div class="description"><p>配列の各キー・値にコールバックを適用する</p>
<p>$callback は (キー, 値, $callback) が渡ってくるので 「その位置に配置したい配列」を返せばそこに置換される。<br />
つまり、空配列を返せばそのキー・値は消えることになるし、複数の配列を返せば要素が増えることになる。<br />
ただし、数値キーは新しく採番される。<br />
null を返すと特別扱いで、そのキー・値をそのまま維持する。<br />
iterable を返す必要があるが、もし iterable でない場合は配列キャストされる。</p>
<p>「map も filter も可能でキー変更可能」というとてもマッチョな関数。<br />
実質的には「数値キーが再採番される再帰的でない array_convert」のように振る舞う。<br />
ただし、再帰処理はないので自前で管理する必要がある。</p>
<p>Example:</p>
<pre><code class="language-php">$array = [
   'a' =&gt; 'A',
   'b' =&gt; 'B',
   'c' =&gt; 'C',
   'd' =&gt; 'D',
];
// キーに '_' 、値に 'prefix-' を付与。'b' は一切何もしない。'c' は値のみ。'd' はそれ自体伏せる
that(array_kvmap($array, function($k, $v){
    if ($k === 'b') return null;
    if ($k === 'd') return [];
    if ($k !== 'c') $k = "_$k";
    return [$k =&gt; "prefix-$v"];
}))-&gt;isSame([
    '_a' =&gt; 'prefix-A',
    'b'  =&gt; 'B',
    'c'  =&gt; 'prefix-C',
]);

// 複数返せばその分増える（要素の水増し）
that(array_kvmap($array, function($k, $v){
    return [
        "{$k}1" =&gt; "{$v}1",
        "{$k}2" =&gt; "{$v}2",
    ];
}))-&gt;isSame([
   'a1' =&gt; 'A1',
   'a2' =&gt; 'A2',
   'b1' =&gt; 'B1',
   'b2' =&gt; 'B2',
   'c1' =&gt; 'C1',
   'c2' =&gt; 'C2',
   'd1' =&gt; 'D1',
   'd2' =&gt; 'D2',
]);

// $callback には $callback 自体も渡ってくるので再帰も比較的楽に書ける
that(array_kvmap([
    'x' =&gt; [
        'X',
        'y' =&gt; [
            'Y',
            'z' =&gt; ['Z'],
        ],
    ],
], function($k, $v, $callback){
    // 配列だったら再帰する
    return ["_$k" =&gt; is_array($v) ? array_kvmap($v, $callback) : "prefix-$v"];
}))-&gt;isSame([
    "_x" =&gt; [
        "_0" =&gt; "prefix-X",
        "_y" =&gt; [
            "_0" =&gt; "prefix-Y",
            "_z" =&gt; [
                "_0" =&gt; "prefix-Z",
            ],
        ],
    ],
]);
</code></pre>
</div>
    	<h4 class="fqsen-title">method		<small></small>
		<a href="ryunosuke-Functions-Package-Arrays$typespace.html#ryunosuke\Functions\Package\Arrays::array_kmap()">
                                    ryunosuke\Functions\Package\Arrays::array_kmap		</a>	<small>($array, $callback) : array</small>
		</h4>
	<div class="description"><p>キーも渡ってくる array_map</p>
<p><code>array_map($callback, $array, array_keys($array))</code> とほとんど変わりはない。<br />
違いは下記。</p>
<ul>
<li>引数の順番が異なる（$array が先）</li>
<li>キーが死なない（array_map は複数配列を与えるとキーが死ぬ）</li>
<li>配列だけでなく Traversable も受け入れる</li>
<li>callback の第3引数に 0 からの連番が渡ってくる</li>
</ul>
<p>Example:</p>
<pre><code class="language-php">// キー・値をくっつけるシンプルな例
that(array_kmap([
    'k1' =&gt; 'v1',
    'k2' =&gt; 'v2',
    'k3' =&gt; 'v3',
], function($v, $k){return "$k:$v";}))-&gt;isSame([
    'k1' =&gt; 'k1:v1',
    'k2' =&gt; 'k2:v2',
    'k3' =&gt; 'k3:v3',
]);
</code></pre>
</div>
    	<h4 class="fqsen-title">method		<small></small>
		<a href="ryunosuke-Functions-Package-Arrays$typespace.html#ryunosuke\Functions\Package\Arrays::array_nmap()">
                                    ryunosuke\Functions\Package\Arrays::array_nmap		</a>	<small>($array, $callback, $n, ...$variadic) : array</small>
		</h4>
	<div class="description"><p>要素値を $callback の n 番目(0ベース)に適用して array_map する</p>
<p>引数 $n に配列を与えると [キー番目 =&gt; 値番目] とみなしてキー・値も渡される（Example 参照）。<br />
その際、「挿入後の番目」ではなく、単純に「元の引数の番目」であることに留意。キー・値が同じ位置を指定している場合はキーが先にくる。</p>
<p>Example:</p>
<pre><code class="language-php">// 1番目に値を渡して map
$sprintf = function(){return vsprintf('%s%s%s', func_get_args());};
that(array_nmap(['a', 'b'], $sprintf, 1, 'prefix-', '-suffix'))-&gt;isSame(['prefix-a-suffix', 'prefix-b-suffix']);
// 1番目にキー、2番目に値を渡して map
$sprintf = function(){return vsprintf('%s %s %s %s %s', func_get_args());};
that(array_nmap(['k' =&gt; 'v'], $sprintf, [1 =&gt; 2], 'a', 'b', 'c'))-&gt;isSame(['k' =&gt; 'a k b v c']);
</code></pre>
</div>
    	<h4 class="fqsen-title">method		<small></small>
		<a href="ryunosuke-Functions-Package-Arrays$typespace.html#ryunosuke\Functions\Package\Arrays::array_lmap()">
                                    ryunosuke\Functions\Package\Arrays::array_lmap		</a>	<small>($array, $callback, ...$variadic) : array</small>
		</h4>
	<div class="description"><p>要素値を $callback の最左に適用して array_map する</p>
<p>Example:</p>
<pre><code class="language-php">$sprintf = function(){return vsprintf('%s%s', func_get_args());};
that(array_lmap(['a', 'b'], $sprintf, '-suffix'))-&gt;isSame(['a-suffix', 'b-suffix']);
</code></pre>
</div>
    	<h4 class="fqsen-title">method		<small></small>
		<a href="ryunosuke-Functions-Package-Arrays$typespace.html#ryunosuke\Functions\Package\Arrays::array_rmap()">
                                    ryunosuke\Functions\Package\Arrays::array_rmap		</a>	<small>($array, $callback, ...$variadic) : array</small>
		</h4>
	<div class="description"><p>要素値を $callback の最右に適用して array_map する</p>
<p>Example:</p>
<pre><code class="language-php">$sprintf = function(){return vsprintf('%s%s', func_get_args());};
that(array_rmap(['a', 'b'], $sprintf, 'prefix-'))-&gt;isSame(['prefix-a', 'prefix-b']);
</code></pre>
</div>
    	<h4 class="fqsen-title">method		<small></small>
		<a href="ryunosuke-Functions-Package-Arrays$typespace.html#ryunosuke\Functions\Package\Arrays::array_each()">
                                    ryunosuke\Functions\Package\Arrays::array_each		</a>	<small>($array, $callback, $default = null) : mixed</small>
		</h4>
	<div class="description"><p>array_reduce の参照版（のようなもの）</p>
<p>配列をループで回し、その途中経過、値、キー、連番をコールバック引数で渡して最終的な結果を返り値として返す。<br />
array_reduce と少し似てるが、下記の点が異なる。</p>
<ul>
<li>いわゆる $carry は返り値で表すのではなく、参照引数で表す</li>
<li>値だけでなくキー、連番も渡ってくる</li>
<li>巨大配列の場合でも速度劣化が少ない（array_reduce に巨大配列を渡すと実用にならないレベルで遅くなる）</li>
</ul>
<p>$callback の引数は <code>($value, $key, $n)</code> （$n はキーとは関係がない 0 ～ 要素数-1 の通し連番）。</p>
<p>返り値ではなく参照引数なので return する必要はない（ワンライナーが書きやすくなる）。<br />
返り値が空くのでループ制御に用いる。<br />
今のところ $callback が false を返すとそこで break するのみ。</p>
<p>第3引数を省略した場合、<strong>クロージャの第1引数のデフォルト値が使われる</strong>。<br />
これは特筆すべき動作で、不格好な第3引数を完全に省略することができる（サンプルコードを参照）。<br />
ただし「php の文法違反（今のところエラーにはならないし、全てにデフォルト値をつければ一応回避可能）」「リフレクションを使う（ほんの少し遅くなる）」などの弊害が有るので推奨はしない。<br />
（ただ、「意図していることをコードで表す」といった観点ではこの記法の方が正しいとも思う）。</p>
<p>Example:</p>
<pre><code class="language-php">// 全要素を文字列的に足し合わせる
that(array_each([1, 2, 3, 4, 5], function(&amp;$carry, $v){$carry .= $v;}, ''))-&gt;isSame('12345');
// 値をキーにして要素を2乗値にする
that(array_each([1, 2, 3, 4, 5], function(&amp;$carry, $v){$carry[$v] = $v * $v;}, []))-&gt;isSame([
    1 =&gt; 1,
    2 =&gt; 4,
    3 =&gt; 9,
    4 =&gt; 16,
    5 =&gt; 25,
]);
// 上記と同じ。ただし、3 で break する
that(array_each([1, 2, 3, 4, 5], function(&amp;$carry, $v, $k){
    if ($k === 3) return false;
    $carry[$v] = $v * $v;
}, []))-&gt;isSame([
    1 =&gt; 1,
    2 =&gt; 4,
    3 =&gt; 9,
]);

// 下記は完全に同じ（第3引数の代わりにデフォルト引数を使っている）
that(array_each([1, 2, 3], function(&amp;$carry = [], $v) {
        $carry[$v] = $v * $v;
    }))-&gt;isSame(array_each([1, 2, 3], function(&amp;$carry, $v) {
        $carry[$v] = $v * $v;
    }, [])
    // 個人的に↑のようなぶら下がり引数があまり好きではない（クロージャを最後の引数にしたい）
);
</code></pre>
</div>
    	<h4 class="fqsen-title">method		<small></small>
		<a href="ryunosuke-Functions-Package-Arrays$typespace.html#ryunosuke\Functions\Package\Arrays::array_depth()">
                                    ryunosuke\Functions\Package\Arrays::array_depth		</a>	<small>($array, $max_depth = null) : int</small>
		</h4>
	<div class="description"><p>配列の次元数を返す</p>
<p>フラット配列は 1 と定義する。<br />
つまり、配列を与える限りは 0 以下を返すことはない。</p>
<p>第2引数 $max_depth を与えるとその階層になった時点で走査を打ち切る。<br />
「1階層のみか？」などを調べるときは指定したほうが高速に動作する。</p>
<p>Example:</p>
<pre><code class="language-php">that(array_depth([]))-&gt;isSame(1);
that(array_depth(['hoge']))-&gt;isSame(1);
that(array_depth([['nest1' =&gt; ['nest2']]]))-&gt;isSame(3);
</code></pre>
</div>
    	<h4 class="fqsen-title">method		<small></small>
		<a href="ryunosuke-Functions-Package-Arrays$typespace.html#ryunosuke\Functions\Package\Arrays::array_insert()">
                                    ryunosuke\Functions\Package\Arrays::array_insert		</a>	<small>($array, $value, $position = null) : array</small>
		</h4>
	<div class="description"><p>配列・連想配列を問わず任意の位置に値を挿入する</p>
<p>$position を省略すると最後に挿入される（≒ array_push）。<br />
$position に負数を与えると後ろから数えられる。<br />
$value には配列も与えられるが、その場合数値キーは振り直される</p>
<p>Example:</p>
<pre><code class="language-php">that(array_insert([1, 2, 3], 'x'))-&gt;isSame([1, 2, 3, 'x']);
that(array_insert([1, 2, 3], 'x', 1))-&gt;isSame([1, 'x', 2, 3]);
that(array_insert([1, 2, 3], 'x', -1))-&gt;isSame([1, 2, 'x', 3]);
that(array_insert([1, 2, 3], ['a' =&gt; 'A', 'b' =&gt; 'B'], 1))-&gt;isSame([1, 'a' =&gt; 'A', 'b' =&gt; 'B', 2, 3]);
</code></pre>
</div>
    	<h4 class="fqsen-title">method		<small></small>
		<a href="ryunosuke-Functions-Package-Arrays$typespace.html#ryunosuke\Functions\Package\Arrays::array_assort()">
                                    ryunosuke\Functions\Package\Arrays::array_assort		</a>	<small>($array, $rules) : array</small>
		</h4>
	<div class="description"><p>配列をコールバックに従って分類する</p>
<p>コールバックは配列で複数与える。そのキーが結果配列のキーになるが、一切マッチしなくてもキー自体は作られる。<br />
複数のコールバックにマッチしたらその分代入されるし、どれにもマッチしなければ代入されない。<br />
つまり5個の配列を分類したからと言って、全要素数が5個になるとは限らない（多い場合も少ない場合もある）。</p>
<p>$rule が要求するならキーも渡ってくる。</p>
<p>Example:</p>
<pre><code class="language-php">// lt2(2より小さい)で分類
$lt2 = function($v){return $v &lt; 2;};
that(array_assort([1, 2, 3], [
    'lt2' =&gt; $lt2,
]))-&gt;isSame([
    'lt2' =&gt; [1],
]);
// lt3(3より小さい)、ctd(ctype_digit)で分類（両方に属する要素が存在する）
$lt3 = function($v){return $v &lt; 3;};
that(array_assort(['1', '2', '3'], [
    'lt3' =&gt; $lt3,
    'ctd' =&gt; 'ctype_digit',
]))-&gt;isSame([
    'lt3' =&gt; ['1', '2'],
    'ctd' =&gt; ['1', '2', '3'],
]);
</code></pre>
</div>
    	<h4 class="fqsen-title">method		<small></small>
		<a href="ryunosuke-Functions-Package-Arrays$typespace.html#ryunosuke\Functions\Package\Arrays::array_count()">
                                    ryunosuke\Functions\Package\Arrays::array_count		</a>	<small>($array, $callback) : int<span class="type-separator"></span><wbr>array</small>
		</h4>
	<div class="description"><p>配列をコールバックに従ってカウントする</p>
<p>コールバックが true 相当を返した要素をカウントして返す。<br />
普通に使う分には <code>count(array_filter($array, $callback))</code> とほとんど同じだが、下記の点が微妙に異なる。</p>
<ul>
<li>$callback が要求するならキーも渡ってくる</li>
<li>$callback には配列が渡せる。配列を渡した場合は件数を配列で返す（Example 参照）</li>
</ul>
<p>Example:</p>
<pre><code class="language-php">$array = ['hoge', 'fuga', 'piyo'];
// 'o' を含むものの数（2個）
that(array_count($array, function($s){return strpos($s, 'o') !== false;}))-&gt;isSame(2);
// 'a' と 'o' を含むものをそれぞれ（1個と2個）
that(array_count($array, [
    'a' =&gt; function($s){return strpos($s, 'a') !== false;},
    'o' =&gt; function($s){return strpos($s, 'o') !== false;},
]))-&gt;isSame([
    'a' =&gt; 1,
    'o' =&gt; 2,
]);
</code></pre>
</div>
    	<h4 class="fqsen-title">method		<small></small>
		<a href="ryunosuke-Functions-Package-Arrays$typespace.html#ryunosuke\Functions\Package\Arrays::array_group()">
                                    ryunosuke\Functions\Package\Arrays::array_group		</a>	<small>($array, $callback = null, $preserve_keys = false) : array</small>
		</h4>
	<div class="description"><p>配列をコールバックの返り値でグループ化する</p>
<p>コールバックを省略すると値そのもので評価する。<br />
コールバックが配列を返すと入れ子としてグループ化する。</p>
<p>Example:</p>
<pre><code class="language-php">that(array_group([1, 1, 1]))-&gt;isSame([
    1 =&gt; [1, 1, 1],
]);
that(array_group([1, 2, 3], function($v){return $v % 2;}))-&gt;isSame([
    1 =&gt; [1, 3],
    0 =&gt; [2],
]);
// group -&gt; id で入れ子グループにする
$row1 = ['id' =&gt; 1, 'group' =&gt; 'hoge'];
$row2 = ['id' =&gt; 2, 'group' =&gt; 'fuga'];
$row3 = ['id' =&gt; 3, 'group' =&gt; 'hoge'];
that(array_group([$row1, $row2, $row3], function($row){return [$row['group'], $row['id']];}))-&gt;isSame([
    'hoge' =&gt; [
        1 =&gt; $row1,
        3 =&gt; $row3,
    ],
    'fuga' =&gt; [
        2 =&gt; $row2,
    ],
]);
</code></pre>
</div>
    	<h4 class="fqsen-title">method		<small></small>
		<a href="ryunosuke-Functions-Package-Arrays$typespace.html#ryunosuke\Functions\Package\Arrays::array_aggregate()">
                                    ryunosuke\Functions\Package\Arrays::array_aggregate		</a>	<small>($array, $columns, $key = null) : array</small>
		</h4>
	<div class="description"><p>配列をコールバックの返り値で集計する</p>
<p>$columns で集計列を指定する。<br />
単一の callable を渡すと結果も単一になる。<br />
複数の callable 連想配列を渡すと [キー =&gt; 集系列] の連想配列になる。<br />
いずれにせよ引数としてそのグループの配列が渡ってくるので返り値がその列の値になる。<br />
第2引数には「今までの結果が詰まった配列」が渡ってくる（count, avg, sum など何度もでてくる集計で便利）。</p>
<p>$key で集約列を指定する。<br />
指定しなければ引数の配列そのままで集計される。<br />
複数要素の配列を与えるとその数分潜って集計される。<br />
クロージャを与えると返り値がキーになる。</p>
<p>Example:</p>
<pre><code class="language-php">// 単純な配列の集計
that(array_aggregate([1, 2, 3], [
    'min' =&gt; function($elems) {return min($elems);},
    'max' =&gt; function($elems) {return max($elems);},
    'avg' =&gt; function($elems) {return array_sum($elems) / count($elems);},
]))-&gt;isSame([
    'min' =&gt; 1, // 最小値
    'max' =&gt; 3, // 最大値
    'avg' =&gt; 2, // 平均値
]);

$row1 = ['user_id' =&gt; 'hoge', 'group' =&gt; 'A', 'score' =&gt; 4];
$row2 = ['user_id' =&gt; 'fuga', 'group' =&gt; 'B', 'score' =&gt; 6];
$row3 = ['user_id' =&gt; 'fuga', 'group' =&gt; 'A', 'score' =&gt; 5];
$row4 = ['user_id' =&gt; 'hoge', 'group' =&gt; 'A', 'score' =&gt; 8];

// user_id, group ごとの score を集計して階層配列で返す（第2引数 $current を利用している）
that(array_aggregate([$row1, $row2, $row3, $row4], [
    'scores' =&gt; function($rows) {return array_column($rows, 'score');},
    'score'  =&gt; function($rows, $current) {return array_sum($current['scores']);},
], ['user_id', 'group']))-&gt;isSame([
    'hoge' =&gt; [
        'A' =&gt; [
            'scores' =&gt; [4, 8],
            'score'  =&gt; 12,
        ],
    ],
    'fuga' =&gt; [
        'B' =&gt; [
            'scores' =&gt; [6],
            'score'  =&gt; 6,
        ],
        'A' =&gt; [
            'scores' =&gt; [5],
            'score'  =&gt; 5,
        ],
    ],
]);

// user_id ごとの score を集計して単一列で返す（キーのクロージャも利用している）
that(array_aggregate([$row1, $row2, $row3, $row4],
    function($rows) {return array_sum(array_column($rows, 'score'));},
    function($row) {return strtoupper($row['user_id']);}))-&gt;isSame([
    'HOGE' =&gt; 12,
    'FUGA' =&gt; 11,
]);
</code></pre>
</div>
    	<h4 class="fqsen-title">method		<small></small>
		<a href="ryunosuke-Functions-Package-Arrays$typespace.html#ryunosuke\Functions\Package\Arrays::array_all()">
                                    ryunosuke\Functions\Package\Arrays::array_all		</a>	<small>($array, $callback = null, $default = true) : bool</small>
		</h4>
	<div class="description"><p>全要素が true になるなら true を返す（1つでも false なら false を返す）</p>
<p>$callback が要求するならキーも渡ってくる。</p>
<p>Example:</p>
<pre><code class="language-php">that(array_all([true, true]))-&gt;isTrue();
that(array_all([true, false]))-&gt;isFalse();
that(array_all([false, false]))-&gt;isFalse();
</code></pre>
</div>
    	<h4 class="fqsen-title">method		<small></small>
		<a href="ryunosuke-Functions-Package-Arrays$typespace.html#ryunosuke\Functions\Package\Arrays::array_any()">
                                    ryunosuke\Functions\Package\Arrays::array_any		</a>	<small>($array, $callback = null, $default = false) : bool</small>
		</h4>
	<div class="description"><p>全要素が false になるなら false を返す（1つでも true なら true を返す）</p>
<p>$callback が要求するならキーも渡ってくる。</p>
<p>Example:</p>
<pre><code class="language-php">that(array_any([true, true]))-&gt;isTrue();
that(array_any([true, false]))-&gt;isTrue();
that(array_any([false, false]))-&gt;isFalse();
</code></pre>
</div>
    	<h4 class="fqsen-title">method		<small></small>
		<a href="ryunosuke-Functions-Package-Arrays$typespace.html#ryunosuke\Functions\Package\Arrays::array_distinct()">
                                    ryunosuke\Functions\Package\Arrays::array_distinct		</a>	<small>($array, $comparator = null) : array</small>
		</h4>
	<div class="description"><p>比較関数が渡せる array_unique</p>
<p>array_unique は微妙に癖があるのでシンプルに使いやすくしたもの。</p>
<ul>
<li>SORT_STRING|SORT_FLAG_CASE のような指定が使える（大文字小文字を無視した重複除去）<ul>
<li>厳密に言えば array_unique も指定すれば動く（が、ドキュメントに記載がない）</li>
</ul>
</li>
<li>配列を渡すと下記の動作になる<ul>
<li>数値キーは配列アクセス</li>
<li>文字キーはメソッドコール（値は引数）</li>
</ul>
</li>
<li>もちろん（$a, $b を受け取る）クロージャも渡せる</li>
</ul>
<p>Example:</p>
<pre><code class="language-php">// シンプルな重複除去
that(array_distinct([1, 2, 3, '3']))-&gt;isSame([1, 2, 3]);
// 大文字小文字を無視した重複除去
that(array_distinct(['a', 'b', 'A', 'B'], SORT_STRING|SORT_FLAG_CASE))-&gt;isSame(['a', 'b']);

$v1 = new \ArrayObject(['id' =&gt; '1', 'group' =&gt; 'aaa']);
$v2 = new \ArrayObject(['id' =&gt; '2', 'group' =&gt; 'bbb', 'dummy' =&gt; 123]);
$v3 = new \ArrayObject(['id' =&gt; '3', 'group' =&gt; 'aaa', 'dummy' =&gt; 456]);
$v4 = new \ArrayObject(['id' =&gt; '4', 'group' =&gt; 'bbb', 'dummy' =&gt; 789]);
// クロージャを指定して重複除去
that(array_distinct([$v1, $v2, $v3, $v4], function($a, $b) { return $a['group'] &lt;=&gt; $b['group']; }))-&gt;isSame([$v1, $v2]);
// 単純な配列アクセスなら文字列や配列でよい（上記と同じ結果になる）
that(array_distinct([$v1, $v2, $v3, $v4], 'group'))-&gt;isSame([$v1, $v2]);
// 文字キーの配列はメソッドコールになる（ArrayObject::count で重複検出）
that(array_distinct([$v1, $v2, $v3, $v4], ['count' =&gt; []]))-&gt;isSame([$v1, $v2]);
// 上記2つは混在できる（group キー + count メソッドで重複検出。端的に言えば "aaa+2", "bbb+3", "aaa+3", "bbb+3" で除去）
that(array_distinct([$v1, $v2, $v3, $v4], ['group', 'count' =&gt; []]))-&gt;isSame([$v1, $v2, 2 =&gt; $v3]);
</code></pre>
</div>
    	<h4 class="fqsen-title">method		<small></small>
		<a href="ryunosuke-Functions-Package-Arrays$typespace.html#ryunosuke\Functions\Package\Arrays::array_order()">
                                    ryunosuke\Functions\Package\Arrays::array_order		</a>	<small>($array, $orders, $preserve_keys = false) : array</small>
		</h4>
	<div class="description"><p>配列を $orders に従って並べ替える</p>
<p>データベースからフェッチしたような連想配列の配列を想定しているが、スカラー配列(['key' =&gt; 'value'])にも対応している。<br />
その場合 $orders に配列ではなく直値を渡せば良い。</p>
<p>$orders には下記のような配列を渡す。<br />
キーに空文字を渡すとそれは「キー自体」を意味する。</p>
<pre><code class="language-php">$orders = [
    'col1' =&gt; true,                               // true: 昇順, false: 降順。照合は型に依存
    'col2' =&gt; SORT_NATURAL,                       // SORT_NATURAL, SORT_REGULAR などで照合。正数で昇順、負数で降順
    'col3' =&gt; ['sort', 'this', 'order'],          // 指定した配列順で昇順
    'col4' =&gt; function($v) {return $v;},          // クロージャを通した値で昇順。照合は返り値の型に依存
    'col5' =&gt; function($a, $b) {return $a - $b;}, // クロージャで比較して昇順（いわゆる比較関数を渡す）
];
</code></pre>
<p>Example:</p>
<pre><code class="language-php">$v1 = ['id' =&gt; '1', 'no' =&gt; 'a03', 'name' =&gt; 'yyy'];
$v2 = ['id' =&gt; '2', 'no' =&gt; 'a4',  'name' =&gt; 'yyy'];
$v3 = ['id' =&gt; '3', 'no' =&gt; 'a12', 'name' =&gt; 'xxx'];
// name 昇順, no 自然降順
that(array_order([$v1, $v2, $v3], ['name' =&gt; true, 'no' =&gt; -SORT_NATURAL]))-&gt;isSame([$v3, $v2, $v1]);
</code></pre>
</div>
    	<h4 class="fqsen-title">method		<small></small>
		<a href="ryunosuke-Functions-Package-Arrays$typespace.html#ryunosuke\Functions\Package\Arrays::array_shuffle()">
                                    ryunosuke\Functions\Package\Arrays::array_shuffle		</a>	<small>($array) : array</small>
		</h4>
	<div class="description"><p>shuffle のキーが保存される＋参照渡しではない版</p>
<p>Example:</p>
<pre><code class="language-php">that(array_shuffle(['a' =&gt; 'A', 'b' =&gt; 'B', 'c' =&gt; 'C']))-&gt;is(['b' =&gt; 'B', 'a' =&gt; 'A', 'c' =&gt; 'C']);
</code></pre>
</div>
    	<h4 class="fqsen-title">method		<small></small>
		<a href="ryunosuke-Functions-Package-Arrays$typespace.html#ryunosuke\Functions\Package\Arrays::array_shrink_key()">
                                    ryunosuke\Functions\Package\Arrays::array_shrink_key		</a>	<small>(...$variadic) : array</small>
		</h4>
	<div class="description"><p>値の優先順位を逆にした array_intersect_key</p>
<p>array_intersect_key は「左優先で共通項を取る」という動作だが、この関数は「右優先で共通項を取る」という動作になる。<br />
「配列の並び順はそのままで値だけ変えたい/削ぎ落としたい」という状況はまれによくあるはず。</p>
<p>Example:</p>
<pre><code class="language-php">$array1 = ['a' =&gt; 'A1', 'b' =&gt; 'B1', 'c' =&gt; 'C1'];
$array2 = ['c' =&gt; 'C2', 'b' =&gt; 'B2', 'a' =&gt; 'A2'];
$array3 = ['c' =&gt; 'C3', 'dummy' =&gt; 'DUMMY'];
// 全共通項である 'c' キーのみが生き残り、その値は最後の 'C3' になる
that(array_shrink_key($array1, $array2, $array3))-&gt;isSame(['c' =&gt; 'C3']);
</code></pre>
</div>
    	<h4 class="fqsen-title">method		<small></small>
		<a href="ryunosuke-Functions-Package-Arrays$typespace.html#ryunosuke\Functions\Package\Arrays::array_fill_gap()">
                                    ryunosuke\Functions\Package\Arrays::array_fill_gap		</a>	<small>($array, ...$values) : array</small>
		</h4>
	<div class="description"><p>配列の隙間を埋める</p>
<p>「隙間」とは数値キーの隙間のこと。文字キーには関与しない。<br />
連番の抜けている箇所に $values の値を順次詰めていく動作となる。</p>
<p>値が足りなくてもエラーにはならない。つまり、この関数を通したとしても隙間が無くなるわけではない。<br />
また、隙間を埋めても値が余る場合（隙間より与えられた値が多い場合）は末尾に全て追加される。</p>
<p>負数キーは考慮しない。</p>
<p>Example:</p>
<pre><code class="language-php">// ところどころキーが抜け落ちている配列の・・・
$array = [
    1 =&gt; 'b',
    2 =&gt; 'c',
    5 =&gt; 'f',
    7 =&gt; 'h',
];
// 抜けているところを可変引数で順次埋める（'i', 'j' は隙間というより末尾追加）
that(array_fill_gap($array, 'a', 'd', 'e', 'g', 'i', 'j'))-&gt;isSame([
    0 =&gt; 'a',
    1 =&gt; 'b',
    2 =&gt; 'c',
    3 =&gt; 'd',
    4 =&gt; 'e',
    5 =&gt; 'f',
    6 =&gt; 'g',
    7 =&gt; 'h',
    8 =&gt; 'i',
    9 =&gt; 'j',
]);

// 文字キーには関与しないし、値は足りなくても良い
$array = [
    1   =&gt; 'b',
    'x' =&gt; 'noize',
    4   =&gt; 'e',
    'y' =&gt; 'noize',
    7   =&gt; 'h',
    'z' =&gt; 'noize',
];
// 文字キーはそのまま保持され、値が足りないので 6 キーはない
that(array_fill_gap($array, 'a', 'c', 'd', 'f'))-&gt;isSame([
    0   =&gt; 'a',
    1   =&gt; 'b',
    'x' =&gt; 'noize',
    2   =&gt; 'c',
    3   =&gt; 'd',
    4   =&gt; 'e',
    'y' =&gt; 'noize',
    5   =&gt; 'f',
    7   =&gt; 'h',
    'z' =&gt; 'noize',
]);
</code></pre>
</div>
    	<h4 class="fqsen-title">method		<small></small>
		<a href="ryunosuke-Functions-Package-Arrays$typespace.html#ryunosuke\Functions\Package\Arrays::array_fill_callback()">
                                    ryunosuke\Functions\Package\Arrays::array_fill_callback		</a>	<small>($keys, $callback) : array</small>
		</h4>
	<div class="description"><p>array_fill_keys のコールバック版のようなもの</p>
<p>指定したキー配列をそれらのマップしたもので配列を生成する。<br />
<code>array_combine($keys, array_map($callback, $keys))</code> とほぼ等価。</p>
<p>Example:</p>
<pre><code class="language-php">$abc = ['a', 'b', 'c'];
// [a, b, c] から [a =&gt; A, b =&gt; B, c =&gt; C] を作る
that(array_fill_callback($abc, 'strtoupper'))-&gt;isSame([
    'a' =&gt; 'A',
    'b' =&gt; 'B',
    'c' =&gt; 'C',
]);
// [a, b, c] からその sha1 配列を作って大文字化する
that(array_fill_callback($abc, function ($v){ return strtoupper(sha1($v)); }))-&gt;isSame([
    'a' =&gt; '86F7E437FAA5A7FCE15D1DDCB9EAEAEA377667B8',
    'b' =&gt; 'E9D71F5EE7C92D6DC9E92FFDAD17B8BD49418F98',
    'c' =&gt; '84A516841BA77A5B4648DE2CD0DFCB30EA46DBB4',
]);
</code></pre>
</div>
    	<h4 class="fqsen-title">method		<small></small>
		<a href="ryunosuke-Functions-Package-Arrays$typespace.html#ryunosuke\Functions\Package\Arrays::array_pickup()">
                                    ryunosuke\Functions\Package\Arrays::array_pickup		</a>	<small>($array, $keys) : array</small>
		</h4>
	<div class="description"><p>キーを指定してそれだけの配列にする</p>
<p><code>array_intersect_key($array, array_flip($keys))</code> とほぼ同義。<br />
違いは Traversable を渡せることと、結果配列の順番が $keys に従うこと。</p>
<p>$keys に連想配列を渡すとキーを読み替えて動作する（Example を参照）。</p>
<p>Example:</p>
<pre><code class="language-php">$array = ['a' =&gt; 'A', 'b' =&gt; 'B', 'c' =&gt; 'C'];
// a と c を取り出す
that(array_pickup($array, ['a', 'c']))-&gt;isSame(['a' =&gt; 'A', 'c' =&gt; 'C']);
// 順番は $keys 基準になる
that(array_pickup($array, ['c', 'a']))-&gt;isSame(['c' =&gt; 'C', 'a' =&gt; 'A']);
// 連想配列を渡すと読み替えて返す
that(array_pickup($array, ['c' =&gt; 'cX', 'a' =&gt; 'aX']))-&gt;isSame(['cX' =&gt; 'C', 'aX' =&gt; 'A']);
</code></pre>
</div>
    	<h4 class="fqsen-title">method		<small></small>
		<a href="ryunosuke-Functions-Package-Arrays$typespace.html#ryunosuke\Functions\Package\Arrays::array_remove()">
                                    ryunosuke\Functions\Package\Arrays::array_remove		</a>	<small>($array, $keys) : array</small>
		</h4>
	<div class="description"><p>キーを指定してそれらを除いた配列にする</p>
<p><code>array_diff_key($array, array_flip($keys))</code> とほぼ同義。<br />
違いは Traversable を渡せること。</p>
<p>array_pickup の逆とも言える。</p>
<p>Example:</p>
<pre><code class="language-php">$array = ['a' =&gt; 'A', 'b' =&gt; 'B', 'c' =&gt; 'C'];
// a と c を伏せる（b を残す）
that(array_remove($array, ['a', 'c']))-&gt;isSame(['b' =&gt; 'B']);
</code></pre>
</div>
    	<h4 class="fqsen-title">method		<small></small>
		<a href="ryunosuke-Functions-Package-Arrays$typespace.html#ryunosuke\Functions\Package\Arrays::array_lookup()">
                                    ryunosuke\Functions\Package\Arrays::array_lookup		</a>	<small>($array, $column_key = null, $index_key = null) : array</small>
		</h4>
	<div class="description"><p>キー保存可能な array_column</p>
<p>array_column は キーを保存することが出来ないが、この関数は引数を2つだけ与えるとキーはそのままで array_column 相当の配列を返す。<br />
逆に第3引数にクロージャを与えるとその結果をキーにすることが出来る。</p>
<p>Example:</p>
<pre><code class="language-php">$array = [
    11 =&gt; ['id' =&gt; 1, 'name' =&gt; 'name1'],
    12 =&gt; ['id' =&gt; 2, 'name' =&gt; 'name2'],
    13 =&gt; ['id' =&gt; 3, 'name' =&gt; 'name3'],
];
// 第3引数を渡せば array_column と全く同じ
that(array_lookup($array, 'name', 'id'))-&gt;isSame(array_column($array, 'name', 'id'));
that(array_lookup($array, 'name', null))-&gt;isSame(array_column($array, 'name', null));
// 省略すればキーが保存される
that(array_lookup($array, 'name'))-&gt;isSame([
    11 =&gt; 'name1',
    12 =&gt; 'name2',
    13 =&gt; 'name3',
]);
// クロージャを指定すればキーが生成される
that(array_lookup($array, 'name', function ($v, $k) {return $k * 2;}))-&gt;isSame([
    22 =&gt; 'name1',
    24 =&gt; 'name2',
    26 =&gt; 'name3',
]);
</code></pre>
</div>
    	<h4 class="fqsen-title">method		<small></small>
		<a href="ryunosuke-Functions-Package-Arrays$typespace.html#ryunosuke\Functions\Package\Arrays::array_select()">
                                    ryunosuke\Functions\Package\Arrays::array_select		</a>	<small>($array, $columns, $index = null) : array</small>
		</h4>
	<div class="description"><p>指定キーの要素で抽出する</p>
<p>$columns に単純な値を渡すとそのキーの値を選択する。<br />
キー付きで値を渡すと読み替えて選択する。<br />
キー付きでクロージャを渡すと <code>(キーの値, 行自体, 現在行のキー)</code> を引数としてコールバックして選択する。<br />
単一のクロージャを渡すと <code>(行自体, 現在行のキー)</code> を引数としてコールバックして選択する（array_map とほぼ同じ）。</p>
<p>Example:</p>
<pre><code class="language-php">$array = [
    11 =&gt; ['id' =&gt; 1, 'name' =&gt; 'name1'],
    12 =&gt; ['id' =&gt; 2, 'name' =&gt; 'name2'],
    13 =&gt; ['id' =&gt; 3, 'name' =&gt; 'name3'],
];

that(array_select($array, [
    'id',              // id を単純取得
    'alias' =&gt; 'name', // name を alias として取得
]))-&gt;isSame([
    11 =&gt; ['id' =&gt; 1, 'alias' =&gt; 'name1'],
    12 =&gt; ['id' =&gt; 2, 'alias' =&gt; 'name2'],
    13 =&gt; ['id' =&gt; 3, 'alias' =&gt; 'name3'],
]);

that(array_select($array, [
    // id の 10 倍を取得
    'id'     =&gt; function ($id) {return $id * 10;},
    // id と name の結合を取得
    'idname' =&gt; function ($null, $row, $index) {return $row['id'] . $row['name'];},
]))-&gt;isSame([
    11 =&gt; ['id' =&gt; 10, 'idname' =&gt; '1name1'],
    12 =&gt; ['id' =&gt; 20, 'idname' =&gt; '2name2'],
    13 =&gt; ['id' =&gt; 30, 'idname' =&gt; '3name3'],
]);
</code></pre>
</div>
    	<h4 class="fqsen-title">method		<small></small>
		<a href="ryunosuke-Functions-Package-Arrays$typespace.html#ryunosuke\Functions\Package\Arrays::array_columns()">
                                    ryunosuke\Functions\Package\Arrays::array_columns		</a>	<small>($array, $column_keys = null, $index_key = null) : array</small>
		</h4>
	<div class="description"><p>全要素に対して array_column する</p>
<p>行列が逆転するイメージ。</p>
<p>Example:</p>
<pre><code class="language-php">$row1 = ['id' =&gt; 1, 'name' =&gt; 'A'];
$row2 = ['id' =&gt; 2, 'name' =&gt; 'B'];
$rows = [$row1, $row2];
that(array_columns($rows))-&gt;isSame(['id' =&gt; [1, 2], 'name' =&gt; ['A', 'B']]);
that(array_columns($rows, 'id'))-&gt;isSame(['id' =&gt; [1, 2]]);
that(array_columns($rows, 'name', 'id'))-&gt;isSame(['name' =&gt; [1 =&gt; 'A', 2 =&gt; 'B']]);
</code></pre>
</div>
    	<h4 class="fqsen-title">method		<small></small>
		<a href="ryunosuke-Functions-Package-Arrays$typespace.html#ryunosuke\Functions\Package\Arrays::array_uncolumns()">
                                    ryunosuke\Functions\Package\Arrays::array_uncolumns		</a>	<small>($array, $template = null) : array</small>
		</h4>
	<div class="description"><p>array_columns のほぼ逆で [キー =&gt; [要素]] 配列から連想配列の配列を生成する</p>
<p>$template を指定すると「それに含まれる配列かつ値がデフォルト」になる（要するに $default みたいなもの）。<br />
キーがバラバラな配列を指定する場合は指定したほうが良い。が、null を指定すると最初の要素が使われるので大抵の場合は null で良い。</p>
<p>Example:</p>
<pre><code class="language-php">that(array_uncolumns([
    'id'   =&gt; [1, 2],
    'name' =&gt; ['A', 'B'],
]))-&gt;isSame([
    ['id' =&gt; 1, 'name' =&gt; 'A'],
    ['id' =&gt; 2, 'name' =&gt; 'B'],
]);
</code></pre>
</div>
    	<h4 class="fqsen-title">method		<small></small>
		<a href="ryunosuke-Functions-Package-Arrays$typespace.html#ryunosuke\Functions\Package\Arrays::array_convert()">
                                    ryunosuke\Functions\Package\Arrays::array_convert		</a>	<small>($array, $callback, $apply_array = false) : array</small>
		</h4>
	<div class="description"><p>配列の各要素に再帰的にコールバックを適用して変換する</p>
<p>$callback は下記の仕様。</p>
<p>引数は (キー, 値, 今まで処理したキー配列) で渡ってくる。<br />
返り値は新しいキーを返す。</p>
<ul>
<li>文字列や数値を返すとそれがキーとして使われる</li>
<li>null を返すと元のキーがそのまま使われる</li>
<li>true を返すと数値連番が振られる</li>
<li>false を返すとその要素は無かったことになる</li>
<li>配列を返すとその配列で完全に置換される</li>
</ul>
<p>$apply_array=false で要素が配列の場合は再帰され、コールバックが適用されない（array_walk_recursive と同じ仕様）。</p>
<p>$apply_array=true だと配列かは問わず全ての要素にコールバックが適用される。<br />
配列も渡ってきてしまうのでコールバック内部で is_array 判定が必要になる場合がある。</p>
<p>「map も filter も可能でキー変更可能かつ再帰的」というとてもマッチョな関数。<br />
複雑だが実質的には「キーも設定できる array_walk_recursive」のように振る舞う（そしてそのような使い方を想定している）。</p>
<p>Example:</p>
<pre><code class="language-php">$array = [
   'k1' =&gt; 'v1',
   'k2' =&gt; [
       'k21' =&gt; 'v21',
       'k22' =&gt; [
           'k221' =&gt; 'v221',
           'k222' =&gt; 'v222',
       ],
       'k23' =&gt; 'v23',
   ],
];
// 全要素に 'prefix-' を付与する。キーには '_' をつける。ただし 'k21' はそのままとする。さらに 'k22' はまるごと伏せる。 'k23' は数値キーになる
$callback = function($k, &amp;$v){
    if ($k === 'k21') return null;
    if ($k === 'k22') return false;
    if ($k === 'k23') return true;
    if (!is_array($v)) $v = "prefix-$v";
    return "_$k";
};
that(array_convert($array, $callback, true))-&gt;isSame([
    '_k1' =&gt; 'prefix-v1',
    '_k2' =&gt; [
        'k21' =&gt; 'v21',
        0     =&gt; 'v23',
    ],
]);
</code></pre>
</div>
    	<h4 class="fqsen-title">method		<small></small>
		<a href="ryunosuke-Functions-Package-Arrays$typespace.html#ryunosuke\Functions\Package\Arrays::array_flatten()">
                                    ryunosuke\Functions\Package\Arrays::array_flatten		</a>	<small>($array, $delimiter = null) : array</small>
		</h4>
	<div class="description"><p>多階層配列をフラットに展開する</p>
<p>巷にあふれている実装と違って、 ["$pkey.$ckey" =&gt; $value] 形式の配列でも返せる。<br />
$delimiter で区切り文字を指定した場合にそのようになる。<br />
$delimiter = null の場合に本当の配列で返す（巷の実装と同じ）。</p>
<p>Example:</p>
<pre><code class="language-php">$array = [
   'k1' =&gt; 'v1',
   'k2' =&gt; [
       'k21' =&gt; 'v21',
       'k22' =&gt; [
           'k221' =&gt; 'v221',
           'k222' =&gt; 'v222',
           'k223' =&gt; [1, 2, 3],
       ],
   ],
];
// 区切り文字指定なし
that(array_flatten($array))-&gt;isSame([
   0 =&gt; 'v1',
   1 =&gt; 'v21',
   2 =&gt; 'v221',
   3 =&gt; 'v222',
   4 =&gt; 1,
   5 =&gt; 2,
   6 =&gt; 3,
]);
// 区切り文字指定
that(array_flatten($array, '.'))-&gt;isSame([
   'k1'            =&gt; 'v1',
   'k2.k21'        =&gt; 'v21',
   'k2.k22.k221'   =&gt; 'v221',
   'k2.k22.k222'   =&gt; 'v222',
   'k2.k22.k223.0' =&gt; 1,
   'k2.k22.k223.1' =&gt; 2,
   'k2.k22.k223.2' =&gt; 3,
]);
</code></pre>
</div>
    	<h4 class="fqsen-title">method		<small></small>
		<a href="ryunosuke-Functions-Package-Arrays$typespace.html#ryunosuke\Functions\Package\Arrays::array_nest()">
                                    ryunosuke\Functions\Package\Arrays::array_nest		</a>	<small>($array, $delimiter = &quot;.&quot;) : array</small>
		</h4>
	<div class="description"><p>シンプルな [キー =&gt; 値] な配列から階層配列を生成する</p>
<p>定義的に array_flatten の逆関数のような扱いになる。<br />
$delimiter で階層を表現する。</p>
<p>同名とみなされるキーは上書きされるか例外が飛ぶ。具体的には Example を参照。</p>
<p>Example:</p>
<pre><code class="language-php">// 単純な階層展開
$array = [
   'k1'            =&gt; 'v1',
   'k2.k21'        =&gt; 'v21',
   'k2.k22.k221'   =&gt; 'v221',
   'k2.k22.k222'   =&gt; 'v222',
   'k2.k22.k223.0' =&gt; 1,
   'k2.k22.k223.1' =&gt; 2,
   'k2.k22.k223.2' =&gt; 3,
];
that(array_nest($array))-&gt;isSame([
   'k1' =&gt; 'v1',
   'k2' =&gt; [
       'k21' =&gt; 'v21',
       'k22' =&gt; [
           'k221' =&gt; 'v221',
           'k222' =&gt; 'v222',
           'k223' =&gt; [1, 2, 3],
       ],
   ],
]);
// 同名になるようなキーは上書きされる
$array = [
   'k1.k2' =&gt; 'v1', // この時点で 'k1' は配列になるが・・・
   'k1'    =&gt; 'v2', // この時点で 'k1' は文字列として上書きされる
];
that(array_nest($array))-&gt;isSame([
   'k1' =&gt; 'v2',
]);
// 上書きすら出来ない場合は例外が飛ぶ
$array = [
   'k1'    =&gt; 'v1', // この時点で 'k1' は文字列になるが・・・
   'k1.k2' =&gt; 'v2', // この時点で 'k1' にインデックスアクセスすることになるので例外が飛ぶ
];
try {
    array_nest($array);
}
catch (\Exception $e) {
    that($e)-&gt;isInstanceOf(\InvalidArgumentException::class);
}
</code></pre>
</div>
    	<h4 class="fqsen-title">method		<small></small>
		<a href="ryunosuke-Functions-Package-Arrays$typespace.html#ryunosuke\Functions\Package\Arrays::array_difference()">
                                    ryunosuke\Functions\Package\Arrays::array_difference		</a>	<small>($array1, $array2, $delimiter = &quot;.&quot;) : array</small>
		</h4>
	<div class="description"><p>配列の差分を取り配列で返す</p>
<p>返り値の配列は構造化されたデータではない。<br />
主に文字列化して出力することを想定している。</p>
<p>ユースケースとしては「スキーマデータ」「各環境の設定ファイル」などの差分。</p>
<ul>
<li>'+' はキーが追加されたことを表す</li>
<li>'-' はキーが削除されたことを表す</li>
<li>両方が含まれている場合、値の変更を表す</li>
</ul>
<p>数値キーはキーの比較は行われない。値の差分のみ返す。</p>
<p>Example:</p>
<pre><code class="language-php">// common は 中身に差分がある。 1 に key1 はあるが、 2 にはない。2 に key2 はあるが、 1 にはない。
that(array_difference([
    'common' =&gt; [
        'sub' =&gt; [
            'x' =&gt; 'val',
        ]
    ],
    'key1'   =&gt; 'hoge',
    'array'  =&gt; ['a', 'b', 'c'],
], [
    'common' =&gt; [
        'sub' =&gt; [
            'x' =&gt; 'VAL',
        ]
    ],
    'key2'   =&gt; 'fuga',
    'array'  =&gt; ['c', 'd', 'e'],
]))-&gt;isSame([
    'common.sub.x' =&gt; ['-' =&gt; 'val', '+' =&gt; 'VAL'],
    'key1'         =&gt; ['-' =&gt; 'hoge'],
    'array'        =&gt; ['-' =&gt; ['a', 'b'], '+' =&gt; ['d', 'e']],
    'key2'         =&gt; ['+' =&gt; 'fuga'],
]);
</code></pre>
</div>
    	<h4 class="fqsen-title">method		<small></small>
		<a href="ryunosuke-Functions-Package-Arrays$typespace.html#ryunosuke\Functions\Package\Arrays::array_schema()">
                                    ryunosuke\Functions\Package\Arrays::array_schema		</a>	<small>($schema, ...$arrays) : array</small>
		</h4>
	<div class="description"><p>配列のスキーマを定義して配列を正規化する</p>
<ul>
<li>type: 値の型を指定する<ul>
<li>is_XXX の XXX 部分: 左記で検証</li>
<li>number: is_int or is_float で検証</li>
<li>class 名: instanceof で検証</li>
<li>list: 値がマージされて通常配列になる<ul>
<li>list@string のようにすると配列の中身の型を指定できる</li>
</ul>
</li>
<li>hash: 連想配列になる</li>
<li>string|int: string or int</li>
<li></li>
</ul>
</li>
<li>closure: 指定クロージャで検証・フィルタ<ul>
<li>all: 値を引数に取り、返り値が新しい値となる</li>
</ul>
</li>
<li>unique: 重複を除去する<ul>
<li>list: 重複除去（パラメータがソートアルゴリズムになる）</li>
</ul>
</li>
<li>enum: 値が指定値のいずれかであるか検証する<ul>
<li>all: in_array で検証する</li>
</ul>
</li>
<li>min: 値が指定値以上であるか検証する<ul>
<li>string: strlen で検証</li>
<li>list: count で検証</li>
<li>all: その値で検証</li>
</ul>
</li>
<li>max: 値が指定値以下であるか検証する<ul>
<li>min の逆</li>
</ul>
</li>
<li>match: 値が正規表現にマッチするか検証する<ul>
<li>all: preg_match で検証する</li>
</ul>
</li>
<li>unmatch: 値が正規表現にマッチしないか検証する<ul>
<li>match の逆</li>
</ul>
</li>
<li>include: 値が指定値を含むか検証する<ul>
<li>string: strpos で検証</li>
<li>list: in_array で検証</li>
</ul>
</li>
<li>exclude: 値が指定値を含まないか検証する<ul>
<li>include の逆</li>
</ul>
</li>
</ul>
<p>検証・フィルタは原則として型を見ない（指定されていればすべて実行される）。<br />
のでおかしな型におかしな検証・フィルタを与えると型エラーが出ることがある。</p>
<p>検証は途中経過を問わない。<br />
後ろの配列で上書きされた値や unique で減った配列などは以下に違反していても valid と判断される。</p>
<p>素直に json schema を使えという内なる声が聞こえなくもない。</p>
</div>
            	<h4 class="fqsen-title">class		<small></small>
		<a href="ryunosuke-Functions-Package-Classobj$typespace.html#ryunosuke\Functions\Package\Classobj">
                                    ryunosuke\Functions\Package::Classobj		</a>	</h4>
	<div class="description"><p>クラス・オブジェクト関連のユーティリティ</p>
</div>
        	<h4 class="fqsen-title">classconstant		<small>integer</small>
		<a href="ryunosuke-Functions-Package-Classobj$typespace.html#ryunosuke\Functions\Package\Classobj::IS_OWNSELF">
                                    ryunosuke\Functions\Package\Classobj::IS_OWNSELF		</a>	</h4>
	<div class="description"><p>自分自身を表す定数</p>
</div>
    	<h4 class="fqsen-title">classconstant		<small>integer</small>
		<a href="ryunosuke-Functions-Package-Classobj$typespace.html#ryunosuke\Functions\Package\Classobj::IS_PUBLIC">
                                    ryunosuke\Functions\Package\Classobj::IS_PUBLIC		</a>	</h4>
	<div class="description"><p>public を表す定数</p>
</div>
    	<h4 class="fqsen-title">classconstant		<small>integer</small>
		<a href="ryunosuke-Functions-Package-Classobj$typespace.html#ryunosuke\Functions\Package\Classobj::IS_PROTECTED">
                                    ryunosuke\Functions\Package\Classobj::IS_PROTECTED		</a>	</h4>
	<div class="description"><p>protected を表す定数</p>
</div>
    	<h4 class="fqsen-title">classconstant		<small>integer</small>
		<a href="ryunosuke-Functions-Package-Classobj$typespace.html#ryunosuke\Functions\Package\Classobj::IS_PRIVATE">
                                    ryunosuke\Functions\Package\Classobj::IS_PRIVATE		</a>	</h4>
	<div class="description"><p>private を表す定数</p>
</div>
            	<h4 class="fqsen-title">method		<small></small>
		<a href="ryunosuke-Functions-Package-Classobj$typespace.html#ryunosuke\Functions\Package\Classobj::stdclass()">
                                    ryunosuke\Functions\Package\Classobj::stdclass		</a>	<small>($fields = []) : <a href="http://php.net/manual/ja/class.stdclass.php" class="fqsen" target="_blank">\stdClass</a></small>
		</h4>
	<div class="description"><p>初期フィールド値を与えて stdClass を生成する</p>
<p>手元にある配列でサクッと stdClass を作りたいことがまれによくあるはず。</p>
<p>object キャストでもいいんだが、 Iterator/Traversable とかも stdClass 化したいかもしれない。<br />
それにキャストだとコールバックで呼べなかったり、数値キーが死んだりして微妙に使いづらいところがある。</p>
<p>Example:</p>
<pre><code class="language-php">// 基本的には object キャストと同じ
$fields = ['a' =&gt; 'A', 'b' =&gt; 'B'];
that(stdclass($fields))-&gt;is((object) $fields);
// ただしこういうことはキャストでは出来ない
that(array_map('stdclass', [$fields]))-&gt;is([(object) $fields]); // コールバックとして利用する
that(property_exists(stdclass(['a', 'b']), '0'))-&gt;isTrue();     // 数値キー付きオブジェクトにする
</code></pre>
</div>
    	<h4 class="fqsen-title">method		<small></small>
		<a href="ryunosuke-Functions-Package-Classobj$typespace.html#ryunosuke\Functions\Package\Classobj::detect_namespace()">
                                    ryunosuke\Functions\Package\Classobj::detect_namespace		</a>	<small>($location) : string</small>
		</h4>
	<div class="description"><p>ディレクトリ構造から名前空間を推測して返す</p>
<p>指定パスに名前空間を持つような php ファイルが有るならその名前空間を返す。<br />
指定パスに名前空間を持つような php ファイルが無いなら親をたどる。<br />
親に名前空間を持つような php ファイルが有るならその名前空間＋ローカルパスを返す。</p>
<p>言葉で表すとややこしいが、「そのパスに配置しても違和感の無い名前空間」を返してくれるはず。</p>
<p>Example:</p>
<pre><code class="language-php">// Example 用としてこのクラスのディレクトリを使用してみる
$dirname = dirname(class_loader()-&gt;findFile(\ryunosuke\Functions\Package\Classobj::class));
// "$dirname/Hoge" の名前空間を推測して返す
that(detect_namespace("$dirname/Hoge"))-&gt;isSame("ryunosuke\\Functions\\Package\\Hoge");
</code></pre>
</div>
    	<h4 class="fqsen-title">method		<small></small>
		<a href="ryunosuke-Functions-Package-Classobj$typespace.html#ryunosuke\Functions\Package\Classobj::class_uses_all()">
                                    ryunosuke\Functions\Package\Classobj::class_uses_all		</a>	<small>($class, $autoload = true) : array</small>
		</h4>
	<div class="description"><p>クラスが use しているトレイトを再帰的に取得する</p>
<p>トレイトが use しているトレイトが use しているトレイトが use している・・・のような場合もすべて返す。</p>
<p>Example:</p>
<pre><code class="language-php">trait T1{}
trait T2{use T1;}
trait T3{use T2;}
that(class_uses_all(new class{use T3;}))-&gt;isSame([
    'Example\\T3', // クラスが直接 use している
    'Example\\T2', // T3 が use している
    'Example\\T1', // T2 が use している
]);
</code></pre>
</div>
    	<h4 class="fqsen-title">method		<small></small>
		<a href="ryunosuke-Functions-Package-Classobj$typespace.html#ryunosuke\Functions\Package\Classobj::class_loader()">
                                    ryunosuke\Functions\Package\Classobj::class_loader		</a>	<small>($startdir = null) : <a href="Composer-Autoload-ClassLoader$typespace.html#Composer\Autoload\ClassLoader" class="fqsen "><small>Composer\Autoload\</small><wbr>ClassLoader</a></small>
		</h4>
	<div class="description"><p>composer のクラスローダを返す</p>
<p>かなり局所的な実装で vendor ディレクトリを変更していたりするとそれだけで例外になる。</p>
<p>Example:</p>
<pre><code class="language-php">that(class_loader())-&gt;isInstanceOf(\Composer\Autoload\ClassLoader::class);
</code></pre>
</div>
    	<h4 class="fqsen-title">method		<small></small>
		<a href="ryunosuke-Functions-Package-Classobj$typespace.html#ryunosuke\Functions\Package\Classobj::class_namespace()">
                                    ryunosuke\Functions\Package\Classobj::class_namespace		</a>	<small>($class) : string</small>
		</h4>
	<div class="description"><p>クラスの名前空間部分を取得する</p>
<p>Example:</p>
<pre><code class="language-php">that(class_namespace('vendor\\namespace\\ClassName'))-&gt;isSame('vendor\\namespace');
</code></pre>
</div>
    	<h4 class="fqsen-title">method		<small></small>
		<a href="ryunosuke-Functions-Package-Classobj$typespace.html#ryunosuke\Functions\Package\Classobj::class_shorten()">
                                    ryunosuke\Functions\Package\Classobj::class_shorten		</a>	<small>($class) : string</small>
		</h4>
	<div class="description"><p>クラスの名前空間部分を除いた短い名前を取得する</p>
<p>Example:</p>
<pre><code class="language-php">that(class_shorten('vendor\\namespace\\ClassName'))-&gt;isSame('ClassName');
</code></pre>
</div>
    	<h4 class="fqsen-title">method		<small></small>
		<a href="ryunosuke-Functions-Package-Classobj$typespace.html#ryunosuke\Functions\Package\Classobj::class_replace()">
                                    ryunosuke\Functions\Package\Classobj::class_replace		</a>	<small>($class, $register) : void</small>
		</h4>
	<div class="description"><p>既存（未読み込みに限る）クラスを強制的に置換する</p>
<p>例えば継承ツリーが下記の場合を考える。</p>
<p>classA &lt;- classB &lt;- classC</p>
<p>この場合、「classC は classB に」「classB は classA に」それぞれ依存している、と考えることができる。<br />
これは静的に決定的であり、この依存を壊したり注入したりする手段は存在しない。<br />
例えば classA の実装を差し替えたいときに、いかに classA を継承した classAA を定義したとしても classB の親は classA で決して変わらない。</p>
<p>この関数を使うと本当に classA そのものを弄るので、継承ツリーを下記のように変えることができる。</p>
<p>classA &lt;- classAA &lt;- classB &lt;- classC</p>
<p>つまり、classA を継承した classAA を定義してそれを classA とみなすことが可能になる。<br />
ただし、内部的には class_alias を使用して実現しているので厳密には異なるクラスとなる。</p>
<p>実際のところかなり強力な機能だが、同時にかなり黒魔術的なので乱用は控えたほうがいい。</p>
<p>Example:</p>
<pre><code class="language-php">// Y1 extends X1 だとしてクラス定義でオーバーライドする
class_replace('\\ryunosuke\\Test\\Package\\Classobj\\X1', function() {
    // アンスコがついたクラスが定義されるのでそれを継承して定義する
    class X1d extends \ryunosuke\Test\Package\Classobj\X1_
    {
        function method(){return 'this is X1d';}
        function newmethod(){return 'this is newmethod';}
    }
    // このように匿名クラスを返しても良い。ただし、混在せずにどちらか一方にすること
    return new class() extends \ryunosuke\Test\Package\Classobj\X1_
    {
        function method(){return 'this is X1d';}
        function newmethod(){return 'this is newmethod';}
    };
});
// X1 を継承している Y1 にまで影響が出ている（X1 を完全に置換できたということ）
that((new \ryunosuke\Test\Package\Classobj\Y1())-&gt;method())-&gt;isSame('this is X1d');
that((new \ryunosuke\Test\Package\Classobj\Y1())-&gt;newmethod())-&gt;isSame('this is newmethod');

// Y2 extends X2 だとしてクロージャ配列でオーバーライドする
class_replace('\\ryunosuke\\Test\\Package\\Classobj\\X2', function() {
    return [
        'method'    =&gt; function(){return 'this is X2d';},
        'newmethod' =&gt; function(){return 'this is newmethod';},
    ];
});
// X2 を継承している Y2 にまで影響が出ている（X2 を完全に置換できたということ）
that((new \ryunosuke\Test\Package\Classobj\Y2())-&gt;method())-&gt;isSame('this is X2d');
that((new \ryunosuke\Test\Package\Classobj\Y2())-&gt;newmethod())-&gt;isSame('this is newmethod');

// メソッド定義だけであればクロージャではなく配列指定でも可能。さらに trait 配列を渡すとそれらを use できる
class_replace('\\ryunosuke\\Test\\Package\\Classobj\\X3', [
    [\ryunosuke\Test\Package\Classobj\XTrait::class],
    'method' =&gt; function(){return 'this is X3d';},
]);
// X3 を継承している Y3 にまで影響が出ている（X3 を完全に置換できたということ）
that((new \ryunosuke\Test\Package\Classobj\Y3())-&gt;method())-&gt;isSame('this is X3d');
// トレイトのメソッドも生えている
that((new \ryunosuke\Test\Package\Classobj\Y3())-&gt;traitMethod())-&gt;isSame('this is XTrait::traitMethod');
</code></pre>
</div>
    	<h4 class="fqsen-title">method		<small></small>
		<a href="ryunosuke-Functions-Package-Classobj$typespace.html#ryunosuke\Functions\Package\Classobj::class_extends()">
                                    ryunosuke\Functions\Package\Classobj::class_extends		</a>	<small>($object, $methods, $fields = []) : object</small>
		</h4>
	<div class="description"><p>インスタンスを動的に拡張する</p>
<p>インスタンスに特異メソッド・特異フィールドのようなものを生やす。<br />
ただし、特異フィールドの用途はほとんどない（php はデフォルトで特異フィールドのような動作なので）。<br />
そのクラスの <code>__set</code>/<code>__get</code> が禁止されている場合に使えるかもしれない程度。</p>
<p>クロージャ配列を渡すと特異メソッドになる。<br />
そのクロージャの $this は元オブジェクトで bind される。<br />
ただし、static closure を渡した場合はそれは static メソッドとして扱われる。</p>
<p>内部的にはいわゆる Decorator パターンを動的に実行しているだけであり、実行速度は劣悪。<br />
当然ながら final クラス/メソッドの拡張もできない。</p>
<p>Example:</p>
<pre><code class="language-php">// Expcetion に「コードとメッセージを結合して返す」メソッドを動的に生やす
$object = new \Exception('hoge', 123);
$newobject = class_extends($object, [
    'codemessage' =&gt; function() {
        // bind されるので protected フィールドが使える
        return $this-&gt;code . ':' . $this-&gt;message;
    },
]);
that($newobject-&gt;codemessage())-&gt;isSame('123:hoge');

// オーバーライドもできる（ArrayObject の count を2倍になるように上書き）
$object = new \ArrayObject([1, 2, 3]);
$newobject = class_extends($object, [
    'count' =&gt; function() {
        // parent は元オブジェクトを表す
        return parent::count() * 2;
    },
]);
that($newobject-&gt;count())-&gt;isSame(6);
</code></pre>
</div>
    	<h4 class="fqsen-title">method		<small></small>
		<a href="ryunosuke-Functions-Package-Classobj$typespace.html#ryunosuke\Functions\Package\Classobj::reflect_types()">
                                    ryunosuke\Functions\Package\Classobj::reflect_types		</a>	<small>($reflection_type = null) : <a href="http://php.net/manual/ja/class.traversable.php" class="fqsen" target="_blank">\Traversable</a><span class="type-separator"></span><wbr><a href="http://php.net/manual/ja/class.arrayaccess.php" class="fqsen" target="_blank">\ArrayAccess</a><span class="type-separator"></span><wbr><a href="http://php.net/manual/ja/class.countable.php" class="fqsen" target="_blank">\Countable</a><span class="type-separator"></span><wbr><a href="Stringable$typespace.html#Stringable" class="fqsen ">Stringable</a></small>
		</h4>
	<div class="description"><p>ReflectionType の型配列を返す</p>
<p>ReflectionType のインターフェース・仕様がコロコロ変わってついていけないので関数化した。</p>
<p>ReflectionType に準ずるインスタンスを渡すと取り得る候補を配列ライクなオブジェクトで返す。<br />
引数は配列で複数与えても良い。よしなに扱って複数型として返す。<br />
null を与えた場合はエラーにはならず、スルーされる（getType は null を返し得るので利便性のため）。</p>
<p>単純に ReflectionType の配列ライクなオブジェクトを返すが、そのオブジェクトは <code>__toString</code> が実装されており、文字列化するとパイプ区切りの型文字列を返す。<br />
これは 8.0 における ReflectionUnionType の <code>__toString</code> を模倣したものである。<br />
互換性のある型があった場合、上位の型に内包されて型文字列としては出現しない。</p>
<p>Countable も実装されているが、その結果は「内部 Type の数」ではなく、論理的に「取り得る型の数」を返す。<br />
例えば <code>?int</code> は型としては1つだが、実際は int, null の2つを取り得るため、 count は 2 を返す。<br />
端的に言えば「<code>__toString</code> のパイプ区切りの型の数」を返す。</p>
<p>あとは便利メソッドとして下記が生えている。</p>
<ul>
<li>jsonSerialize: JsonSerializable 実装</li>
<li>getTypes: 取り得る型をすべて返す（ReflectionUnionType 互換）</li>
<li>allows: その値を取りうるか判定して返す</li>
</ul>
<p>ReflectionUnionType とは完全互換ではないので、php8.0が完全に使える環境であれば素直に ReflectionUnionType を使ったほうが良い。<br />
（「常に（型分岐せずに）複数形で扱える」程度のメリットしかない。allows は惜しいが）。</p>
<p>ちなみに型の変遷は下記の通り。</p>
<ul>
<li>php7.1: ReflectionType::__toString が非推奨になった</li>
<li>php7.1: ReflectionNamedType が追加され、各種 getType でそれを返すようになった</li>
<li>php8.0: ReflectionType::__toString が非推奨ではなくなった</li>
<li>php8.0: ReflectionUnionType が追加され、複合の場合は getType でそれを返すようになった</li>
</ul>
<p>Example:</p>
<pre><code class="language-php">$object = new class {
    function method(object $o):?string {}
};
$method = new \ReflectionMethod($object, 'method');
$types = reflect_types($method-&gt;getParameters()[0]-&gt;getType());
// 文字列化すると型宣言文字列を返すし、配列アクセスや count, iterable でそれぞれの型が得られる
that((string) $types)-&gt;is('object');
that($types[0])-&gt;isInstanceOf(\ReflectionType::class);
that(iterator_to_array($types))-&gt;eachIsInstanceOf(\ReflectionType::class);
that(count($types))-&gt;is(1);
// 返り値でも同じ（null 許容なので null が付くし count も 2 になる）
$types = reflect_types($method-&gt;getReturnType());
that((string) $types)-&gt;is('string|null');
that(count($types))-&gt;is(2);
</code></pre>
</div>
    	<h4 class="fqsen-title">method		<small></small>
		<a href="ryunosuke-Functions-Package-Classobj$typespace.html#ryunosuke\Functions\Package\Classobj::const_exists()">
                                    ryunosuke\Functions\Package\Classobj::const_exists		</a>	<small>($classname, $constname = null) : bool</small>
		</h4>
	<div class="description"><p>クラス定数が存在するか調べる</p>
<p>グローバル定数も調べられる。ので実質的には defined とほぼ同じで違いは下記。</p>
<ul>
<li>defined は単一引数しか与えられないが、この関数は2つの引数も受け入れる</li>
<li>defined は private const で即死するが、この関数はきちんと調べることができる</li>
<li>ClassName::class は常に true を返す</li>
</ul>
<p>あくまで存在を調べるだけで実際にアクセスできるかは分からないので注意（<code>property_exists</code> と同じ）。</p>
<p>Example:</p>
<pre><code class="language-php">// クラス定数が調べられる（1引数、2引数どちらでも良い）
that(const_exists('ArrayObject::STD_PROP_LIST'))-&gt;isTrue();
that(const_exists('ArrayObject', 'STD_PROP_LIST'))-&gt;isTrue();
that(const_exists('ArrayObject::UNDEFINED'))-&gt;isFalse();
that(const_exists('ArrayObject', 'UNDEFINED'))-&gt;isFalse();
// グローバル（名前空間）もいける
that(const_exists('PHP_VERSION'))-&gt;isTrue();
that(const_exists('UNDEFINED'))-&gt;isFalse();
</code></pre>
</div>
    	<h4 class="fqsen-title">method		<small></small>
		<a href="ryunosuke-Functions-Package-Classobj$typespace.html#ryunosuke\Functions\Package\Classobj::object_dive()">
                                    ryunosuke\Functions\Package\Classobj::object_dive		</a>	<small>($object, $path, $default = null, $delimiter = &quot;.&quot;) : mixed</small>
		</h4>
	<div class="description"><p>パス形式でプロパティ値を取得</p>
<p>存在しない場合は $default を返す。</p>
<p>Example:</p>
<pre><code class="language-php">$class = stdclass([
    'a' =&gt; stdclass([
        'b' =&gt; stdclass([
            'c' =&gt; 'vvv'
        ])
    ])
]);
that(object_dive($class, 'a.b.c'))-&gt;isSame('vvv');
that(object_dive($class, 'a.b.x', 9))-&gt;isSame(9);
// 配列を与えても良い。その場合 $delimiter 引数は意味をなさない
that(object_dive($class, ['a', 'b', 'c']))-&gt;isSame('vvv');
</code></pre>
</div>
    	<h4 class="fqsen-title">method		<small></small>
		<a href="ryunosuke-Functions-Package-Classobj$typespace.html#ryunosuke\Functions\Package\Classobj::get_class_constants()">
                                    ryunosuke\Functions\Package\Classobj::get_class_constants		</a>	<small>($class, $filter = null) : array</small>
		</h4>
	<div class="description"><p>クラス定数を配列で返す</p>
<p><code>(new \ReflectionClass($class))-&gt;getConstants()</code> とほぼ同じだが、可視性でフィルタができる。<br />
さらに「自分自身の定義か？」でもフィルタできる。</p>
<p>Example:</p>
<pre><code class="language-php">$class = new class extends \ArrayObject
{
    private   const C_PRIVATE   = 'private';
    protected const C_PROTECTED = 'protected';
    public    const C_PUBLIC    = 'public';
};
// 普通に全定数を返す
that(get_class_constants($class))-&gt;isSame([
    'C_PRIVATE'      =&gt; 'private',
    'C_PROTECTED'    =&gt; 'protected',
    'C_PUBLIC'       =&gt; 'public',
    'STD_PROP_LIST'  =&gt; \ArrayObject::STD_PROP_LIST,
    'ARRAY_AS_PROPS' =&gt; \ArrayObject::ARRAY_AS_PROPS,
]);
// public のみを返す
that(get_class_constants($class, IS_PUBLIC))-&gt;isSame([
    'C_PUBLIC'       =&gt; 'public',
    'STD_PROP_LIST'  =&gt; \ArrayObject::STD_PROP_LIST,
    'ARRAY_AS_PROPS' =&gt; \ArrayObject::ARRAY_AS_PROPS,
]);
// 自身定義でかつ public のみを返す
that(get_class_constants($class, IS_OWNSELF | IS_PUBLIC))-&gt;isSame([
    'C_PUBLIC'       =&gt; 'public',
]);
</code></pre>
</div>
    	<h4 class="fqsen-title">method		<small></small>
		<a href="ryunosuke-Functions-Package-Classobj$typespace.html#ryunosuke\Functions\Package\Classobj::get_object_properties()">
                                    ryunosuke\Functions\Package\Classobj::get_object_properties		</a>	<small>($object) : array</small>
		</h4>
	<div class="description"><p>オブジェクトのプロパティを可視・不可視を問わず取得する</p>
<p>get_object_vars + no public プロパティを返すイメージ。</p>
<p>Example:</p>
<pre><code class="language-php">$object = new \Exception('something', 42);
$object-&gt;oreore = 'oreore';

// get_object_vars はそのスコープから見えないプロパティを取得できない
// var_dump(get_object_vars($object));

// array キャストは全て得られるが null 文字を含むので扱いにくい
// var_dump((array) $object);

// この関数を使えば不可視プロパティも取得できる
that(get_object_properties($object))-&gt;arraySubset([
    'message' =&gt; 'something',
    'code'    =&gt; 42,
    'oreore'  =&gt; 'oreore',
]);
</code></pre>
</div>
            	<h4 class="fqsen-title">class		<small></small>
		<a href="ryunosuke-Functions-Package-Date$typespace.html#ryunosuke\Functions\Package\Date">
                                    ryunosuke\Functions\Package::Date		</a>	</h4>
	<div class="description"><p>日付・時刻関連のユーティリティ</p>
</div>
        	<h4 class="fqsen-title">classconstant		<small>array</small>
		<a href="ryunosuke-Functions-Package-Date$typespace.html#ryunosuke\Functions\Package\Date::JP_ERA">
                                    ryunosuke\Functions\Package\Date::JP_ERA		</a>	</h4>
	<div class="description"><p>和暦</p>
</div>
            	<h4 class="fqsen-title">method		<small></small>
		<a href="ryunosuke-Functions-Package-Date$typespace.html#ryunosuke\Functions\Package\Date::date_timestamp()">
                                    ryunosuke\Functions\Package\Date::date_timestamp		</a>	<small>($datetimedata, $baseTimestamp = null) : int<span class="type-separator"></span><wbr>float<span class="type-separator"></span><wbr>null</small>
		</h4>
	<div class="description"><p>日時文字列をよしなにタイムスタンプに変換する</p>
<p>マイクロ秒にも対応している。つまり返り値は int か float になる。<br />
また、相対指定の +1 month の月末問題は起きないようにしてある。</p>
<p>かなり適当に和暦にも対応している。</p>
<p>Example:</p>
<pre><code class="language-php">// 普通の日時文字列
that(date_timestamp('2014/12/24 12:34:56'))-&gt;isSame(strtotime('2014/12/24 12:34:56'));
// 和暦
that(date_timestamp('昭和31年12月24日 12時34分56秒'))-&gt;isSame(strtotime('1956/12/24 12:34:56'));
// 相対指定
that(date_timestamp('2012/01/31 +1 month'))-&gt;isSame(strtotime('2012/02/29'));
that(date_timestamp('2012/03/31 -1 month'))-&gt;isSame(strtotime('2012/02/29'));
// マイクロ秒
that(date_timestamp('2014/12/24 12:34:56.789'))-&gt;isSame(1419392096.789);
</code></pre>
</div>
    	<h4 class="fqsen-title">method		<small></small>
		<a href="ryunosuke-Functions-Package-Date$typespace.html#ryunosuke\Functions\Package\Date::date_convert()">
                                    ryunosuke\Functions\Package\Date::date_convert		</a>	<small>($format, $datetimedata = null) : string</small>
		</h4>
	<div class="description"><p>日時文字列をよしなに別のフォーマットに変換する</p>
<p>マイクロ秒にも対応している。<br />
かなり適当に和暦にも対応している。</p>
<p>Example:</p>
<pre><code class="language-php">// 和暦を Y/m/d H:i:s に変換
that(date_convert('Y/m/d H:i:s', '昭和31年12月24日 12時34分56秒'))-&gt;isSame('1956/12/24 12:34:56');
// 単純に「マイクロ秒が使える date」としても使える
$now = 1234567890.123; // テストがしづらいので固定時刻にする
that(date_convert('Y/m/d H:i:s.u', $now))-&gt;isSame('2009/02/14 08:31:30.123000');
</code></pre>
</div>
    	<h4 class="fqsen-title">method		<small></small>
		<a href="ryunosuke-Functions-Package-Date$typespace.html#ryunosuke\Functions\Package\Date::date_fromto()">
                                    ryunosuke\Functions\Package\Date::date_fromto		</a>	<small>($format, $datetimestring) : array<span class="type-separator"></span><wbr>null</small>
		</h4>
	<div class="description"><p>日時っぽい文字列とフォーマットを与えると取りうる範囲を返す</p>
<p>与えられた日時の最大の切り捨て日時と最小の切り上げ日時の配列を返す。<br />
日付文字列はある程度よしなに補完される（例えば "2014/12" は"2014年12月01日" と解釈されるし "12/24" は "今年12月24日" と解釈される）。</p>
<p>Example:</p>
<pre><code class="language-php">that(date_fromto('Y/m/d H:i:s', '2010/11'))-&gt;isSame(["2010/11/01 00:00:00", "2010/12/01 00:00:00"]);
that(date_fromto('Y/m/d H:i:s', '2010/11/24'))-&gt;isSame(["2010/11/24 00:00:00", "2010/11/25 00:00:00"]);
that(date_fromto('Y/m/d H:i:s', '2010/11/24 13'))-&gt;isSame(["2010/11/24 13:00:00", "2010/11/24 14:00:00"]);
that(date_fromto('Y/m/d H:i:s', '2010/11/24 13:24'))-&gt;isSame(["2010/11/24 13:24:00", "2010/11/24 13:25:00"]);
</code></pre>
</div>
    	<h4 class="fqsen-title">method		<small></small>
		<a href="ryunosuke-Functions-Package-Date$typespace.html#ryunosuke\Functions\Package\Date::date_interval()">
                                    ryunosuke\Functions\Package\Date::date_interval		</a>	<small>($sec, $format = null, $limit_type = &quot;y&quot;) : string<span class="type-separator"></span><wbr><a href="http://php.net/manual/ja/class.dateinterval.php" class="fqsen" target="_blank">\DateInterval</a></small>
		</h4>
	<div class="description"><p>秒を世紀・年・月・日・時間・分・秒・ミリ秒の各要素に分解する</p>
<p>例えば <code>60 * 60 * 24 * 900 + 12345.678</code> （約900日12345秒）は・・・</p>
<ul>
<li>2 年（約900日なので）</li>
<li>5 ヶ月（約(900 - 365 * 2 = 170)日なので）</li>
<li>18 日（約(170 - 30.416 * 5 = 18)日なので）</li>
<li>3 時間（約12345秒なので）</li>
<li>25 分（約(12345 - 3600 * 3 = 1545)秒なので）</li>
<li>45 秒（約(1545 - 60 * 25 = 45)秒なので）</li>
<li>678 ミリ秒（.678 部分そのまま）</li>
</ul>
<p>となる（年はうるう年未考慮で365日、月は30.41666666日で換算）。</p>
<p>$format を与えると DateInterval::format して文字列で返す。与えないと DateInterval をそのまま返す。<br />
$format はクロージャを与えることができる。クロージャを与えた場合、各要素を引数としてコールバックされる。<br />
$format は配列で与えることができる。配列で与えた場合、 0 になる要素は省かれる。<br />
セパレータを与えたり、pre/suffix を与えたりできるが、難解なので省略する。</p>
<p>$limit_type で換算のリミットを指定できる。例えば 'y' を指定すると「2年5ヶ月」となるが、 'm' を指定すると「29ヶ月」となる。<br />
数値を与えるとその範囲でオートスケールする。例えば 3 を指定すると値が大きいとき <code>ymd</code> の表示になり、年が 0 になると <code>mdh</code> の表示に切り替わるようになる。</p>
<p>Example:</p>
<pre><code class="language-php">// 書式文字列指定（%vはミリ秒）
that(date_interval(60 * 60 * 24 * 900 + 12345.678, '%Y/%M/%D %H:%I:%S.%v'))-&gt;isSame('02/05/18 03:25:45.678');

// 書式にクロージャを与えるとコールバックされる（引数はスケールの小さい方から）
that(date_interval(60 * 60 * 24 * 900 + 12345.678, function(){return implode(',', func_get_args());}))-&gt;isSame('678,45,25,3,18,5,2,0');

// リミットを指定（month までしか計算しないので year は 0 になり month は 29になる）
that(date_interval(60 * 60 * 24 * 900 + 12345.678, '%Y/%M/%D %H:%I:%S.%v', 'm'))-&gt;isSame('00/29/18 03:25:45.678');

// 書式に配列を与えてリミットに数値を与えるとその範囲でオートスケールする
$format = [
    'y' =&gt; '%y年',
    'm' =&gt; '%mヶ月',
    'd' =&gt; '%d日',
    ' ',
    'h' =&gt; '%h時間',
    'i' =&gt; '%i分',
    's' =&gt; '%s秒',
];
// 数が大きいので年・月・日の3要素のみ
that(date_interval(60 * 60 * 24 * 900 + 12345, $format, 3))-&gt;isSame('2年5ヶ月18日');
// 数がそこそこだと日・時間・分の3要素に切り替わる
that(date_interval(60 * 60 * 24 * 20 + 12345, $format, 3))-&gt;isSame('20日 3時間25分');
// どんなに数が小さくても3要素以下にはならない
that(date_interval(1234, $format, 3))-&gt;isSame('0時間20分34秒');

// 書式指定なし（DateInterval を返す）
that(date_interval(123.456))-&gt;isInstanceOf(\DateInterval::class);
</code></pre>
</div>
            	<h4 class="fqsen-title">class		<small></small>
		<a href="ryunosuke-Functions-Package-FileSystem$typespace.html#ryunosuke\Functions\Package\FileSystem">
                                    ryunosuke\Functions\Package::FileSystem		</a>	</h4>
	<div class="description"><p>ファイルシステム関連のユーティリティ</p>
</div>
                	<h4 class="fqsen-title">method		<small></small>
		<a href="ryunosuke-Functions-Package-FileSystem$typespace.html#ryunosuke\Functions\Package\FileSystem::file_matcher()">
                                    ryunosuke\Functions\Package\FileSystem::file_matcher		</a>	<small>($filter_condition) : <a href="http://php.net/manual/ja/class.closure.php" class="fqsen" target="_blank">\Closure</a></small>
		</h4>
	<div class="description"><p>各種属性を指定してファイルのマッチングを行うクロージャを返す</p>
<p>※ 内部向け</p>
</div>
    	<h4 class="fqsen-title">method		<small></small>
		<a href="ryunosuke-Functions-Package-FileSystem$typespace.html#ryunosuke\Functions\Package\FileSystem::file_list()">
                                    ryunosuke\Functions\Package\FileSystem::file_list		</a>	<small>($dirname, $filter_condition = []) : array<span class="type-separator"></span><wbr>false</small>
		</h4>
	<div class="description"><p>ファイル一覧を配列で返す</p>
<p>Example:</p>
<pre><code class="language-php">// 適当にファイルを用意
$DS = DIRECTORY_SEPARATOR;
$tmp = sys_get_temp_dir() . "{$DS}file_list";
rm_rf($tmp, false);
file_set_contents("$tmp/a.txt", 'a');
file_set_contents("$tmp/dir/b.txt", 'b');
file_set_contents("$tmp/dir/dir/c.txt", 'c');
// ファイル一覧が取得できる
that(file_list($tmp))-&gt;equalsCanonicalizing([
    "$tmp{$DS}a.txt",
    "$tmp{$DS}dir{$DS}b.txt",
    "$tmp{$DS}dir{$DS}dir{$DS}c.txt",
]);
</code></pre>
</div>
    	<h4 class="fqsen-title">method		<small></small>
		<a href="ryunosuke-Functions-Package-FileSystem$typespace.html#ryunosuke\Functions\Package\FileSystem::file_tree()">
                                    ryunosuke\Functions\Package\FileSystem::file_tree		</a>	<small>($dirname, $filter_condition = []) : array<span class="type-separator"></span><wbr>false</small>
		</h4>
	<div class="description"><p>ディレクトリ階層をツリー構造で返す</p>
<p>Example:</p>
<pre><code class="language-php">// 適当にファイルを用意
$DS = DIRECTORY_SEPARATOR;
$tmp = sys_get_temp_dir() . "{$DS}file_tree";
rm_rf($tmp, false);
file_set_contents("$tmp/a.txt", 'a');
file_set_contents("$tmp/dir/b.txt", 'b');
file_set_contents("$tmp/dir/dir/c.txt", 'c');
// ファイルツリーが取得できる
that(file_tree($tmp))-&gt;is([
    'file_tree' =&gt; [
        'a.txt' =&gt; "$tmp{$DS}a.txt",
        'dir'   =&gt; [
            'b.txt' =&gt; "$tmp{$DS}dir{$DS}b.txt",
            'dir'   =&gt; [
                'c.txt' =&gt; "$tmp{$DS}dir{$DS}dir{$DS}c.txt",
            ],
        ],
    ],
]);
</code></pre>
</div>
    	<h4 class="fqsen-title">method		<small></small>
		<a href="ryunosuke-Functions-Package-FileSystem$typespace.html#ryunosuke\Functions\Package\FileSystem::file_suffix()">
                                    ryunosuke\Functions\Package\FileSystem::file_suffix		</a>	<small>($filename, $suffix) : string</small>
		</h4>
	<div class="description"><p>ファイル名にサフィックスを付与する</p>
<p>pathinfoに非準拠。例えば「filename.hoge.fuga」のような形式は「filename」が変換対象になる。</p>
<p>Example:</p>
<pre><code class="language-php">that(file_suffix('filename.ext', '-min'))-&gt;isSame('filename-min.ext');
that(file_suffix('filename.ext1.ext2', '-min'))-&gt;isSame('filename-min.ext1.ext2');
</code></pre>
</div>
    	<h4 class="fqsen-title">method		<small></small>
		<a href="ryunosuke-Functions-Package-FileSystem$typespace.html#ryunosuke\Functions\Package\FileSystem::file_extension()">
                                    ryunosuke\Functions\Package\FileSystem::file_extension		</a>	<small>($filename, $extension = &quot;&quot;) : string</small>
		</h4>
	<div class="description"><p>ファイルの拡張子を変更する。引数を省略すると拡張子を返す</p>
<p>pathinfo に準拠。例えば「filename.hoge.fuga」のような形式は「fuga」が変換対象になる。</p>
<p>Example:</p>
<pre><code class="language-php">that(file_extension('filename.ext'))-&gt;isSame('ext');
that(file_extension('filename.ext', 'txt'))-&gt;isSame('filename.txt');
that(file_extension('filename.ext', ''))-&gt;isSame('filename');
</code></pre>
</div>
    	<h4 class="fqsen-title">method		<small></small>
		<a href="ryunosuke-Functions-Package-FileSystem$typespace.html#ryunosuke\Functions\Package\FileSystem::file_set_contents()">
                                    ryunosuke\Functions\Package\FileSystem::file_set_contents		</a>	<small>($filename, $data, $umask = 2) : int</small>
		</h4>
	<div class="description"><p>ディレクトリも掘る file_put_contents</p>
<p>書き込みは一時ファイルと rename を使用してアトミックに行われる。</p>
<p>Example:</p>
<pre><code class="language-php">file_set_contents(sys_get_temp_dir() . '/not/filename.ext', 'hoge');
that(file_get_contents(sys_get_temp_dir() . '/not/filename.ext'))-&gt;isSame('hoge');
</code></pre>
</div>
    	<h4 class="fqsen-title">method		<small></small>
		<a href="ryunosuke-Functions-Package-FileSystem$typespace.html#ryunosuke\Functions\Package\FileSystem::file_rewrite_contents()">
                                    ryunosuke\Functions\Package\FileSystem::file_rewrite_contents		</a>	<small>($filename, $callback, $operation = 0) : int</small>
		</h4>
	<div class="description"><p>ファイルを読み込んで内容をコールバックに渡して書き込む</p>
<p>Example:</p>
<pre><code class="language-php">// 適当にファイルを用意
$testpath = sys_get_temp_dir() . '/rewrite.txt';
file_put_contents($testpath, 'hoge');
// 前後に 'pre-', '-fix' を付与する
file_rewrite_contents($testpath, function($contents, $fp){ return "pre-$contents-fix"; });
that($testpath)-&gt;fileEquals('pre-hoge-fix');
</code></pre>
</div>
    	<h4 class="fqsen-title">method		<small></small>
		<a href="ryunosuke-Functions-Package-FileSystem$typespace.html#ryunosuke\Functions\Package\FileSystem::file_pos()">
                                    ryunosuke\Functions\Package\FileSystem::file_pos		</a>	<small>($filename, $needle, $start = 0, $end = null, $chunksize = null) : int<span class="type-separator"></span><wbr>false</small>
		</h4>
	<div class="description"><p>範囲指定でファイルを読んで位置を返す</p>
<p>Example:</p>
<pre><code class="language-php">// 適当にファイルを用意
$testpath = sys_get_temp_dir() . '/file_pos.txt';
file_put_contents($testpath, "hoge\nfuga\npiyo\nfuga");
// fuga の位置を返す
that(file_pos($testpath, 'fuga'))-&gt;is(5);
// 2つ目の fuga の位置を返す
that(file_pos($testpath, 'fuga', 6))-&gt;is(15);
// 見つからない場合は false を返す
that(file_pos($testpath, 'hogera'))-&gt;is(false);
</code></pre>
</div>
    	<h4 class="fqsen-title">method		<small></small>
		<a href="ryunosuke-Functions-Package-FileSystem$typespace.html#ryunosuke\Functions\Package\FileSystem::file_mimetype()">
                                    ryunosuke\Functions\Package\FileSystem::file_mimetype		</a>	<small>($filename) : string<span class="type-separator"></span><wbr>null</small>
		</h4>
	<div class="description"><p>ファイルの mimetype を返す</p>
<p>mime_content_type の http 対応版。<br />
変更点は下記。</p>
<ul>
<li>http(s) に対応（HEAD メソッドで取得する）</li>
<li>失敗時に false ではなく null を返す</li>
</ul>
<p>Example:</p>
<pre><code class="language-php">that(file_mimetype(__FILE__))-&gt;is('text/x-php');
that(file_mimetype('http://httpbin.org/get?name=value'))-&gt;is('application/json');
</code></pre>
</div>
    	<h4 class="fqsen-title">method		<small></small>
		<a href="ryunosuke-Functions-Package-FileSystem$typespace.html#ryunosuke\Functions\Package\FileSystem::mkdir_p()">
                                    ryunosuke\Functions\Package\FileSystem::mkdir_p		</a>	<small>($dirname, $umask = 2) : bool</small>
		</h4>
	<div class="description"><p>ディレクトリを再帰的に掘る</p>
<p>既に存在する場合は何もしない（エラーも出さない）。</p>
</div>
    	<h4 class="fqsen-title">method		<small></small>
		<a href="ryunosuke-Functions-Package-FileSystem$typespace.html#ryunosuke\Functions\Package\FileSystem::dirname_r()">
                                    ryunosuke\Functions\Package\FileSystem::dirname_r		</a>	<small>($path, $callback) : mixed</small>
		</h4>
	<div class="description"><p>コールバックが true 相当を返すまで親ディレクトリを辿り続ける</p>
<p>コールバックには親ディレクトリが引数として渡ってくる。</p>
<p>Example:</p>
<pre><code class="language-php">// //tmp/a/b/file.txt を作っておく
$tmp = sys_get_temp_dir();
file_set_contents("$tmp/a/b/file.txt", 'hoge');
// /a/b/c/d/e/f から開始して「どこかの階層の file.txt を探したい」という状況を想定
$callback = function($path){return realpath("$path/file.txt");};
that(dirname_r("$tmp/a/b/c/d/e/f", $callback))-&gt;isSame(realpath("$tmp/a/b/file.txt"));
</code></pre>
</div>
    	<h4 class="fqsen-title">method		<small></small>
		<a href="ryunosuke-Functions-Package-FileSystem$typespace.html#ryunosuke\Functions\Package\FileSystem::dirmtime()">
                                    ryunosuke\Functions\Package\FileSystem::dirmtime		</a>	<small>($dirname, $recursive = true) : int</small>
		</h4>
	<div class="description"><p>ディレクトリの最終更新日時を返す</p>
<p>「ディレクトリの最終更新日時」とは filemtime で得られる結果ではなく、「配下のファイル群で最も新しい日時」を表す。<br />
ディレクトリの mtime も検出に含まれるので、ファイルを削除した場合も検知できる。</p>
<p>ファイル名を与えると例外を投げる。<br />
空ディレクトリの場合は自身の mtime を返す。</p>
<p>Example:</p>
<pre><code class="language-php">$dirname = sys_get_temp_dir() . '/mtime';
rm_rf($dirname);
mkdir($dirname);

// この時点では現在日時（単純に自身の更新日時）
that(dirmtime($dirname))-&gt;isBetween(time() - 2, time());
// ファイルを作って更新するとその時刻
touch("$dirname/tmp", time() + 10);
that(dirmtime($dirname))-&gt;isSame(time() + 10);
</code></pre>
</div>
    	<h4 class="fqsen-title">method		<small></small>
		<a href="ryunosuke-Functions-Package-FileSystem$typespace.html#ryunosuke\Functions\Package\FileSystem::fnmatch_and()">
                                    ryunosuke\Functions\Package\FileSystem::fnmatch_and		</a>	<small>($patterns, $string, $flags = 0) : bool</small>
		</h4>
	<div class="description"><p>fnmatch の AND 版</p>
<p>$patterns のうちどれか一つでもマッチしなかったら false を返す。<br />
$patterns が空だと例外を投げる。</p>
<p>Example:</p>
<pre><code class="language-php">// すべてにマッチするので true
that(fnmatch_and(['*aaa*', '*bbb*'], 'aaaXbbbX'))-&gt;isTrue();
// aaa にはマッチするが bbb にはマッチしないので false
that(fnmatch_and(['*aaa*', '*bbb*'], 'aaaX'))-&gt;isFalse();
</code></pre>
</div>
    	<h4 class="fqsen-title">method		<small></small>
		<a href="ryunosuke-Functions-Package-FileSystem$typespace.html#ryunosuke\Functions\Package\FileSystem::fnmatch_or()">
                                    ryunosuke\Functions\Package\FileSystem::fnmatch_or		</a>	<small>($patterns, $string, $flags = 0) : bool</small>
		</h4>
	<div class="description"><p>fnmatch の OR 版</p>
<p>$patterns のうちどれか一つでもマッチしたら true を返す。<br />
$patterns が空だと例外を投げる。</p>
<p>Example:</p>
<pre><code class="language-php">// aaa にマッチするので true
that(fnmatch_or(['*aaa*', '*bbb*'], 'aaaX'))-&gt;isTrue();
// どれともマッチしないので false
that(fnmatch_or(['*aaa*', '*bbb*'], 'cccX'))-&gt;isFalse();
</code></pre>
</div>
    	<h4 class="fqsen-title">method		<small></small>
		<a href="ryunosuke-Functions-Package-FileSystem$typespace.html#ryunosuke\Functions\Package\FileSystem::path_is_absolute()">
                                    ryunosuke\Functions\Package\FileSystem::path_is_absolute		</a>	<small>($path) : bool</small>
		</h4>
	<div class="description"><p>パスが絶対パスか判定する</p>
<p>Example:</p>
<pre><code class="language-php">that(path_is_absolute('/absolute/path'))-&gt;isTrue();
that(path_is_absolute('relative/path'))-&gt;isFalse();
// Windows 環境では下記も true になる
if (DIRECTORY_SEPARATOR === '\\') {
    that(path_is_absolute('\\absolute\\path'))-&gt;isTrue();
    that(path_is_absolute('C:\\absolute\\path'))-&gt;isTrue();
}
</code></pre>
</div>
    	<h4 class="fqsen-title">method		<small></small>
		<a href="ryunosuke-Functions-Package-FileSystem$typespace.html#ryunosuke\Functions\Package\FileSystem::path_resolve()">
                                    ryunosuke\Functions\Package\FileSystem::path_resolve		</a>	<small>(...$paths) : string</small>
		</h4>
	<div class="description"><p>パスを絶対パスに変換して正規化する</p>
<p>可変引数で与えられた文字列群を結合して絶対パス化して返す。<br />
出来上がったパスが絶対パスでない場合はカレントディレクトリを結合して返す。</p>
<p>Example:</p>
<pre><code class="language-php">$DS = DIRECTORY_SEPARATOR;
that(path_resolve('/absolute/path'))-&gt;isSame("{$DS}absolute{$DS}path");
that(path_resolve('absolute/path'))-&gt;isSame(getcwd() . "{$DS}absolute{$DS}path");
that(path_resolve('/absolute/path/through', '../current/./path'))-&gt;isSame("{$DS}absolute{$DS}path{$DS}current{$DS}path");
</code></pre>
</div>
    	<h4 class="fqsen-title">method		<small></small>
		<a href="ryunosuke-Functions-Package-FileSystem$typespace.html#ryunosuke\Functions\Package\FileSystem::path_relative()">
                                    ryunosuke\Functions\Package\FileSystem::path_relative		</a>	<small>($from, $to) : string</small>
		</h4>
	<div class="description"><p>パスを相対パスに変換して正規化する</p>
<p>$from から $to への相対パスを返す。</p>
<p>Example:</p>
<pre><code class="language-php">$DS = DIRECTORY_SEPARATOR;
that(path_relative('/a/b/c/X', '/a/b/c/d/X'))-&gt;isSame("..{$DS}d{$DS}X");
that(path_relative('/a/b/c/d/X', '/a/b/c/X'))-&gt;isSame("..{$DS}..{$DS}X");
that(path_relative('/a/b/c/X', '/a/b/c/X'))-&gt;isSame("");
</code></pre>
</div>
    	<h4 class="fqsen-title">method		<small></small>
		<a href="ryunosuke-Functions-Package-FileSystem$typespace.html#ryunosuke\Functions\Package\FileSystem::path_normalize()">
                                    ryunosuke\Functions\Package\FileSystem::path_normalize		</a>	<small>($path) : string</small>
		</h4>
	<div class="description"><p>パスを正規化する</p>
<p>具体的には ./ や ../ を取り除いたり連続したディレクトリ区切りをまとめたりする。<br />
realpath ではない。のでシンボリックリンクの解決などはしない。その代わりファイルが存在しなくても使用することができる。</p>
<p>Example:</p>
<pre><code class="language-php">$DS = DIRECTORY_SEPARATOR;
that(path_normalize('/path/to/something'))-&gt;isSame("{$DS}path{$DS}to{$DS}something");
that(path_normalize('/path/through/../something'))-&gt;isSame("{$DS}path{$DS}something");
that(path_normalize('./path/current/./through/../something'))-&gt;isSame("path{$DS}current{$DS}something");
</code></pre>
</div>
    	<h4 class="fqsen-title">method		<small></small>
		<a href="ryunosuke-Functions-Package-FileSystem$typespace.html#ryunosuke\Functions\Package\FileSystem::cp_rf()">
                                    ryunosuke\Functions\Package\FileSystem::cp_rf		</a>	<small>($src, $dst) : bool</small>
		</h4>
	<div class="description"><p>ディレクトリのコピー</p>
<p>$dst に / を付けると「$dst に自身をコピー」する。付けないと「$dst に中身をコピー」するという動作になる。</p>
<p>ディレクトリではなくファイルを与えても動作する（copy とほぼ同じ動作になるが、対象にディレクトリを指定できる点が異なる）。</p>
<p>Example:</p>
<pre><code class="language-php">// /tmp/src/hoge.txt, /tmp/src/dir/fuga.txt を作っておく
$tmp = sys_get_temp_dir();
file_set_contents("$tmp/src/hoge.txt", 'hoge');
file_set_contents("$tmp/src/dir/fuga.txt", 'fuga');

// "/" を付けないと中身コピー
cp_rf("$tmp/src", "$tmp/dst1");
that("$tmp/dst1/hoge.txt")-&gt;fileEquals('hoge');
that("$tmp/dst1/dir/fuga.txt")-&gt;fileEquals('fuga');
// "/" を付けると自身コピー
cp_rf("$tmp/src", "$tmp/dst2/");
that("$tmp/dst2/src/hoge.txt")-&gt;fileEquals('hoge');
that("$tmp/dst2/src/dir/fuga.txt")-&gt;fileEquals('fuga');

// $src はファイルでもいい（$dst に "/" を付けるとそのディレクトリにコピーする）
cp_rf("$tmp/src/hoge.txt", "$tmp/dst3/");
that("$tmp/dst3/hoge.txt")-&gt;fileEquals('hoge');
// $dst に "/" を付けないとそのパスとしてコピー（copy と完全に同じ）
cp_rf("$tmp/src/hoge.txt", "$tmp/dst4");
that("$tmp/dst4")-&gt;fileEquals('hoge');
</code></pre>
</div>
    	<h4 class="fqsen-title">method		<small></small>
		<a href="ryunosuke-Functions-Package-FileSystem$typespace.html#ryunosuke\Functions\Package\FileSystem::rm_rf()">
                                    ryunosuke\Functions\Package\FileSystem::rm_rf		</a>	<small>($dirname, $self = true) : bool</small>
		</h4>
	<div class="description"><p>中身があっても消せる rmdir</p>
<p>Example:</p>
<pre><code class="language-php">mkdir(sys_get_temp_dir() . '/new/make/dir', 0777, true);
rm_rf(sys_get_temp_dir() . '/new');
that(file_exists(sys_get_temp_dir() . '/new'))-&gt;isSame(false);
</code></pre>
</div>
    	<h4 class="fqsen-title">method		<small></small>
		<a href="ryunosuke-Functions-Package-FileSystem$typespace.html#ryunosuke\Functions\Package\FileSystem::tmpname()">
                                    ryunosuke\Functions\Package\FileSystem::tmpname		</a>	<small>($prefix = &quot;rft&quot;, $dir = null) : string</small>
		</h4>
	<div class="description"><p>終了時に削除される一時ファイル名を生成する</p>
<p>tempnam とほぼ同じで違いは下記。</p>
<ul>
<li>引数が逆</li>
<li>終了時に削除される</li>
<li>失敗時に false を返すのではなく例外を投げる</li>
</ul>
</div>
    	<h4 class="fqsen-title">method		<small></small>
		<a href="ryunosuke-Functions-Package-FileSystem$typespace.html#ryunosuke\Functions\Package\FileSystem::memory_path()">
                                    ryunosuke\Functions\Package\FileSystem::memory_path		</a>	<small>($path) : string</small>
		</h4>
	<div class="description"><p>ファイルのように扱えるメモリ上のパスを返す</p>
<p>劣化 vfsStream のようなもの。<br />
stream wrapper を用いて実装しており、そのプロトコルは初回呼び出し時に1度だけ登録される。<br />
プロトコル名は決め打ちだが、 php.ini に "rfunc.memory_stream" というキーで文字列を指定するとそれが使用される。</p>
<p>ファイル操作はある程度できるが、ディレクトリ操作は未対応（そこまでしたいなら vfsStream とか /dev/shm とかを使えば良い）。</p>
<p>Example:</p>
<pre><code class="language-php">// ファイル名のように読み書きができるパスを返す（一時ファイルを使用するよりかなり高速に動作する）
$memory_path = memory_path('filename.txt');
// 呼んだだけでは何もしないので存在しない
that(file_exists($memory_path))-&gt;isSame(false);
// file_put_contents が使える
that(file_put_contents($memory_path, 'Hello, World'))-&gt;isSame(12);
// file_get_contents が使える
that(file_get_contents($memory_path))-&gt;isSame('Hello, World');
// 上記の操作で実体が存在している
that(file_exists($memory_path))-&gt;isSame(true);
// unlink が使える
that(unlink($memory_path))-&gt;isSame(true);
// unlink したので存在しない
that(file_exists($memory_path))-&gt;isSame(false);
</code></pre>
</div>
            	<h4 class="fqsen-title">class		<small></small>
		<a href="ryunosuke-Functions-Package-Funchand$typespace.html#ryunosuke\Functions\Package\Funchand">
                                    ryunosuke\Functions\Package::Funchand		</a>	</h4>
	<div class="description"><p>callable 関連のユーティリティ</p>
</div>
                	<h4 class="fqsen-title">method		<small></small>
		<a href="ryunosuke-Functions-Package-Funchand$typespace.html#ryunosuke\Functions\Package\Funchand::delegate()">
                                    ryunosuke\Functions\Package\Funchand::delegate		</a>	<small>($invoker, $callable, $arity = null) : callable</small>
		</h4>
	<div class="description"><p>指定 callable を指定クロージャで実行するクロージャを返す</p>
<p>ほぼ内部向けで外から呼ぶことはあまり想定していない。</p>
</div>
    	<h4 class="fqsen-title">method		<small></small>
		<a href="ryunosuke-Functions-Package-Funchand$typespace.html#ryunosuke\Functions\Package\Funchand::abind()">
                                    ryunosuke\Functions\Package\Funchand::abind		</a>	<small>($callable, $default_args) : callable</small>
		</h4>
	<div class="description"><p>$callable の引数を指定配列で束縛したクロージャを返す</p>
<p>Example:</p>
<pre><code class="language-php">$bind = abind('sprintf', [1 =&gt; 'a', 3 =&gt; 'c']);
that($bind('%s%s%s', 'b'))-&gt;isSame('abc');
</code></pre>
</div>
    	<h4 class="fqsen-title">method		<small></small>
		<a href="ryunosuke-Functions-Package-Funchand$typespace.html#ryunosuke\Functions\Package\Funchand::nbind()">
                                    ryunosuke\Functions\Package\Funchand::nbind		</a>	<small>($callable, $n, ...$variadic) : callable</small>
		</h4>
	<div class="description"><p>$callable の指定位置に引数を束縛したクロージャを返す</p>
<p>Example:</p>
<pre><code class="language-php">$bind = nbind('sprintf', 2, 'X');
that($bind('%s%s%s', 'N', 'N'))-&gt;isSame('NXN');
</code></pre>
</div>
    	<h4 class="fqsen-title">method		<small></small>
		<a href="ryunosuke-Functions-Package-Funchand$typespace.html#ryunosuke\Functions\Package\Funchand::lbind()">
                                    ryunosuke\Functions\Package\Funchand::lbind		</a>	<small>($callable, ...$variadic) : callable</small>
		</h4>
	<div class="description"><p>$callable の最左に引数を束縛した callable を返す</p>
<p>Example:</p>
<pre><code class="language-php">$bind = lbind('sprintf', '%s%s');
that($bind('N', 'M'))-&gt;isSame('NM');
</code></pre>
</div>
    	<h4 class="fqsen-title">method		<small></small>
		<a href="ryunosuke-Functions-Package-Funchand$typespace.html#ryunosuke\Functions\Package\Funchand::rbind()">
                                    ryunosuke\Functions\Package\Funchand::rbind		</a>	<small>($callable, ...$variadic) : callable</small>
		</h4>
	<div class="description"><p>$callable の最右に引数を束縛した callable を返す</p>
<p>Example:</p>
<pre><code class="language-php">$bind = rbind('sprintf', 'X');
that($bind('%s%s', 'N'))-&gt;isSame('NX');
</code></pre>
</div>
    	<h4 class="fqsen-title">method		<small></small>
		<a href="ryunosuke-Functions-Package-Funchand$typespace.html#ryunosuke\Functions\Package\Funchand::ope_func()">
                                    ryunosuke\Functions\Package\Funchand::ope_func		</a>	<small>($operator, ...$operands) : <a href="http://php.net/manual/ja/class.closure.php" class="fqsen" target="_blank">\Closure</a></small>
		</h4>
	<div class="description"><p>演算子のクロージャを返す</p>
<p>関数ベースなので <code>??</code> のような言語組み込みの特殊な演算子は若干希望通りにならない（Notice が出る）。<br />
2つ目以降の引数でオペランドを指定できる。</p>
<p>Example:</p>
<pre><code class="language-php">$not = ope_func('!');    // 否定演算子クロージャ
that(false)-&gt;isSame($not(true));

$minus = ope_func('-'); // マイナス演算子クロージャ
that($minus(2))-&gt;isSame(-2);       // 引数1つで呼ぶと1項演算子
that($minus(3, 2))-&gt;isSame(3 - 2); // 引数2つで呼ぶと2項演算子

$cond = ope_func('?:'); // 条件演算子クロージャ
that($cond('OK', 'NG'))-&gt;isSame('OK' ?: 'NG');               // 引数2つで呼ぶと2項演算子
that($cond(false, 'OK', 'NG'))-&gt;isSame(false ? 'OK' : 'NG'); // 引数3つで呼ぶと3項演算子

$gt5 = ope_func('&lt;=', 5); // 5以下を判定するクロージャ
that(array_filter([1, 2, 3, 4, 5, 6, 7, 8, 9], $gt5))-&gt;isSame([1, 2, 3, 4, 5]);
</code></pre>
</div>
    	<h4 class="fqsen-title">method		<small></small>
		<a href="ryunosuke-Functions-Package-Funchand$typespace.html#ryunosuke\Functions\Package\Funchand::not_func()">
                                    ryunosuke\Functions\Package\Funchand::not_func		</a>	<small>($callable) : callable</small>
		</h4>
	<div class="description"><p>返り値の真偽値を逆転した新しいクロージャを返す</p>
<p>Example:</p>
<pre><code class="language-php">$not_strlen = not_func('strlen');
that($not_strlen('hoge'))-&gt;isFalse();
that($not_strlen(''))-&gt;isTrue();
</code></pre>
</div>
    	<h4 class="fqsen-title">method		<small></small>
		<a href="ryunosuke-Functions-Package-Funchand$typespace.html#ryunosuke\Functions\Package\Funchand::eval_func()">
                                    ryunosuke\Functions\Package\Funchand::eval_func		</a>	<small>($expression, ...$variadic) : <a href="http://php.net/manual/ja/class.closure.php" class="fqsen" target="_blank">\Closure</a></small>
		</h4>
	<div class="description"><p>指定コードで eval するクロージャを返す</p>
<p>create_function のクロージャ版みたいなもの。<br />
参照渡しは未対応。</p>
<p>Example:</p>
<pre><code class="language-php">$evalfunc = eval_func('$a + $b + $c', 'a', 'b', 'c');
that($evalfunc(1, 2, 3))-&gt;isSame(6);
</code></pre>
</div>
    	<h4 class="fqsen-title">method		<small></small>
		<a href="ryunosuke-Functions-Package-Funchand$typespace.html#ryunosuke\Functions\Package\Funchand::reflect_callable()">
                                    ryunosuke\Functions\Package\Funchand::reflect_callable		</a>	<small>($callable) : <a href="http://php.net/manual/ja/class.reflectionfunction.php" class="fqsen" target="_blank">\ReflectionFunction</a><span class="type-separator"></span><wbr><a href="http://php.net/manual/ja/class.reflectionmethod.php" class="fqsen" target="_blank">\ReflectionMethod</a></small>
		</h4>
	<div class="description"><p>callable から ReflectionFunctionAbstract を生成する</p>
<p>Example:</p>
<pre><code class="language-php">that(reflect_callable('sprintf'))-&gt;isInstanceOf(\ReflectionFunction::class);
that(reflect_callable('\Closure::bind'))-&gt;isInstanceOf(\ReflectionMethod::class);
</code></pre>
</div>
    	<h4 class="fqsen-title">method		<small></small>
		<a href="ryunosuke-Functions-Package-Funchand$typespace.html#ryunosuke\Functions\Package\Funchand::callable_code()">
                                    ryunosuke\Functions\Package\Funchand::callable_code		</a>	<small>($callable) : array</small>
		</h4>
	<div class="description"><p>callable のコードブロックを返す</p>
<p>返り値は2値の配列。0番目の要素が定義部、1番目の要素が処理部を表す。</p>
<p>Example:</p>
<pre><code class="language-php">list($meta, $body) = callable_code(function(...$args){return true;});
that($meta)-&gt;isSame('function(...$args)');
that($body)-&gt;isSame('{return true;}');

// ReflectionFunctionAbstract を渡しても動作する
list($meta, $body) = callable_code(new \ReflectionFunction(function(...$args){return true;}));
that($meta)-&gt;isSame('function(...$args)');
that($body)-&gt;isSame('{return true;}');
</code></pre>
</div>
    	<h4 class="fqsen-title">method		<small></small>
		<a href="ryunosuke-Functions-Package-Funchand$typespace.html#ryunosuke\Functions\Package\Funchand::call_safely()">
                                    ryunosuke\Functions\Package\Funchand::call_safely		</a>	<small>($callback, ...$variadic) : mixed</small>
		</h4>
	<div class="description"><p>エラーを例外に変換するブロックでコールバックを実行する</p>
<p>Example:</p>
<pre><code class="language-php">try {
    call_safely(function(){return $v;});
}
catch (\Exception $ex) {
    that($ex-&gt;getMessage())-&gt;isSame('Undefined variable: v');
}
</code></pre>
</div>
    	<h4 class="fqsen-title">method		<small></small>
		<a href="ryunosuke-Functions-Package-Funchand$typespace.html#ryunosuke\Functions\Package\Funchand::ob_capture()">
                                    ryunosuke\Functions\Package\Funchand::ob_capture		</a>	<small>($callback, ...$variadic) : string</small>
		</h4>
	<div class="description"><p>ob_start ～ ob_get_clean のブロックでコールバックを実行する</p>
<p>Example:</p>
<pre><code class="language-php">// コールバック内のテキストが得られる
that(ob_capture(function(){echo 123;}))-&gt;isSame('123');
// こういう事もできる
that(ob_capture(function () {
?&gt;
bare string1
bare string2
&lt;?php
}))-&gt;isSame("bare string1\nbare string2\n");
</code></pre>
</div>
    	<h4 class="fqsen-title">method		<small></small>
		<a href="ryunosuke-Functions-Package-Funchand$typespace.html#ryunosuke\Functions\Package\Funchand::is_bindable_closure()">
                                    ryunosuke\Functions\Package\Funchand::is_bindable_closure		</a>	<small>($closure) : bool</small>
		</h4>
	<div class="description"><p>$this を bind 可能なクロージャか調べる</p>
<p>Example:</p>
<pre><code class="language-php">that(is_bindable_closure(function(){}))-&gt;isTrue();
that(is_bindable_closure(static function(){}))-&gt;isFalse();
</code></pre>
</div>
    	<h4 class="fqsen-title">method		<small></small>
		<a href="ryunosuke-Functions-Package-Funchand$typespace.html#ryunosuke\Functions\Package\Funchand::by_builtin()">
                                    ryunosuke\Functions\Package\Funchand::by_builtin		</a>	<small>($class, $function) : bool</small>
		</h4>
	<div class="description"><p>Countable#count, Serializable#serialize などの「ネイティブ由来かメソッド由来か」を判定して返す</p>
<p>Countable#count, Serializable#serialize のように「インターフェースのメソッド名」と「ネイティブ関数名」が一致している必要がある。</p>
<p>Example:</p>
<pre><code class="language-php">class CountClass implements \Countable
{
    public function count() {
        // count 経由なら 1 を、メソッド経由なら 0 を返す
        return (int) by_builtin($this, 'count');
    }
}
$counter = new CountClass();
that(count($counter))-&gt;isSame(1);
that($counter-&gt;count())-&gt;isSame(0);
</code></pre>
<p>のように判定できる。</p>
</div>
    	<h4 class="fqsen-title">method		<small></small>
		<a href="ryunosuke-Functions-Package-Funchand$typespace.html#ryunosuke\Functions\Package\Funchand::namedcallize()">
                                    ryunosuke\Functions\Package\Funchand::namedcallize		</a>	<small>($callable, $defaults = []) : <a href="http://php.net/manual/ja/class.closure.php" class="fqsen" target="_blank">\Closure</a></small>
		</h4>
	<div class="description"><p>callable を名前付き引数で呼べるようにしたクロージャを返す</p>
<p>callable のデフォルト引数は適用されるが、それ以外にも $default でデフォルト値を与えることができる（部分適用のようなものだと思えば良い）。<br />
最終的な優先順位は下記。上に行くほど優先。</p>
<ol>
<li>呼び出し時の引数</li>
<li>この関数の $default 引数</li>
<li>callable のデフォルト引数</li>
</ol>
<p>引数は n 番目でも引数名でもどちらでも良い。<br />
n 番目の場合は引数名に依存しないが、順番に依存してしまう。<br />
引数名の場合は順番に依存しないが、引数名に依存してしまう。</p>
<p>可変引数の場合は 1 と 2 がマージされる。<br />
必須引数が渡されていない or 定義されていない引数が渡された場合は例外を投げる。</p>
<p>Example:</p>
<pre><code class="language-php">// ベースとなる関数（引数をそのまま連想配列で返す）
$f = function ($x, $a = 1, $b = 2, ...$other){return get_defined_vars();};

// x に 'X', a に 9 を与えて名前付きで呼べるクロージャ
$f1 = namedcallize($f, [
    'x' =&gt; 'X',
    'a' =&gt; 9,
]);
// 引数無しで呼ぶと↑で与えた引数が使用される（b は渡されていないのでデフォルト引数の 2 が使用される）
that($f1())-&gt;isSame([
    'x'     =&gt; 'X',
    'a'     =&gt; 9,
    'b'     =&gt; 2,
    'other' =&gt; [],
]);
// 引数付きで呼ぶとそれが優先される
that($f1([
    'x'     =&gt; 'XXX',
    'a'     =&gt; 99,
    'b'     =&gt; 999,
    'other' =&gt; [1, 2, 3],
]))-&gt;isSame([
    'x'     =&gt; 'XXX',
    'a'     =&gt; 99,
    'b'     =&gt; 999,
    'other' =&gt; [1, 2, 3],
]);
// 引数名ではなく、 n 番目指定でも同じ
that($f1([
    'x' =&gt; 'XXX',
    1   =&gt; 99,
    2   =&gt; 999,
    3   =&gt; [1, 2, 3],
]))-&gt;isSame([
    'x'     =&gt; 'XXX',
    'a'     =&gt; 99,
    'b'     =&gt; 999,
    'other' =&gt; [1, 2, 3],
]);

// x に 'X', other に [1, 2, 3] を与えて名前付きで呼べるクロージャ
$f2 = namedcallize($f, [
    'x'     =&gt; 'X',
    'other' =&gt; [1, 2, 3],
]);
// other は可変引数なのでマージされる
that($f2(['other' =&gt; [4, 5, 6]]))-&gt;isSame([
    'x'     =&gt; 'X',
    'a'     =&gt; 1,
    'b'     =&gt; 2,
    'other' =&gt; [1, 2, 3, 4, 5, 6],
]);
</code></pre>
</div>
    	<h4 class="fqsen-title">method		<small></small>
		<a href="ryunosuke-Functions-Package-Funchand$typespace.html#ryunosuke\Functions\Package\Funchand::parameter_length()">
                                    ryunosuke\Functions\Package\Funchand::parameter_length		</a>	<small>($callable, $require_only = false, $thought_variadic = false) : int</small>
		</h4>
	<div class="description"><p>callable の引数の数を返す</p>
<p>クロージャはキャッシュされない。毎回リフレクションを生成し、引数の数を調べてそれを返す。<br />
（クロージャには一意性がないので key-value なキャッシュが適用できない）。<br />
ので、ループ内で使ったりすると目に見えてパフォーマンスが低下するので注意。</p>
<p>Example:</p>
<pre><code class="language-php">// trim の引数は2つ
that(parameter_length('trim'))-&gt;isSame(2);
// trim の必須引数は1つ
that(parameter_length('trim', true))-&gt;isSame(1);
</code></pre>
</div>
    	<h4 class="fqsen-title">method		<small></small>
		<a href="ryunosuke-Functions-Package-Funchand$typespace.html#ryunosuke\Functions\Package\Funchand::parameter_default()">
                                    ryunosuke\Functions\Package\Funchand::parameter_default		</a>	<small>($callable, $arguments = []) : array</small>
		</h4>
	<div class="description"><p>callable のデフォルト引数を返す</p>
<p>オプションで指定もできる。<br />
負数を指定した場合「最後の引数から数えた位置」になる。</p>
<p>内部関数には使用できない（リフレクションが対応していない）。</p>
<p>Example:</p>
<pre><code class="language-php">$f = function ($a, $b = 'b') {};
// デフォルト引数である b を返す
that(parameter_default($f))-&gt;isSame([1 =&gt; 'b']);
// 引数で与えるとそれが優先される
that(parameter_default($f, ['A', 'B']))-&gt;isSame(['A', 'B']);
</code></pre>
</div>
    	<h4 class="fqsen-title">method		<small></small>
		<a href="ryunosuke-Functions-Package-Funchand$typespace.html#ryunosuke\Functions\Package\Funchand::parameter_wiring()">
                                    ryunosuke\Functions\Package\Funchand::parameter_wiring		</a>	<small>($callable, $dependency) : array</small>
		</h4>
	<div class="description"><p>callable の引数の型情報に基づいてワイヤリングした引数配列を返す</p>
<p>ワイヤリングは下記のルールに基づいて行われる。</p>
<ul>
<li>引数の型とキーが完全一致</li>
<li>引数の型とキーが継承・実装関係<ul>
<li>複数一致した場合は解決されない</li>
</ul>
</li>
<li>引数名とキーが完全一致<ul>
<li>可変引数は追加</li>
</ul>
</li>
<li>引数のデフォルト値</li>
<li>得られた値がクロージャの場合は再帰的に解決<ul>
<li>$this は $dependency になるが FromCallable 経由の場合は元のまま</li>
</ul>
</li>
</ul>
<p>Example:</p>
<pre><code class="language-php">$closure = function (\ArrayObject $ao, \Throwable $t, $array, $none, $default1, $default2 = 'default2', ...$misc) { return get_defined_vars(); };
$params = (parameter_wiring)($closure, [
    \ArrayObject::class      =&gt; $ao = new \ArrayObject([1, 2, 3]),
    \RuntimeException::class =&gt; $t = new \RuntimeException('hoge'),
    '$array'                 =&gt; function (\ArrayObject $ao) { return (array) $ao; },
    4                        =&gt; 'default1',
    '$misc'                  =&gt; ['x', 'y', 'z'],
]);
that($params)-&gt;isSame([
    0 =&gt; $ao,        // 0番目はクラス名が完全一致
    1 =&gt; $t,         // 1番目はインターフェース実装
    2 =&gt; [1, 2, 3],  // 2番目はクロージャをコール
                     // 3番目は解決されない
    4 =&gt; 'default1', // 4番目は順番指定のデフォルト値
    5 =&gt; 'default2', // 5番目は引数定義のデフォルト値
    6 =&gt; 'x',        // 可変引数なのでフラットに展開
    7 =&gt; 'y',
    8 =&gt; 'z',
]);
</code></pre>
</div>
    	<h4 class="fqsen-title">method		<small></small>
		<a href="ryunosuke-Functions-Package-Funchand$typespace.html#ryunosuke\Functions\Package\Funchand::function_shorten()">
                                    ryunosuke\Functions\Package\Funchand::function_shorten		</a>	<small>($function) : string</small>
		</h4>
	<div class="description"><p>関数の名前空間部分を除いた短い名前を取得する</p>
</div>
    	<h4 class="fqsen-title">method		<small></small>
		<a href="ryunosuke-Functions-Package-Funchand$typespace.html#ryunosuke\Functions\Package\Funchand::func_user_func_array()">
                                    ryunosuke\Functions\Package\Funchand::func_user_func_array		</a>	<small>($callback) : callable</small>
		</h4>
	<div class="description"><p>パラメータ定義数に応じて呼び出し引数を可変にしてコールする</p>
<p>デフォルト引数はカウントされない。必須パラメータの数で呼び出す。</p>
<p>$callback に null を与えると例外的に「第1引数を返すクロージャ」を返す。</p>
<p>php の標準関数は定義数より多い引数を投げるとエラーを出すのでそれを抑制したい場合に使う。</p>
<p>Example:</p>
<pre><code class="language-php">// strlen に2つの引数を渡してもエラーにならない
$strlen = func_user_func_array('strlen');
that($strlen('abc', null))-&gt;isSame(3);
</code></pre>
</div>
    	<h4 class="fqsen-title">method		<small></small>
		<a href="ryunosuke-Functions-Package-Funchand$typespace.html#ryunosuke\Functions\Package\Funchand::func_wiring()">
                                    ryunosuke\Functions\Package\Funchand::func_wiring		</a>	<small>($callable, $dependency) : <a href="http://php.net/manual/ja/class.closure.php" class="fqsen" target="_blank">\Closure</a></small>
		</h4>
	<div class="description"><p>引数の型情報に基づいてワイヤリングしたクロージャを返す</p>
<p>$dependency に数値キーの配列を混ぜるとデフォルト値として使用される。<br />
得られたクロージャの呼び出し時に引数を与える事ができる。</p>
<p>parameter_wiring も参照。</p>
<p>Example:</p>
<pre><code class="language-php">$closure = function ($a, $b) { return func_get_args(); };
$new_closure = func_wiring($closure, [
    '$a' =&gt; 'a',
    '$b' =&gt; 'b',
    1    =&gt; 'B',
]);
that($new_closure())-&gt;isSame(['a', 'B']);    // 同時指定の場合は数値キー優先
that($new_closure('A'))-&gt;isSame(['A', 'B']); // 呼び出し時の引数優先
</code></pre>
</div>
    	<h4 class="fqsen-title">method		<small></small>
		<a href="ryunosuke-Functions-Package-Funchand$typespace.html#ryunosuke\Functions\Package\Funchand::func_new()">
                                    ryunosuke\Functions\Package\Funchand::func_new		</a>	<small>($classname, ...$defaultargs) : <a href="http://php.net/manual/ja/class.closure.php" class="fqsen" target="_blank">\Closure</a></small>
		</h4>
	<div class="description"><p>指定クラスのコンストラクタを呼び出すクロージャを返す</p>
<p>この関数を呼ぶとコンストラクタのクロージャを返す。</p>
<p>オプションでデフォルト引数を設定できる（Example を参照）。</p>
<p>Example:</p>
<pre><code class="language-php">// Exception のコンストラクタを呼ぶクロージャ
$newException = func_new(\Exception::class, 'hoge');
// デフォルト引数を使用して Exception を作成
that($newException()-&gt;getMessage())-&gt;isSame('hoge');
// 引数を指定して Exception を作成
that($newException('fuga')-&gt;getMessage())-&gt;isSame('fuga');
</code></pre>
</div>
    	<h4 class="fqsen-title">method		<small></small>
		<a href="ryunosuke-Functions-Package-Funchand$typespace.html#ryunosuke\Functions\Package\Funchand::func_method()">
                                    ryunosuke\Functions\Package\Funchand::func_method		</a>	<small>($methodname, ...$defaultargs) : <a href="http://php.net/manual/ja/class.closure.php" class="fqsen" target="_blank">\Closure</a></small>
		</h4>
	<div class="description"><p>指定メソッドを呼び出すクロージャを返す</p>
<p>この関数を呼ぶとメソッドのクロージャを返す。<br />
そのクロージャにオブジェクトを与えて呼び出すとそれはメソッド呼び出しとなる。</p>
<p>オプションでデフォルト引数を設定できる（Example を参照）。</p>
<p>Example:</p>
<pre><code class="language-php">// 与えられた引数を結合して返すメソッド hoge を持つクラス
$object = new class()
{
    function hoge(...$args) { return implode(',', $args); }
};
// hoge を呼び出すクロージャ
$hoge = func_method('hoge');
// ↑を使用して $object の hoge を呼び出す
that($hoge($object, 1, 2, 3))-&gt;isSame('1,2,3');

// デフォルト値付きで hoge を呼び出すクロージャ
$hoge789 = func_method('hoge', 7, 8, 9);
// ↑を使用して $object の hoge を呼び出す（引数指定してるので結果は同じ）
that($hoge789($object, 1, 2, 3))-&gt;isSame('1,2,3');
// 同上（一部デフォルト値）
that($hoge789($object, 1, 2))-&gt;isSame('1,2,9');
// 同上（全部デフォルト値）
that($hoge789($object))-&gt;isSame('7,8,9');
</code></pre>
</div>
    	<h4 class="fqsen-title">method		<small></small>
		<a href="ryunosuke-Functions-Package-Funchand$typespace.html#ryunosuke\Functions\Package\Funchand::function_alias()">
                                    ryunosuke\Functions\Package\Funchand::function_alias		</a>	<small>($original, $alias) : void</small>
		</h4>
	<div class="description"><p>関数のエイリアスを作成する</p>
<p>単に移譲するだけではなく、参照渡し・参照返しも模倣される。<br />
その代わり、単純なエイリアスではなく別定義で吐き出すので「エイリアス」ではなく「処理が同じな別関数」と思ったほうがよい。</p>
<p>静的であればクラスメソッドも呼べる。</p>
<p>Example:</p>
<pre><code class="language-php">// trim のエイリアス
function_alias('trim', 'trim_alias');
that(trim_alias(' abc '))-&gt;isSame('abc');
</code></pre>
</div>
    	<h4 class="fqsen-title">method		<small></small>
		<a href="ryunosuke-Functions-Package-Funchand$typespace.html#ryunosuke\Functions\Package\Funchand::function_parameter()">
                                    ryunosuke\Functions\Package\Funchand::function_parameter		</a>	<small>($eitherReffuncOrCallable) : array</small>
		</h4>
	<div class="description"><p>関数/メソッドの引数定義を取得する</p>
<p>ほぼ内部向けで外から呼ぶことはあまり想定していない。</p>
</div>
            	<h4 class="fqsen-title">class		<small></small>
		<a href="ryunosuke-Functions-Package-Math$typespace.html#ryunosuke\Functions\Package\Math">
                                    ryunosuke\Functions\Package::Math		</a>	</h4>
	<div class="description"><p>数学関連のユーティリティ</p>
</div>
                	<h4 class="fqsen-title">method		<small></small>
		<a href="ryunosuke-Functions-Package-Math$typespace.html#ryunosuke\Functions\Package\Math::minimum()">
                                    ryunosuke\Functions\Package\Math::minimum		</a>	<small>(...$variadic) : mixed</small>
		</h4>
	<div class="description"><p>引数の最小値を返す</p>
<ul>
<li>配列は個数ではなくフラット展開した要素を対象にする</li>
<li>候補がない場合はエラーではなく例外を投げる</li>
</ul>
<p>Example:</p>
<pre><code class="language-php">that(minimum(-1, 0, 1))-&gt;isSame(-1);
</code></pre>
</div>
    	<h4 class="fqsen-title">method		<small></small>
		<a href="ryunosuke-Functions-Package-Math$typespace.html#ryunosuke\Functions\Package\Math::maximum()">
                                    ryunosuke\Functions\Package\Math::maximum		</a>	<small>(...$variadic) : mixed</small>
		</h4>
	<div class="description"><p>引数の最大値を返す</p>
<ul>
<li>配列は個数ではなくフラット展開した要素を対象にする</li>
<li>候補がない場合はエラーではなく例外を投げる</li>
</ul>
<p>Example:</p>
<pre><code class="language-php">that(maximum(-1, 0, 1))-&gt;isSame(1);
</code></pre>
</div>
    	<h4 class="fqsen-title">method		<small></small>
		<a href="ryunosuke-Functions-Package-Math$typespace.html#ryunosuke\Functions\Package\Math::mode()">
                                    ryunosuke\Functions\Package\Math::mode		</a>	<small>(...$variadic) : mixed</small>
		</h4>
	<div class="description"><p>引数の最頻値を返す</p>
<ul>
<li>等価比較は文字列で行う。小数時は注意。おそらく php.ini の precision に従うはず</li>
<li>等価値が複数ある場合の返り値は不定</li>
<li>配列は個数ではなくフラット展開した要素を対象にする</li>
<li>候補がない場合はエラーではなく例外を投げる</li>
</ul>
<p>Example:</p>
<pre><code class="language-php">that(mode(0, 1, 2, 2, 3, 3, 3))-&gt;isSame(3);
</code></pre>
</div>
    	<h4 class="fqsen-title">method		<small></small>
		<a href="ryunosuke-Functions-Package-Math$typespace.html#ryunosuke\Functions\Package\Math::mean()">
                                    ryunosuke\Functions\Package\Math::mean		</a>	<small>(...$variadic) : int<span class="type-separator"></span><wbr>float</small>
		</h4>
	<div class="description"><p>引数の相加平均値を返す</p>
<ul>
<li>is_numeric でない値は除外される（計算結果に影響しない）</li>
<li>配列は個数ではなくフラット展開した要素を対象にする</li>
<li>候補がない場合はエラーではなく例外を投げる</li>
</ul>
<p>Example:</p>
<pre><code class="language-php">that(mean(1, 2, 3, 4, 5, 6))-&gt;isSame(3.5);
that(mean(1, '2', 3, 'noize', 4, 5, 'noize', 6))-&gt;isSame(3.5);
</code></pre>
</div>
    	<h4 class="fqsen-title">method		<small></small>
		<a href="ryunosuke-Functions-Package-Math$typespace.html#ryunosuke\Functions\Package\Math::median()">
                                    ryunosuke\Functions\Package\Math::median		</a>	<small>(...$variadic) : mixed</small>
		</h4>
	<div class="description"><p>引数の中央値を返す</p>
<ul>
<li>要素数が奇数の場合は完全な中央値/偶数の場合は中2つの平均。「平均」という概念が存在しない値なら中2つの後の値</li>
<li>配列は個数ではなくフラット展開した要素を対象にする</li>
<li>候補がない場合はエラーではなく例外を投げる</li>
</ul>
<p>Example:</p>
<pre><code class="language-php">// 偶数個なので中2つの平均
that(median(1, 2, 3, 4, 5, 6))-&gt;isSame(3.5);
// 奇数個なのでど真ん中
that(median(1, 2, 3, 4, 5))-&gt;isSame(3);
// 偶数個だが文字列なので中2つの後
that(median('a', 'b', 'c', 'd'))-&gt;isSame('c');
</code></pre>
</div>
    	<h4 class="fqsen-title">method		<small></small>
		<a href="ryunosuke-Functions-Package-Math$typespace.html#ryunosuke\Functions\Package\Math::average()">
                                    ryunosuke\Functions\Package\Math::average		</a>	<small>(...$variadic) : mixed</small>
		</h4>
	<div class="description"><p>引数の意味平均値を返す</p>
<ul>
<li>3座標の重心座標とか日付の平均とかそういうもの</li>
<li>配列は個数ではなくフラット展開した要素を対象にする</li>
<li>候補がない場合はエラーではなく例外を投げる</li>
</ul>
</div>
    	<h4 class="fqsen-title">method		<small></small>
		<a href="ryunosuke-Functions-Package-Math$typespace.html#ryunosuke\Functions\Package\Math::sum()">
                                    ryunosuke\Functions\Package\Math::sum		</a>	<small>(...$variadic) : mixed</small>
		</h4>
	<div class="description"><p>引数の合計値を返す</p>
<ul>
<li>is_numeric でない値は除外される（計算結果に影響しない）</li>
<li>配列は個数ではなくフラット展開した要素を対象にする</li>
<li>候補がない場合はエラーではなく例外を投げる</li>
</ul>
<p>Example:</p>
<pre><code class="language-php">that(sum(1, 2, 3, 4, 5, 6))-&gt;isSame(21);
</code></pre>
</div>
    	<h4 class="fqsen-title">method		<small></small>
		<a href="ryunosuke-Functions-Package-Math$typespace.html#ryunosuke\Functions\Package\Math::clamp()">
                                    ryunosuke\Functions\Package\Math::clamp		</a>	<small>($value, $min, $max, $circulative = false) : int</small>
		</h4>
	<div class="description"><p>値を一定範囲に収める</p>
<p>$circulative に true を渡すと値が循環する。<br />
ただし、循環的な型に限る（整数のみ？）。</p>
<p>Example:</p>
<pre><code class="language-php">// 5～9 に収める
that(clamp(4, 5, 9))-&gt;isSame(5); // 4 は [5～9] の範囲外なので 5 に切り上げられる
that(clamp(5, 5, 9))-&gt;isSame(5); // 範囲内なのでそのまま
that(clamp(6, 5, 9))-&gt;isSame(6); // 範囲内なのでそのまま
that(clamp(7, 5, 9))-&gt;isSame(7); // 範囲内なのでそのまま
that(clamp(8, 5, 9))-&gt;isSame(8); // 範囲内なのでそのまま
that(clamp(9, 5, 9))-&gt;isSame(9); // 範囲内なのでそのまま
that(clamp(10, 5, 9))-&gt;isSame(9); // 10 は [5～9] の範囲外なので 9 に切り下げられる

// 5～9 に収まるように循環する
that(clamp(4, 5, 9, true))-&gt;isSame(9); // 4 は [5～9] の範囲外なので循環して 9 になる
that(clamp(5, 5, 9, true))-&gt;isSame(5); // 範囲内なのでそのまま
that(clamp(6, 5, 9, true))-&gt;isSame(6); // 範囲内なのでそのまま
that(clamp(7, 5, 9, true))-&gt;isSame(7); // 範囲内なのでそのまま
that(clamp(8, 5, 9, true))-&gt;isSame(8); // 範囲内なのでそのまま
that(clamp(9, 5, 9, true))-&gt;isSame(9); // 範囲内なのでそのまま
that(clamp(10, 5, 9, true))-&gt;isSame(5); // 10 は [5～9] の範囲外なので循環して 5 になる
</code></pre>
</div>
    	<h4 class="fqsen-title">method		<small></small>
		<a href="ryunosuke-Functions-Package-Math$typespace.html#ryunosuke\Functions\Package\Math::decimal()">
                                    ryunosuke\Functions\Package\Math::decimal		</a>	<small>($value, $precision = 0, $mode = 0) : float</small>
		</h4>
	<div class="description"><p>数値を指定桁数に丸める</p>
<p>感覚的には「桁数指定できる ceil/floor」に近い。<br />
ただし、正の方向(ceil)、負の方向(floor)以外にも0の方向、無限大の方向も実装されている（さらに四捨五入もできる）。</p>
<ul>
<li>0   : 0 に近づく方向： 絶対値が必ず減る</li>
<li>null: 0 から離れる方向： 絶対値が必ず増える</li>
<li>-INF: 負の無限大の方向： 数値として必ず減る</li>
<li>+INF : 正の無限大の方向： 数値として必ず増える</li>
</ul>
<p>のように「持っていきたい方向（の数値）」を指定すれば良い（正負自動だけ null で特殊だが）。</p>
<p>Example:</p>
<pre><code class="language-php">that(decimal(-3.14, 1, 0))-&gt;isSame(-3.1);    // 0 に近づく方向
that(decimal(-3.14, 1, null))-&gt;isSame(-3.2); // 0 から離れる方向
that(decimal(-3.14, 1, -INF))-&gt;isSame(-3.2); // 負の無限大の方向
that(decimal(-3.14, 1, +INF))-&gt;isSame(-3.1); // 正の無限大の方向

that(decimal(3.14, 1, 0))-&gt;isSame(3.1);    // 0 に近づく方向
that(decimal(3.14, 1, null))-&gt;isSame(3.2); // 0 から離れる方向
that(decimal(3.14, 1, -INF))-&gt;isSame(3.1); // 負の無限大の方向
that(decimal(3.14, 1, +INF))-&gt;isSame(3.2); // 正の無限大の方向
</code></pre>
</div>
    	<h4 class="fqsen-title">method		<small></small>
		<a href="ryunosuke-Functions-Package-Math$typespace.html#ryunosuke\Functions\Package\Math::random_at()">
                                    ryunosuke\Functions\Package\Math::random_at		</a>	<small>(...$args) : mixed</small>
		</h4>
	<div class="description"><p>引数をランダムで返す</p>
<ul>
<li>候補がない場合はエラーではなく例外を投げる</li>
</ul>
<p>Example:</p>
<pre><code class="language-php">// 1 ～ 6 のどれかを返す
that(random_at(1, 2, 3, 4, 5, 6))-&gt;isAny([1, 2, 3, 4, 5, 6]);
</code></pre>
</div>
    	<h4 class="fqsen-title">method		<small></small>
		<a href="ryunosuke-Functions-Package-Math$typespace.html#ryunosuke\Functions\Package\Math::probability()">
                                    ryunosuke\Functions\Package\Math::probability		</a>	<small>($probability, $divisor = 100) : bool</small>
		</h4>
	<div class="description"><p>一定確率で true を返す</p>
<p>具体的には $probability / $divisor の確率で true を返す。<br />
$divisor のデフォルトは 100 にしてあるので、 $probability だけ与えれば $probability パーセントで true を返すことになる。</p>
<p>Example:</p>
<pre><code class="language-php">// 50% の確率で "hello" を出す
if (probability(50)) {
    echo "hello";
}
</code></pre>
</div>
    	<h4 class="fqsen-title">method		<small></small>
		<a href="ryunosuke-Functions-Package-Math$typespace.html#ryunosuke\Functions\Package\Math::normal_rand()">
                                    ryunosuke\Functions\Package\Math::normal_rand		</a>	<small>($average = 0.0, $std_deviation = 1.0) : float</small>
		</h4>
	<div class="description"><p>正規乱数（正規分布に従う乱数）を返す</p>
<p>※ ボックス＝ミュラー法</p>
<p>Example:</p>
<pre><code class="language-php">mt_srand(4); // テストがコケるので種固定

// 平均 100, 標準偏差 10 の正規乱数を得る
that(normal_rand(100, 10))-&gt;isSame(101.16879645296162);
that(normal_rand(100, 10))-&gt;isSame(96.49615862542069);
that(normal_rand(100, 10))-&gt;isSame(87.74557282679618);
that(normal_rand(100, 10))-&gt;isSame(117.93697951557125);
that(normal_rand(100, 10))-&gt;isSame(99.1917453115627);
that(normal_rand(100, 10))-&gt;isSame(96.74688207698713);
</code></pre>
</div>
            	<h4 class="fqsen-title">class		<small></small>
		<a href="ryunosuke-Functions-Package-Network$typespace.html#ryunosuke\Functions\Package\Network">
                                    ryunosuke\Functions\Package::Network		</a>	</h4>
	<div class="description"><p>ネットワーク関連のユーティリティ</p>
</div>
                	<h4 class="fqsen-title">method		<small></small>
		<a href="ryunosuke-Functions-Package-Network$typespace.html#ryunosuke\Functions\Package\Network::getipaddress()">
                                    ryunosuke\Functions\Package\Network::getipaddress		</a>	<small>($target = &quot;128.0.0.0&quot;) : string</small>
		</h4>
	<div class="description"><p>接続元となる IP を返す</p>
<p>要するに自分の IP を返す。</p>
<p>Example:</p>
<pre><code class="language-php">// 何らかの IP アドレスが返ってくる
that(getipaddress())-&gt;matches('#\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}#');
// 自分への接続元は自分なので 127.0.0.1 を返す
that(getipaddress('127.0.0.9'))-&gt;isSame('127.0.0.1');
</code></pre>
</div>
    	<h4 class="fqsen-title">method		<small></small>
		<a href="ryunosuke-Functions-Package-Network$typespace.html#ryunosuke\Functions\Package\Network::incidr()">
                                    ryunosuke\Functions\Package\Network::incidr		</a>	<small>($ipaddr, $cidr) : bool</small>
		</h4>
	<div class="description"><p>ipv4 の cidr チェック</p>
<p>$ipaddr が $cidr のレンジ内なら true を返す。<br />
$cidr は複数与えることができ、どれかに合致したら true を返す。</p>
<p>ipv6 は今のところ未対応。</p>
<p>Example:</p>
<pre><code class="language-php">// 範囲内なので true
that(incidr('192.168.1.1', '192.168.1.0/24'))-&gt;isTrue();
// 範囲外なので false
that(incidr('192.168.1.1', '192.168.2.0/24'))-&gt;isFalse();
// 1つでも範囲内なら true
that(incidr('192.168.1.1', ['192.168.1.0/24', '192.168.2.0/24']))-&gt;isTrue();
// 全部範囲外なら false
that(incidr('192.168.1.1', ['192.168.2.0/24', '192.168.3.0/24']))-&gt;isFalse();
</code></pre>
</div>
    	<h4 class="fqsen-title">method		<small></small>
		<a href="ryunosuke-Functions-Package-Network$typespace.html#ryunosuke\Functions\Package\Network::ping()">
                                    ryunosuke\Functions\Package\Network::ping		</a>	<small>($host, $port = null, $timeout = 1, &amp;$errstr = &quot;&quot;) : float<span class="type-separator"></span><wbr>bool</small>
		</h4>
	<div class="description"><p>ネットワーク疎通を返す</p>
<p>$port を指定すると TCP/UDP、省略（null）すると ICMP で繋ぐ。<br />
が、 ICMP は root ユーザしか実行できないので ping コマンドにフォールバックする。<br />
TCP/UDP の分岐はマニュアル通り tcp://, udp:// のようなスキームで行う（スキームがなければ tcp）。</p>
<p>udp は結果が不安定なので信頼しないこと（タイムアウトも疎通 OK とみなされる。プロトコルの仕様上どうしようもない）。</p>
<p>Example:</p>
<pre><code class="language-php">// 自身へ ICMP ping を打つ（正常終了なら float を返し、失敗なら false を返す）
that(ping('127.0.0.1'))-&gt;isFloat();
// 自身の tcp:1234 が開いているか（開いていれば float を返し、開いていなければ false を返す）
that(ping('tcp://127.0.0.1', 1234))-&gt;isFalse();
that(ping('127.0.0.1', 1234))-&gt;isFalse(); // tcp はスキームを省略できる
</code></pre>
</div>
    	<h4 class="fqsen-title">method		<small></small>
		<a href="ryunosuke-Functions-Package-Network$typespace.html#ryunosuke\Functions\Package\Network::http_requests()">
                                    ryunosuke\Functions\Package\Network::http_requests		</a>	<small>($urls, $default_options = []) : array</small>
		</h4>
	<div class="description"><p>http リクエストを並列で投げる</p>
<p>$urls で複数の curl を渡し、並列で実行して複数の結果をまとめて返す。<br />
$urls の要素は単一の文字列か curl のオプションである必要がある。</p>
<p>返り値は $urls のキーを保持したまま、レスポンスが返ってきた順に格納して配列で返す。<br />
構造は下記のサンプルを参照。</p>
<p>Example:</p>
<pre><code class="language-php">$responses = http_requests([
    // このように [キー =&gt; CURL オプション] 形式が正しい使い方
    'fuga' =&gt; [
        CURLOPT_URL     =&gt; 'http://unknown-host',
        CURLOPT_TIMEOUT =&gt; 5,
    ],
    // ただし、このように [キー =&gt; URL] 形式でもいい（オプションはデフォルトが使用される）
    'hoge' =&gt; 'http://127.0.0.1',
]);
[
    // キーが維持されるので hoge キー
    'hoge' =&gt; [
        // 0 番目の要素は body 文字列
        'response body',
        // 1 番目の要素は header 配列
        [
            // ・・・・・
            'Content-Type' =&gt; 'text/plain',
            // ・・・・・
        ],
        // 2 番目の要素は curl のメタ配列
        [
            // ・・・・・
        ],
    ],
    // curl のエラーが出た場合は int になる（CURLE_*** の値）
    'fuga' =&gt; 6,
];
</code></pre>
</div>
    	<h4 class="fqsen-title">method		<small></small>
		<a href="ryunosuke-Functions-Package-Network$typespace.html#ryunosuke\Functions\Package\Network::http_request()">
                                    ryunosuke\Functions\Package\Network::http_request		</a>	<small>($options = [], &amp;$response_header = [], &amp;$info = []) : mixed</small>
		</h4>
	<div class="description"><p>curl のラッパー関数</p>
<p>curl は高機能だけど、低レベルで設定が細かすぎる上に似たようなものが大量にあるので素で書くのが割とつらい。<br />
のでデフォルトをスタンダードな設定に寄せつつ、多少便利になるようにラップしている。<br />
まぁ現在では guzzle みたいなクライアントも整ってるし、使い捨てスクリプトでサクッとリクエストを投げたい時用。</p>
<p>生 curl との差異は下記。</p>
<ul>
<li><code>CURLOPT_HTTPHEADER</code> は連想配列指定が可能</li>
<li><code>CURLOPT_POSTFIELDS</code> は連想配列・多次元配列指定が可能</li>
<li>単一ファイル指定は単一アップロードになる</li>
</ul>
<p>さらに独自のオプションとして下記がある。</p>
<ul>
<li><code>raw</code> (bool): curl インスタンスと変換クロージャを返すだけになる<ul>
<li>ただし、ほぼデバッグや内部用なので指定することはほぼ無いはず</li>
</ul>
</li>
<li><code>throw</code> (bool): ステータスコードが 400 以上のときに例外を投げる<ul>
<li><code>CURLOPT_FAILONERROR</code> は原則使わないほうがいいと思う</li>
</ul>
</li>
<li><code>atfile</code> (bool): キーに @ があるフィールドをファイルアップロードとみなす<ul>
<li>悪しき <code>CURLOPT_SAFE_UPLOAD</code> の代替。ただし値ではなくキーで判別する</li>
<li>値が配列のフィールドのキーに @ をつけると連番要素のみアップロードになる</li>
</ul>
</li>
<li><code>cachedir</code> (string): GET のときにクライアントキャッシュや 304 キャッシュが効くようになる<ul>
<li>Cache-Control の private, public は見ないので一応注意</li>
</ul>
</li>
<li><code>parser</code> (array): Content-Type に基づいて body をパースする<ul>
<li>今のところ application/json のみ</li>
</ul>
</li>
</ul>
<p>また、頻出するオプションは下記の定数のエイリアスがあり、単純に読み替えられる。</p>
<ul>
<li><code>url</code>: <code>CURLOPT_URL</code></li>
<li><code>method</code>: <code>CURLOPT_CUSTOMREQUEST</code></li>
<li><code>cookie</code>: <code>CURLOPT_COOKIE</code></li>
<li><code>header</code>: <code>CURLOPT_HTTPHEADER</code></li>
<li><code>body</code>: <code>CURLOPT_POSTFIELDS</code></li>
<li><code>cookie_file</code>: <code>CURLOPT_COOKIEJAR</code>, <code>CURLOPT_COOKIEFILE</code></li>
</ul>
<p>Example:</p>
<pre><code class="language-php">$response = http_request([
    'url'    =&gt; 'http://httpbin.org/post?name=value',
    'method' =&gt; 'POST',
    'body'   =&gt; ['k1' =&gt; 'v1', 'k2' =&gt; 'v2'],
]);
that($response['args'])-&gt;is([
    'name' =&gt; 'value',
]);
that($response['form'])-&gt;is([
    'k1' =&gt; 'v1',
    'k2' =&gt; 'v2',
]);
</code></pre>
</div>
    	<h4 class="fqsen-title">method		<small></small>
		<a href="ryunosuke-Functions-Package-Network$typespace.html#ryunosuke\Functions\Package\Network::http_head()">
                                    ryunosuke\Functions\Package\Network::http_head		</a>	<small>($url, $data = [], $options = [], &amp;$response_header = [], &amp;$info = []) : array</small>
		</h4>
	<div class="description"><p><tag_link data-kind='fqsen' data-type-category='method' data-type-fqsen='ryunosuke\Functions\Package\Network::http_request()' data-type-array='0' data-type-nullable='' data-description='http_request'>http_request</tag_link> の HEAD 特化版</p>
</div>
    	<h4 class="fqsen-title">method		<small></small>
		<a href="ryunosuke-Functions-Package-Network$typespace.html#ryunosuke\Functions\Package\Network::http_get()">
                                    ryunosuke\Functions\Package\Network::http_get		</a>	<small>($url, $data = [], $options = [], &amp;$response_header = [], &amp;$info = []) : mixed</small>
		</h4>
	<div class="description"><p><tag_link data-kind='fqsen' data-type-category='method' data-type-fqsen='ryunosuke\Functions\Package\Network::http_request()' data-type-array='0' data-type-nullable='' data-description='http_request'>http_request</tag_link> の GET 特化版</p>
</div>
    	<h4 class="fqsen-title">method		<small></small>
		<a href="ryunosuke-Functions-Package-Network$typespace.html#ryunosuke\Functions\Package\Network::http_post()">
                                    ryunosuke\Functions\Package\Network::http_post		</a>	<small>($url, $data = [], $options = [], &amp;$response_header = [], &amp;$info = []) : mixed</small>
		</h4>
	<div class="description"><p><tag_link data-kind='fqsen' data-type-category='method' data-type-fqsen='ryunosuke\Functions\Package\Network::http_request()' data-type-array='0' data-type-nullable='' data-description='http_request'>http_request</tag_link> の POST 特化版</p>
</div>
    	<h4 class="fqsen-title">method		<small></small>
		<a href="ryunosuke-Functions-Package-Network$typespace.html#ryunosuke\Functions\Package\Network::http_put()">
                                    ryunosuke\Functions\Package\Network::http_put		</a>	<small>($url, $data = [], $options = [], &amp;$response_header = [], &amp;$info = []) : mixed</small>
		</h4>
	<div class="description"><p><tag_link data-kind='fqsen' data-type-category='method' data-type-fqsen='ryunosuke\Functions\Package\Network::http_request()' data-type-array='0' data-type-nullable='' data-description='http_request'>http_request</tag_link> の PUT 特化版</p>
</div>
    	<h4 class="fqsen-title">method		<small></small>
		<a href="ryunosuke-Functions-Package-Network$typespace.html#ryunosuke\Functions\Package\Network::http_patch()">
                                    ryunosuke\Functions\Package\Network::http_patch		</a>	<small>($url, $data = [], $options = [], &amp;$response_header = [], &amp;$info = []) : mixed</small>
		</h4>
	<div class="description"><p><tag_link data-kind='fqsen' data-type-category='method' data-type-fqsen='ryunosuke\Functions\Package\Network::http_request()' data-type-array='0' data-type-nullable='' data-description='http_request'>http_request</tag_link> の PATCH 特化版</p>
</div>
    	<h4 class="fqsen-title">method		<small></small>
		<a href="ryunosuke-Functions-Package-Network$typespace.html#ryunosuke\Functions\Package\Network::http_delete()">
                                    ryunosuke\Functions\Package\Network::http_delete		</a>	<small>($url, $data = [], $options = [], &amp;$response_header = [], &amp;$info = []) : mixed</small>
		</h4>
	<div class="description"><p><tag_link data-kind='fqsen' data-type-category='method' data-type-fqsen='ryunosuke\Functions\Package\Network::http_request()' data-type-array='0' data-type-nullable='' data-description='http_request'>http_request</tag_link> の DELETE 特化版</p>
</div>
            	<h4 class="fqsen-title">class		<small></small>
		<a href="ryunosuke-Functions-Package-Sql$typespace.html#ryunosuke\Functions\Package\Sql">
                                    ryunosuke\Functions\Package::Sql		</a>	</h4>
	<div class="description"><p>Sql 関連のユーティリティ</p>
</div>
        	<h4 class="fqsen-title">classconstant		<small>array</small>
		<a href="ryunosuke-Functions-Package-Sql$typespace.html#ryunosuke\Functions\Package\Sql::KEYWORDS">
                                    ryunosuke\Functions\Package\Sql::KEYWORDS		</a>	</h4>
	<div class="description"><p>SQL キーワード（全 RDBMS ごちゃまぜ）</p>
</div>
            	<h4 class="fqsen-title">method		<small></small>
		<a href="ryunosuke-Functions-Package-Sql$typespace.html#ryunosuke\Functions\Package\Sql::sql_quote()">
                                    ryunosuke\Functions\Package\Sql::sql_quote		</a>	<small>($value) : mixed</small>
		</h4>
	<div class="description"><p>ものすごく雑に値をクオートする</p>
<p>非常に荒くアドホックに実装しているのでこの関数で得られた値で<strong>実際に実行してはならない</strong>。<br />
あくまでログ出力やデバッグ用途で視認性を高める目的である。</p>
<ul>
<li>null は NULL になる</li>
<li>数字はそのまま数字になる</li>
<li>bool は 0 or 1 になる</li>
<li>それ以外は addcslashes される</li>
</ul>
<p>Example:</p>
<pre><code class="language-php">that(sql_quote(null))-&gt;isSame('NULL');
that(sql_quote(123))-&gt;isSame(123);
that(sql_quote(true))-&gt;isSame(1);
that(sql_quote("hoge"))-&gt;isSame("'hoge'");
</code></pre>
</div>
    	<h4 class="fqsen-title">method		<small></small>
		<a href="ryunosuke-Functions-Package-Sql$typespace.html#ryunosuke\Functions\Package\Sql::sql_bind()">
                                    ryunosuke\Functions\Package\Sql::sql_bind		</a>	<small>($sql, $values) : mixed</small>
		</h4>
	<div class="description"><p>ものすごく雑に SQL に値を埋め込む</p>
<p>非常に荒くアドホックに実装しているのでこの関数で得られた SQL を<strong>実際に実行してはならない</strong>。<br />
あくまでログ出力やデバッグ用途で視認性を高める目的である。</p>
<p>プレースホルダは ? か :alnum で混在していても良い。</p>
<p>Example:</p>
<pre><code class="language-php">that(sql_bind('select ?', 1))-&gt;isSame("select 1");
that(sql_bind('select :hoge', ['hoge' =&gt; 'hoge']))-&gt;isSame("select 'hoge'");
that(sql_bind('select ?, :hoge', [1, 'hoge' =&gt; 'hoge']))-&gt;isSame("select 1, 'hoge'");
</code></pre>
</div>
    	<h4 class="fqsen-title">method		<small></small>
		<a href="ryunosuke-Functions-Package-Sql$typespace.html#ryunosuke\Functions\Package\Sql::sql_format()">
                                    ryunosuke\Functions\Package\Sql::sql_format		</a>	<small>($sql, $options = []) : string</small>
		</h4>
	<div class="description"><p>ものすごく雑に SQL を整形する</p>
<p>非常に荒くアドホックに実装しているのでこの関数で得られた SQL を<strong>実際に実行してはならない</strong>。<br />
あくまでログ出力やデバッグ用途で視認性を高める目的である。</p>
<p>JOIN 句は FROM 句とみなさず、別句として処理する。<br />
AND と &amp;&amp; は微妙に処理が異なる。 AND は改行されるが &amp;&amp; は改行されない（OR と || も同様）。</p>
</div>
            	<h4 class="fqsen-title">class		<small></small>
		<a href="ryunosuke-Functions-Package-Strings$typespace.html#ryunosuke\Functions\Package\Strings">
                                    ryunosuke\Functions\Package::Strings		</a>	</h4>
	<div class="description"><p>文字列関連のユーティリティ</p>
</div>
        	<h4 class="fqsen-title">classconstant		<small>integer</small>
		<a href="ryunosuke-Functions-Package-Strings$typespace.html#ryunosuke\Functions\Package\Strings::JSON_MAX_DEPTH">
                                    ryunosuke\Functions\Package\Strings::JSON_MAX_DEPTH		</a>	</h4>
	<div class="description"><p>json_*** 関数で $depth 引数を表す定数</p>
</div>
    	<h4 class="fqsen-title">classconstant		<small>integer</small>
		<a href="ryunosuke-Functions-Package-Strings$typespace.html#ryunosuke\Functions\Package\Strings::JSON_ES5">
                                    ryunosuke\Functions\Package\Strings::JSON_ES5		</a>	</h4>
	<div class="description"><p>json_*** 関数で json5 を取り扱うかの定数</p>
</div>
    	<h4 class="fqsen-title">classconstant		<small>integer</small>
		<a href="ryunosuke-Functions-Package-Strings$typespace.html#ryunosuke\Functions\Package\Strings::JSON_INT_AS_STRING">
                                    ryunosuke\Functions\Package\Strings::JSON_INT_AS_STRING		</a>	</h4>
	<div class="description"><p>json_*** 関数で整数を常に文字列で返すかの定数</p>
</div>
    	<h4 class="fqsen-title">classconstant		<small>integer</small>
		<a href="ryunosuke-Functions-Package-Strings$typespace.html#ryunosuke\Functions\Package\Strings::JSON_FLOAT_AS_STRING">
                                    ryunosuke\Functions\Package\Strings::JSON_FLOAT_AS_STRING		</a>	</h4>
	<div class="description"><p>json_*** 関数で小数を常に文字列で返すかの定数</p>
</div>
            	<h4 class="fqsen-title">method		<small></small>
		<a href="ryunosuke-Functions-Package-Strings$typespace.html#ryunosuke\Functions\Package\Strings::strcat()">
                                    ryunosuke\Functions\Package\Strings::strcat		</a>	<small>(...$variadic) : string</small>
		</h4>
	<div class="description"><p>文字列結合の関数版</p>
<p>Example:</p>
<pre><code class="language-php">that(strcat('a', 'b', 'c'))-&gt;isSame('abc');
</code></pre>
</div>
    	<h4 class="fqsen-title">method		<small></small>
		<a href="ryunosuke-Functions-Package-Strings$typespace.html#ryunosuke\Functions\Package\Strings::concat()">
                                    ryunosuke\Functions\Package\Strings::concat		</a>	<small>(...$variadic) : string</small>
		</h4>
	<div class="description"><p>strcat の空文字回避版</p>
<p>基本は strcat と同じ。ただし、<strong>引数の内1つでも空文字を含むなら空文字を返す</strong>。</p>
<p>「プレフィックスやサフィックスを付けたいんだけど、空文字の場合はそのままで居て欲しい」という状況はまれによくあるはず。<br />
コードで言えば <code>strlen($string) ? 'prefix-' . $string : '';</code> のようなもの。<br />
可変引数なので 端的に言えば mysql の CONCAT みたいな動作になる（あっちは NULL だが）。</p>
<pre><code class="language-php">that(concat('prefix-', 'middle', '-suffix'))-&gt;isSame('prefix-middle-suffix');
that(concat('prefix-', '', '-suffix'))-&gt;isSame('');
</code></pre>
</div>
    	<h4 class="fqsen-title">method		<small></small>
		<a href="ryunosuke-Functions-Package-Strings$typespace.html#ryunosuke\Functions\Package\Strings::split_noempty()">
                                    ryunosuke\Functions\Package\Strings::split_noempty		</a>	<small>($delimiter, $string, $trimchars = true) : array</small>
		</h4>
	<div class="description"><p>空文字を除外する文字列分割</p>
<ul>
<li>空文字を任意の区切り文字で分割しても常に空配列</li>
<li>キーは連番で返す（歯抜けがないただの配列）</li>
</ul>
<p>$triming を指定した場合、結果配列にも影響する。<br />
つまり「除外は trim したいが結果配列にはしたくない」はできない。</p>
<p>Example:</p>
<pre><code class="language-php">that(split_noempty(',', 'a, b, c'))-&gt;isSame(['a', 'b', 'c']);
that(split_noempty(',', 'a, , , b, c'))-&gt;isSame(['a', 'b', 'c']);
that(split_noempty(',', 'a, , , b, c', false))-&gt;isSame(['a', ' ', ' ', ' b', ' c']);
</code></pre>
</div>
    	<h4 class="fqsen-title">method		<small></small>
		<a href="ryunosuke-Functions-Package-Strings$typespace.html#ryunosuke\Functions\Package\Strings::multiexplode()">
                                    ryunosuke\Functions\Package\Strings::multiexplode		</a>	<small>($delimiter, $string, $limit = PHP_INT_MAX) : array</small>
		</h4>
	<div class="description"><p>explode の配列対応と $limit の挙動を変えたもの</p>
<p>$delimiter には配列が使える。いわゆる「複数文字列での分割」の動作になる。</p>
<p>$limit に負数を与えると「その絶対値-1までを結合したものと残り」を返す。<br />
端的に言えば「正数を与えると後詰めでその個数で返す」「負数を与えると前詰めでその（絶対値）個数で返す」という動作になる。</p>
<p>Example:</p>
<pre><code class="language-php">// 配列を与えると複数文字列での分割
that(multiexplode([',', ' ', '|'], 'a,b c|d'))-&gt;isSame(['a', 'b', 'c', 'd']);
// 負数を与えると前詰め
that(multiexplode(',', 'a,b,c,d', -2))-&gt;isSame(['a,b,c', 'd']);
// もちろん上記2つは共存できる
that(multiexplode([',', ' ', '|'], 'a,b c|d', -2))-&gt;isSame(['a,b c', 'd']);
</code></pre>
</div>
    	<h4 class="fqsen-title">method		<small></small>
		<a href="ryunosuke-Functions-Package-Strings$typespace.html#ryunosuke\Functions\Package\Strings::quoteexplode()">
                                    ryunosuke\Functions\Package\Strings::quoteexplode		</a>	<small>($delimiter, $string, $limit = null, $enclosures = &quot;&#039;\&quot;&quot;, $escape = &quot;\\&quot;) : array</small>
		</h4>
	<div class="description"><p>エスケープやクオートに対応した explode</p>
<p>$enclosures は配列で開始・終了文字が別々に指定できるが、実装上の都合で今のところ1文字ずつのみ。</p>
<p>歴史的な理由により第3引数は $limit でも $enclosures でもどちらでも渡すことができる。</p>
<p>Example:</p>
<pre><code class="language-php">// シンプルな例
that(quoteexplode(',', 'a,b,c\\,d,"e,f"'))-&gt;isSame([
    'a', // 普通に分割される
    'b', // 普通に分割される
    'c\\,d', // \\ でエスケープしているので区切り文字とみなされない
    '"e,f"', // "" でクオートされているので区切り文字とみなされない
]);

// $enclosures で囲い文字の開始・終了文字を明示できる
that(quoteexplode(',', 'a,b,{e,f}', ['{' =&gt; '}']))-&gt;isSame([
    'a', // 普通に分割される
    'b', // 普通に分割される
    '{e,f}', // { } で囲まれているので区切り文字とみなされない
]);

// このように第3引数に $limit 引数を差し込むことができる
that(quoteexplode(',', 'a,b,{e,f}', 2, ['{' =&gt; '}']))-&gt;isSame([
    'a',
    'b,{e,f}',
]);
</code></pre>
</div>
    	<h4 class="fqsen-title">method		<small></small>
		<a href="ryunosuke-Functions-Package-Strings$typespace.html#ryunosuke\Functions\Package\Strings::strrstr()">
                                    ryunosuke\Functions\Package\Strings::strrstr		</a>	<small>($haystack, $needle, $after_needle = true) : string</small>
		</h4>
	<div class="description"><p>文字列が最後に現れる位置以前を返す</p>
<p>strstr の逆のイメージで文字列を後ろから探索する動作となる。<br />
strstr の動作は「文字列を前から探索して指定文字列があったらそれ以後を返す」なので、<br />
その逆の動作の「文字列を後ろから探索して指定文字列があったらそれ以前を返す」という挙動を示す。</p>
<p>strstr の「needle が文字列でない場合は、 それを整数に変換し、その番号に対応する文字として扱います」は直感的じゃないので踏襲しない。<br />
（全体的にこの動作をやめよう、という RFC もあったはず）。</p>
<p>第3引数の意味合いもデフォルト値も逆になるので、単純に呼べばよくある「指定文字列より後ろを（指定文字列を含めないで）返す」という動作になる。</p>
<p>Example:</p>
<pre><code class="language-php">// パス中の最後のディレクトリを取得
that(strrstr("path/to/1:path/to/2:path/to/3", ":"))-&gt;isSame('path/to/3');
// $after_needle を false にすると逆の動作になる
that(strrstr("path/to/1:path/to/2:path/to/3", ":", false))-&gt;isSame('path/to/1:path/to/2:');
// （参考）strrchr と違い、文字列が使えるしその文字そのものは含まれない
that(strrstr("A\r\nB\r\nC", "\r\n"))-&gt;isSame('C');
</code></pre>
</div>
    	<h4 class="fqsen-title">method		<small></small>
		<a href="ryunosuke-Functions-Package-Strings$typespace.html#ryunosuke\Functions\Package\Strings::strpos_array()">
                                    ryunosuke\Functions\Package\Strings::strpos_array		</a>	<small>($haystack, $needles, $offset = 0) : array</small>
		</h4>
	<div class="description"><p>複数の文字列で strpos する</p>
<p>$needles のそれぞれの位置を配列で返す。<br />
ただし、見つからなかった文字は結果に含まれない。</p>
<p>Example:</p>
<pre><code class="language-php">// 見つかった位置を返す
that(strpos_array('hello world', ['hello', 'world']))-&gt;isSame([
    0 =&gt; 0,
    1 =&gt; 6,
]);
// 見つからない文字は含まれない
that(strpos_array('hello world', ['notfound', 'world']))-&gt;isSame([
    1 =&gt; 6,
]);
</code></pre>
</div>
    	<h4 class="fqsen-title">method		<small></small>
		<a href="ryunosuke-Functions-Package-Strings$typespace.html#ryunosuke\Functions\Package\Strings::strpos_quoted()">
                                    ryunosuke\Functions\Package\Strings::strpos_quoted		</a>	<small>($haystack, $needle, $offset = 0, $enclosure = &quot;&#039;\&quot;&quot;, $escape = &quot;\\&quot;) : false<span class="type-separator"></span><wbr>int</small>
		</h4>
	<div class="description"><p>クオートを考慮して strpos する</p>
<p>Example:</p>
<pre><code class="language-php">// クオート中は除外される
that(strpos_quoted('hello "this" is world', 'is'))-&gt;isSame(13);
// 開始位置やクオート文字は指定できる（5文字目以降の \* に囲まれていない hoge の位置を返す）
that(strpos_quoted('1:hoge, 2:*hoge*, 3:hoge', 'hoge', 5, '*'))-&gt;isSame(20);
</code></pre>
</div>
    	<h4 class="fqsen-title">method		<small></small>
		<a href="ryunosuke-Functions-Package-Strings$typespace.html#ryunosuke\Functions\Package\Strings::str_chunk()">
                                    ryunosuke\Functions\Package\Strings::str_chunk		</a>	<small>($string, ...$chunks) : string[]</small>
		</h4>
	<div class="description"><p>文字列を可変引数の数で分割する</p>
<p>str_split の $length を個別に指定できるイメージ。<br />
長さ以上を指定したりしても最後の要素は必ずついてくる（指定数で分割した後のあまり文字が最後の要素になる）。<br />
これは最後が空文字でも同様で、 list での代入を想定しているため。</p>
<p>Example:</p>
<pre><code class="language-php">// 1, 2, 3 文字に分割（ぴったりなので変わったことはない）
that(str_chunk('abcdef', 1, 2, 3))-&gt;isSame(['a', 'bc', 'def', '']);
// 2, 3 文字に分割（余った f も最後の要素として含まれてくる）
that(str_chunk('abcdef', 2, 3))-&gt;isSame(['ab', 'cde', 'f']);
// 1, 10 文字に分割
that(str_chunk('abcdef', 1, 10))-&gt;isSame(['a', 'bcdef', '']);
</code></pre>
</div>
    	<h4 class="fqsen-title">method		<small></small>
		<a href="ryunosuke-Functions-Package-Strings$typespace.html#ryunosuke\Functions\Package\Strings::str_anyof()">
                                    ryunosuke\Functions\Package\Strings::str_anyof		</a>	<small>($needle, $haystack, $case_insensitivity = false) : bool</small>
		</h4>
	<div class="description"><p>文字列が候補の中にあるか調べる</p>
<p>候補配列の中に対象文字列があるならそのキーを返す。ないなら null を返す。</p>
<p>あくまで文字列としての比較に徹する（in_array/array_search の第3引数は厳密すぎて使いにくいことがある）。<br />
ので array_search の文字列特化版とも言える。<br />
動作的には <code>array_flip($haystack)[$needle] ?? null</code> と同じ（大文字小文字オプションはあるけど）。<br />
ただ array_flip は巨大配列に弱いし、大文字小文字などの融通が効かないので foreach での素朴な実装になっている。</p>
<p>Example:</p>
<pre><code class="language-php">that(str_anyof('b', ['a', 'b', 'c']))-&gt;isSame(1);       // 見つかったキーを返す
that(str_anyof('x', ['a', 'b', 'c']))-&gt;isSame(null);    // 見つからないなら null を返す
that(str_anyof('C', ['a', 'b', 'c'], true))-&gt;isSame(2); // 大文字文字を区別しない
that(str_anyof('1', [1, 2, 3]))-&gt;isSame(0);             // 文字列の比較に徹する
that(str_anyof(2, ['1', '2', '3']))-&gt;isSame(1);         // 同上
</code></pre>
</div>
    	<h4 class="fqsen-title">method		<small></small>
		<a href="ryunosuke-Functions-Package-Strings$typespace.html#ryunosuke\Functions\Package\Strings::str_equals()">
                                    ryunosuke\Functions\Package\Strings::str_equals		</a>	<small>($str1, $str2, $case_insensitivity = false) : bool</small>
		</h4>
	<div class="description"><p>文字列比較の関数版</p>
<p>文字列以外が与えられた場合は常に false を返す。ただし __toString を実装したオブジェクトは別。</p>
<p>Example:</p>
<pre><code class="language-php">that(str_equals('abc', 'abc'))-&gt;isTrue();
that(str_equals('abc', 'ABC', true))-&gt;isTrue();
that(str_equals('\0abc', '\0abc'))-&gt;isTrue();
</code></pre>
</div>
    	<h4 class="fqsen-title">method		<small></small>
		<a href="ryunosuke-Functions-Package-Strings$typespace.html#ryunosuke\Functions\Package\Strings::str_contains()">
                                    ryunosuke\Functions\Package\Strings::str_contains		</a>	<small>($haystack, $needle, $case_insensitivity = false, $and_flag = false) : bool</small>
		</h4>
	<div class="description"><p>指定文字列を含むか返す</p>
</div>
    	<h4 class="fqsen-title">method		<small></small>
		<a href="ryunosuke-Functions-Package-Strings$typespace.html#ryunosuke\Functions\Package\Strings::str_exists()">
                                    ryunosuke\Functions\Package\Strings::str_exists		</a>	<small>($haystack, $needle, $case_insensitivity = false, $and_flag = false) : bool</small>
		</h4>
	<div class="description"><p>指定文字列を含むか返す</p>
<p>Example:</p>
<pre><code class="language-php">that(str_exists('abc', 'b'))-&gt;isTrue();
that(str_exists('abc', 'B', true))-&gt;isTrue();
that(str_exists('abc', ['b', 'x'], false, false))-&gt;isTrue();
that(str_exists('abc', ['b', 'x'], false, true))-&gt;isFalse();
</code></pre>
</div>
    	<h4 class="fqsen-title">method		<small></small>
		<a href="ryunosuke-Functions-Package-Strings$typespace.html#ryunosuke\Functions\Package\Strings::str_chop()">
                                    ryunosuke\Functions\Package\Strings::str_chop		</a>	<small>($string, $prefix = null, $suffix = null, $case_insensitivity = false) : string</small>
		</h4>
	<div class="description"><p>先頭・末尾の指定文字列を削ぎ落とす</p>
<p>Example:</p>
<pre><code class="language-php">// 文字列からパス文字列と拡張子を削ぎ落とす
$PATH = '/path/to/something';
that(str_chop("$PATH/hoge.php", "$PATH/", '.php'))-&gt;isSame('hoge');
</code></pre>
</div>
    	<h4 class="fqsen-title">method		<small></small>
		<a href="ryunosuke-Functions-Package-Strings$typespace.html#ryunosuke\Functions\Package\Strings::str_lchop()">
                                    ryunosuke\Functions\Package\Strings::str_lchop		</a>	<small>($string, $prefix, $case_insensitivity = false) : string</small>
		</h4>
	<div class="description"><p>先頭の指定文字列を削ぎ落とす</p>
<p>Example:</p>
<pre><code class="language-php">// 文字列からパス文字列を削ぎ落とす
$PATH = '/path/to/something';
that(str_lchop("$PATH/hoge.php", "$PATH/"))-&gt;isSame('hoge.php');
</code></pre>
</div>
    	<h4 class="fqsen-title">method		<small></small>
		<a href="ryunosuke-Functions-Package-Strings$typespace.html#ryunosuke\Functions\Package\Strings::str_rchop()">
                                    ryunosuke\Functions\Package\Strings::str_rchop		</a>	<small>($string, $suffix = null, $case_insensitivity = false) : string</small>
		</h4>
	<div class="description"><p>末尾の指定文字列を削ぎ落とす</p>
<p>Example:</p>
<pre><code class="language-php">// 文字列から .php を削ぎ落とす
$PATH = '/path/to/something';
that(str_rchop("$PATH/hoge.php", ".php"))-&gt;isSame("$PATH/hoge");
</code></pre>
</div>
    	<h4 class="fqsen-title">method		<small></small>
		<a href="ryunosuke-Functions-Package-Strings$typespace.html#ryunosuke\Functions\Package\Strings::str_putcsv()">
                                    ryunosuke\Functions\Package\Strings::str_putcsv		</a>	<small>($array, $delimiter = &quot;,&quot;, $enclosure = &quot;\&quot;&quot;, $escape = &quot;\\&quot;) : string</small>
		</h4>
	<div class="description"><p>fputcsv の文字列版（str_getcsv の put 版）</p>
<p>エラーは例外に変換される。</p>
<p>普通の配列を与えるとシンプルに "a,b,c" のような1行を返す。<br />
多次元配列（2次元のみを想定）や Traversable を与えるとループして "a,b,c\nd,e,f" のような複数行を返す。</p>
<p>Example:</p>
<pre><code class="language-php">// シンプルな1行を返す
that(str_putcsv(['a', 'b', 'c']))-&gt;isSame("a,b,c");
that(str_putcsv(['a', 'b', 'c'], "\t"))-&gt;isSame("a\tb\tc");
that(str_putcsv(['a', ' b ', 'c'], " ", "'"))-&gt;isSame("a ' b ' c");

// 複数行を返す
that(str_putcsv([['a', 'b', 'c'], ['d', 'e', 'f']]))-&gt;isSame("a,b,c\nd,e,f");
that(str_putcsv((function() {
    yield ['a', 'b', 'c'];
    yield ['d', 'e', 'f'];
})()))-&gt;isSame("a,b,c\nd,e,f");
</code></pre>
</div>
    	<h4 class="fqsen-title">method		<small></small>
		<a href="ryunosuke-Functions-Package-Strings$typespace.html#ryunosuke\Functions\Package\Strings::str_subreplace()">
                                    ryunosuke\Functions\Package\Strings::str_subreplace		</a>	<small>($subject, $search, $replaces, $case_insensitivity = false) : string</small>
		</h4>
	<div class="description"><p>指定文字列を置換する</p>
<p>$subject 内の $search を $replaces に置換する。<br />
str_replace とは「N 番目のみ置換できる」点で異なる。<br />
つまり、$search='hoge', $replace=[2 =&gt; 'fuga'] とすると「2 番目の 'hoge' が 'fuga' に置換される」という動作になる（0 ベース）。</p>
<p>$replace に 非配列を与えた場合は配列化される。<br />
つまり <code>$replaces = 'hoge'</code> は <code>$replaces = [0 =&gt; 'hoge']</code> と同じ（最初のマッチを置換する）。</p>
<p>$replace に空配列を与えると何もしない。<br />
負数キーは後ろから数える動作となる。<br />
また、置換後の文字列は置換対象にはならない。</p>
<p>N 番目の検索文字列が見つからない場合は例外を投げる。<br />
ただし、文字自体が見つからない場合は投げない。</p>
<p>Example:</p>
<pre><code class="language-php">// 1番目（0ベースなので2番目）の x を X に置換
that(str_subreplace('xxx', 'x', [1 =&gt; 'X']))-&gt;isSame('xXx');
// 0番目（最前列）の x を Xa に、-1番目（最後尾）の x を Xz に置換
that(str_subreplace('!xxx!', 'x', [0 =&gt; 'Xa', -1 =&gt; 'Xz']))-&gt;isSame('!XaxXz!');
// 置換結果は置換対象にならない
that(str_subreplace('xxx', 'x', [0 =&gt; 'xxx', 1 =&gt; 'X']))-&gt;isSame('xxxXx');
</code></pre>
</div>
    	<h4 class="fqsen-title">method		<small></small>
		<a href="ryunosuke-Functions-Package-Strings$typespace.html#ryunosuke\Functions\Package\Strings::str_submap()">
                                    ryunosuke\Functions\Package\Strings::str_submap		</a>	<small>($subject, $replaces, $case_insensitivity = false) : string</small>
		</h4>
	<div class="description"><p>指定文字列を置換する</p>
<p>$subject を $replaces に従って置換する。<br />
具体的には「$replaces を 複数指定できる str_subreplace」に近い。</p>
<p>strtr とは「N 番目のみ置換できる」点で異なる。<br />
つまり、$replaces=['hoge' =&gt; [2 =&gt; 'fuga']] とすると「2 番目の 'hoge' が 'fuga' に置換される」という動作になる（0 ベース）。</p>
<p>$replaces の要素に非配列を与えた場合は配列化される。<br />
つまり <code>$replaces = ['hoge' =&gt; 'fuga']</code> は <code>$replaces = ['hoge' =&gt; ['fuga']]</code> と同じ（最初のマッチを置換する）。</p>
<p>$replace に空配列を与えると何もしない。<br />
負数キーは後ろから数える動作となる。<br />
また、置換後の文字列は置換対象にはならない。</p>
<p>N 番目の検索文字列が見つからない場合は例外を投げる。<br />
ただし、文字自体が見つからない場合は投げない。</p>
<p>Example:</p>
<pre><code class="language-php">// "hello, world" の l と o を置換
that(str_submap('hello, world', [
    // l は0番目と2番目のみを置換（1番目は何も行われない）
    'l' =&gt; [
        0 =&gt; 'L1',
        2 =&gt; 'L3',
    ],
    // o は後ろから数えて1番目を置換
    'o' =&gt; [
        -1 =&gt; 'O',
    ],
]))-&gt;isSame('heL1lo, wOrL3d');
</code></pre>
</div>
    	<h4 class="fqsen-title">method		<small></small>
		<a href="ryunosuke-Functions-Package-Strings$typespace.html#ryunosuke\Functions\Package\Strings::str_embed()">
                                    ryunosuke\Functions\Package\Strings::str_embed		</a>	<small>($string, $replacemap, $enclosure = &quot;&#039;\&quot;&quot;, $escape = &quot;\\&quot;) : string</small>
		</h4>
	<div class="description"><p>エスケープ付きで文字列を置換する</p>
<p>$replacemap で from -&gt; to 文字列を指定する。<br />
to は文字列と配列を受け付ける。<br />
文字列の場合は普通に想起される動作で単純な置換となる。<br />
配列の場合は順次置換していく。要素が足りなくなったら例外を投げる。</p>
<p>strtr と同様、最も長いキーから置換を行い、置換後の文字列は対象にならない。</p>
<p>$enclosure で「特定文字に囲まれている」場合を無視することができる。<br />
$escape で「特定文字が前にある」場合を無視することができる。</p>
<p>Example:</p>
<pre><code class="language-php">// 最も単純な置換
that(str_embed('a, b, c', ['a' =&gt; 'A', 'b' =&gt; 'B', 'c' =&gt; 'C']))-&gt;isSame('A, B, C');
// 最も長いキーから置換される
that(str_embed('abc', ['a' =&gt; 'X', 'ab' =&gt; 'AB']))-&gt;isSame('ABc');
// 配列を渡すと「N番目の置換」が実現できる（文字列の場合は再利用される）
that(str_embed('a, a, b, b', [
    'a' =&gt; 'A',          // 全ての a が A になる
    'b' =&gt; ['B1', 'B2'], // 1番目の b が B1, 2番目の b が B2 になる
]))-&gt;isSame('A, A, B1, B2');
// 最も重要な性質として "' で囲まれていると対象にならない
that(str_embed('a, "a", b, "b", b', [
    'a' =&gt; 'A',
    'b' =&gt; ['B1', 'B2'],
]))-&gt;isSame('A, "a", B1, "b", B2');
</code></pre>
</div>
    	<h4 class="fqsen-title">method		<small></small>
		<a href="ryunosuke-Functions-Package-Strings$typespace.html#ryunosuke\Functions\Package\Strings::str_between()">
                                    ryunosuke\Functions\Package\Strings::str_between		</a>	<small>($string, $from, $to, &amp;$position = 0, $enclosure = &quot;&#039;\&quot;&quot;, $escape = &quot;\\&quot;) : string<span class="type-separator"></span><wbr>bool</small>
		</h4>
	<div class="description"><p>指定文字で囲まれた文字列を取得する</p>
<p>$from, $to で指定した文字間を取得する（$from, $to 自体は結果に含まれない）。<br />
ネストしている場合、一番外側の文字間を返す。</p>
<p>$enclosure で「特定文字に囲まれている」場合を無視することができる。<br />
$escape で「特定文字が前にある」場合を無視することができる。</p>
<p>$position を与えた場合、その場所から走査を開始する。<br />
さらに結果があった場合、 $position には「次の走査開始位置」が代入される。<br />
これを使用すると連続で「次の文字, 次の文字, ...」と言った動作が可能になる。</p>
<p>Example:</p>
<pre><code class="language-php">// $position を利用して "first", "second", "third" を得る（"で囲まれた "blank" は返ってこない）。
that(str_between('{first} and {second} and "{blank}" and {third}', '{', '}', $n))-&gt;isSame('first');
that(str_between('{first} and {second} and "{blank}" and {third}', '{', '}', $n))-&gt;isSame('second');
that(str_between('{first} and {second} and "{blank}" and {third}', '{', '}', $n))-&gt;isSame('third');
// ネストしている場合は最も外側を返す
that(str_between('{nest1{nest2{nest3}}}', '{', '}'))-&gt;isSame('nest1{nest2{nest3}}');
</code></pre>
</div>
    	<h4 class="fqsen-title">method		<small></small>
		<a href="ryunosuke-Functions-Package-Strings$typespace.html#ryunosuke\Functions\Package\Strings::str_ellipsis()">
                                    ryunosuke\Functions\Package\Strings::str_ellipsis		</a>	<small>($string, $width, $trimmarker = &quot;...&quot;, $pos = null) : string</small>
		</h4>
	<div class="description"><p>文字列を指定幅に丸める</p>
<p>mb_strimwidth と機能的には同じだが、省略文字の差し込み位置を $pos で指定できる。<br />
$pos は負数が指定できる。負数の場合後ろから数えられる。<br />
省略した場合は真ん中となる。</p>
<p>Example:</p>
<pre><code class="language-php">// 8文字に丸める（$pos 省略なので真ん中が省略される）
that(str_ellipsis('1234567890', 8, '...'))-&gt;isSame('12...890');
// 8文字に丸める（$pos=1 なので1文字目から省略される）
that(str_ellipsis('1234567890', 8, '...', 1))-&gt;isSame('1...7890');
// 8文字に丸める（$pos=-1 なので後ろから1文字目から省略される）
that(str_ellipsis('1234567890', 8, '...', -1))-&gt;isSame('1234...0');
</code></pre>
</div>
    	<h4 class="fqsen-title">method		<small></small>
		<a href="ryunosuke-Functions-Package-Strings$typespace.html#ryunosuke\Functions\Package\Strings::str_diff()">
                                    ryunosuke\Functions\Package\Strings::str_diff		</a>	<small>($xstring, $ystring, $options = []) : string<span class="type-separator"></span><wbr>array</small>
		</h4>
	<div class="description"><p>テキストの diff を得る</p>
<p><code>$options['iignore-case'] = true</code> で大文字小文字を無視する。<br />
<code>$options['ignore-space-change'] = true</code> 空白文字の数を無視する。<br />
<code>$options['ignore-all-space'] = true</code> ですべての空白文字を無視する<br />
<code>$options['stringify']</code> で差分データを文字列化するクロージャを指定する。</p>
<ul>
<li>normal: 標準形式（diff のオプションなしに相当する）</li>
<li>context: コンテキスト形式（context=3 のような形式で diff の -C 3 に相当する）</li>
<li>unified: ユニファイド形式（unified=3 のような形式で diff の -U 3 に相当する）<ul>
<li>unified のみを指定するとヘッダを含まない +- のみの差分を出す</li>
</ul>
</li>
<li>html: ins, del の html タグ形式<ul>
<li>html=perline とすると行レベルでの差分も出す</li>
</ul>
</li>
</ul>
<p>Example:</p>
<pre><code class="language-php">// 前文字列
$old = 'same
delete
same
same
change
';
// 後文字列
$new = 'same
same
append
same
this is changed line
';
// シンプルな差分テキストを返す
that(str_diff($old, $new))-&gt;isSame(' same
-delete
 same
+append
 same
-change
+this is changed line
');
// html で差分を返す
that(str_diff($old, $new, ['stringify' =&gt; 'html']))-&gt;isSame('same
&lt;del&gt;delete&lt;/del&gt;
same
&lt;ins&gt;append&lt;/ins&gt;
same
&lt;del&gt;change&lt;/del&gt;
&lt;ins&gt;this is changed line&lt;/ins&gt;
');
// 行レベルの html で差分を返す
that(str_diff($old, $new, ['stringify' =&gt; 'html=perline']))-&gt;isSame('same
&lt;del&gt;delete&lt;/del&gt;
same
&lt;ins&gt;append&lt;/ins&gt;
same
&lt;ins&gt;this is &lt;/ins&gt;chang&lt;ins&gt;ed lin&lt;/ins&gt;e
');
// raw な配列で差分を返す
that(str_diff($old, $new, ['stringify' =&gt; null]))-&gt;isSame([
    // 等価行（'=' という記号と前後それぞれの文字列を返す（キーは行番号））
    ['=', [0 =&gt; 'same'], [0 =&gt; 'same']],
    // 削除行（'-' という記号と前の文字列を返す（キーは行番号）、後は int で行番号のみ）
    ['-', [1 =&gt; 'delete'], 0],
    // 等価行
    ['=', [2 =&gt; 'same'], [1 =&gt; 'same']],
    // 追加行（'+' という記号と後の文字列を返す（キーは行番号）、前は int で行番号のみ）
    ['+', 2, [2 =&gt; 'append']],
    // 等価行
    ['=', [3 =&gt; 'same'], [3 =&gt; 'same']],
    // 変更行（'*' という記号と前後それぞれの文字列を返す（キーは行番号））
    ['*', [4 =&gt; 'change'], [4 =&gt; 'this is changed line']],
]);
</code></pre>
</div>
    	<h4 class="fqsen-title">method		<small></small>
		<a href="ryunosuke-Functions-Package-Strings$typespace.html#ryunosuke\Functions\Package\Strings::starts_with()">
                                    ryunosuke\Functions\Package\Strings::starts_with		</a>	<small>($string, $with, $case_insensitivity = false) : bool</small>
		</h4>
	<div class="description"><p>指定文字列で始まるか調べる</p>
<p>$with に配列を渡すといずれかで始まるときに true を返す。</p>
<p>Example:</p>
<pre><code class="language-php">that(starts_with('abcdef', 'abc'))-&gt;isTrue();
that(starts_with('abcdef', 'ABC', true))-&gt;isTrue();
that(starts_with('abcdef', 'xyz'))-&gt;isFalse();
that(starts_with('abcdef', ['a', 'b', 'c']))-&gt;isTrue();
that(starts_with('abcdef', ['x', 'y', 'z']))-&gt;isFalse();
</code></pre>
</div>
    	<h4 class="fqsen-title">method		<small></small>
		<a href="ryunosuke-Functions-Package-Strings$typespace.html#ryunosuke\Functions\Package\Strings::ends_with()">
                                    ryunosuke\Functions\Package\Strings::ends_with		</a>	<small>($string, $with, $case_insensitivity = false) : bool</small>
		</h4>
	<div class="description"><p>指定文字列で終わるか調べる</p>
<p>$with に配列を渡すといずれかで終わるときに true を返す。</p>
<p>Example:</p>
<pre><code class="language-php">that(ends_with('abcdef', 'def'))-&gt;isTrue();
that(ends_with('abcdef', 'DEF', true))-&gt;isTrue();
that(ends_with('abcdef', 'xyz'))-&gt;isFalse();
that(ends_with('abcdef', ['d', 'e', 'f']))-&gt;isTrue();
that(ends_with('abcdef', ['x', 'y', 'z']))-&gt;isFalse();
</code></pre>
</div>
    	<h4 class="fqsen-title">method		<small></small>
		<a href="ryunosuke-Functions-Package-Strings$typespace.html#ryunosuke\Functions\Package\Strings::camel_case()">
                                    ryunosuke\Functions\Package\Strings::camel_case		</a>	<small>($string, $delimiter = &quot;_&quot;) : string</small>
		</h4>
	<div class="description"><p>camelCase に変換する</p>
<p>Example:</p>
<pre><code class="language-php">that(camel_case('this_is_a_pen'))-&gt;isSame('thisIsAPen');
</code></pre>
</div>
    	<h4 class="fqsen-title">method		<small></small>
		<a href="ryunosuke-Functions-Package-Strings$typespace.html#ryunosuke\Functions\Package\Strings::pascal_case()">
                                    ryunosuke\Functions\Package\Strings::pascal_case		</a>	<small>($string, $delimiter = &quot;_&quot;) : string</small>
		</h4>
	<div class="description"><p>PascalCase に変換する</p>
<p>Example:</p>
<pre><code class="language-php">that(pascal_case('this_is_a_pen'))-&gt;isSame('ThisIsAPen');
</code></pre>
</div>
    	<h4 class="fqsen-title">method		<small></small>
		<a href="ryunosuke-Functions-Package-Strings$typespace.html#ryunosuke\Functions\Package\Strings::snake_case()">
                                    ryunosuke\Functions\Package\Strings::snake_case		</a>	<small>($string, $delimiter = &quot;_&quot;) : string</small>
		</h4>
	<div class="description"><p>snake_case に変換する</p>
<p>Example:</p>
<pre><code class="language-php">that(snake_case('ThisIsAPen'))-&gt;isSame('this_is_a_pen');
</code></pre>
</div>
    	<h4 class="fqsen-title">method		<small></small>
		<a href="ryunosuke-Functions-Package-Strings$typespace.html#ryunosuke\Functions\Package\Strings::chain_case()">
                                    ryunosuke\Functions\Package\Strings::chain_case		</a>	<small>($string, $delimiter = &quot;-&quot;) : string</small>
		</h4>
	<div class="description"><p>chain-case に変換する</p>
<p>Example:</p>
<pre><code class="language-php">that(chain_case('ThisIsAPen'))-&gt;isSame('this-is-a-pen');
</code></pre>
</div>
    	<h4 class="fqsen-title">method		<small></small>
		<a href="ryunosuke-Functions-Package-Strings$typespace.html#ryunosuke\Functions\Package\Strings::namespace_split()">
                                    ryunosuke\Functions\Package\Strings::namespace_split		</a>	<small>($string) : array</small>
		</h4>
	<div class="description"><p>文字列を名前空間とローカル名に区切ってタプルで返す</p>
<p>class_namespace/class_shorten や function_shorten とほぼ同じだが下記の違いがある。</p>
<ul>
<li>あくまで文字列として処理する<ul>
<li>例えば class_namespace は get_class されるが、この関数は（いうなれば） strval される</li>
</ul>
</li>
<li>\ を trim しないし、特別扱いもしない<ul>
<li><code>ns\\hoge</code> と <code>\\ns\\hoge</code> で返り値が微妙に異なる</li>
<li><code>ns\\</code> のような場合は名前空間だけを返す</li>
</ul>
</li>
</ul>
<p>Example:</p>
<pre><code class="language-php">that(namespace_split('ns\\hoge'))-&gt;isSame(['ns', 'hoge']);
that(namespace_split('hoge'))-&gt;isSame(['', 'hoge']);
that(namespace_split('ns\\'))-&gt;isSame(['ns', '']);
that(namespace_split('\\hoge'))-&gt;isSame(['', 'hoge']);
</code></pre>
</div>
    	<h4 class="fqsen-title">method		<small></small>
		<a href="ryunosuke-Functions-Package-Strings$typespace.html#ryunosuke\Functions\Package\Strings::html_strip()">
                                    ryunosuke\Functions\Package\Strings::html_strip		</a>	<small>($html, $options = []) : string</small>
		</h4>
	<div class="description"><p>html の空白類を除去して minify する</p>
<p>文字列的ではなく DOM 的に行うのでおかしな部分 html を食わせると意図しない結果になる可能性がある。<br />
その副作用として属性のクオートやタグ内空白は全て正規化される。</p>
<p>html コメントも削除される。<br />
また、空白が意味を持つタグ（textarea, pre）は対象にならない。<br />
さらに、php を含むような html （テンプレート）の php タグは一切の対象外となる。</p>
<p>これらの挙動の一部はオプションで指定が可能。</p>
<p>Example:</p>
<pre><code class="language-php">// e.g. id が " でクオートされている
// e.g. class のクオートが " になっている
// e.g. タグ内空白（id, class の間隔等）がスペース1つになっている
// e.g. php タグは一切変更されていない
// e.g. textarea は保持されている
that(html_strip("&lt;span  id=id  class='c1  c2  c3'&gt;&lt;?= '&lt;hoge&gt;  &lt;/hoge&gt;' ?&gt; a  b  c &lt;/span&gt; &lt;pre&gt; a  b  c &lt;/pre&gt;"))-&gt;isSame('&lt;span id="id" class="c1  c2  c3"&gt;&lt;?= \'&lt;hoge&gt;  &lt;/hoge&gt;\' ?&gt; a b c&lt;/span&gt;&lt;pre&gt; a  b  c &lt;/pre&gt;');
</code></pre>
</div>
    	<h4 class="fqsen-title">method		<small></small>
		<a href="ryunosuke-Functions-Package-Strings$typespace.html#ryunosuke\Functions\Package\Strings::htmltag()">
                                    ryunosuke\Functions\Package\Strings::htmltag		</a>	<small>($selector) : string</small>
		</h4>
	<div class="description"><p>css セレクタから html 文字列を生成する</p>
<p><code>tag#id.class[attr=value]</code> のような css セレクタから <code>&lt;tag id="id" class="class" attr="value"&gt;&lt;/tag&gt;</code> のような html 文字列を返す。<br />
配列を与えるとキーがセレクタ、値がコンテント文字列になる。<br />
さらに値が配列だと再帰して生成する。</p>
<p>値や属性は適切に htmlspecialchars される。</p>
<p>Example:</p>
<pre><code class="language-php">// 単純文字列はただのタグを生成する
that(
    htmltag('a#hoge.c1.c2[name=hoge\[\]][href="http://hoge"][hidden]'))
    -&gt;isSame('&lt;a id="hoge" class="c1 c2" name="hoge[]" href="http://hoge" hidden&gt;&lt;/a&gt;'
);
// ペア配列を与えるとコンテント文字列になる
that(
    htmltag(['a.c1#hoge.c2[name=hoge\[\]][href="http://hoge"][hidden]' =&gt; "this is text's content"]))
    -&gt;isSame('&lt;a id="hoge" class="c1 c2" name="hoge[]" href="http://hoge" hidden&gt;this is text&amp;#039;s content&lt;/a&gt;'
);
// ネストした配列を与えると再帰される
that(
    htmltag([
        'div#wrapper' =&gt; [
            'b.class1' =&gt; [
                '&lt;plain&gt;',
            ],
            'b.class2' =&gt; [
                '&lt;plain1&gt;',
                's' =&gt; '&lt;strike&gt;',
                '&lt;plain2&gt;',
            ],
        ],
    ]))
    -&gt;isSame('&lt;div id="wrapper"&gt;&lt;b class="class1"&gt;&amp;lt;plain&amp;gt;&lt;/b&gt;&lt;b class="class2"&gt;&amp;lt;plain1&amp;gt;&lt;s&gt;&amp;lt;strike&amp;gt;&lt;/s&gt;&amp;lt;plain2&amp;gt;&lt;/b&gt;&lt;/div&gt;'
);
</code></pre>
</div>
    	<h4 class="fqsen-title">method		<small></small>
		<a href="ryunosuke-Functions-Package-Strings$typespace.html#ryunosuke\Functions\Package\Strings::css_selector()">
                                    ryunosuke\Functions\Package\Strings::css_selector		</a>	<small>($selector) : array</small>
		</h4>
	<div class="description"><p>CSS セレクタ文字をパースして配列で返す</p>
<p>包含などではない属性セレクタを与えると属性として認識する。<br />
独自仕様として・・・</p>
<ul>
<li>[!attr]: 否定属性として false を返す</li>
<li>{styles}: style 属性とみなす</li>
</ul>
<p>がある。</p>
<p>Example:</p>
<pre><code class="language-php">that(css_selector('#hoge.c1.c2[name=hoge\[\]][href="http://hoge"][hidden][!readonly]{width:123px;height:456px}'))-&gt;is([
    'id'       =&gt; 'hoge',
    'class'    =&gt; ['c1', 'c2'],
    'name'     =&gt; 'hoge[]',
    'href'     =&gt; 'http://hoge',
    'hidden'   =&gt; true,
    'readonly' =&gt; false,
    'style'    =&gt; [
        'width'  =&gt; '123px',
        'height' =&gt; '456px',
    ],
]);
</code></pre>
</div>
    	<h4 class="fqsen-title">method		<small></small>
		<a href="ryunosuke-Functions-Package-Strings$typespace.html#ryunosuke\Functions\Package\Strings::build_uri()">
                                    ryunosuke\Functions\Package\Strings::build_uri		</a>	<small>($parts) : string</small>
		</h4>
	<div class="description"><p>parse_uri の逆</p>
<p>URI のパーツを与えると URI として構築する。<br />
パーツは不完全でも良い。例えば scheme を省略すると "://" すら付かない URI が生成される。</p>
<p>"query" パートだけは配列が許容される。その場合クエリ文字列に変換される。</p>
<p>Example:</p>
<pre><code class="language-php">// 完全指定
that(build_uri([
    'scheme'   =&gt; 'http',
    'user'     =&gt; 'user',
    'pass'     =&gt; 'pass',
    'host'     =&gt; 'localhost',
    'port'     =&gt; '80',
    'path'     =&gt; '/path/to/file',
    'query'    =&gt; ['id' =&gt; 1],
    'fragment' =&gt; 'hash',
]))-&gt;isSame('http://user:pass@localhost:80/path/to/file?id=1#hash');
// 一部だけ指定
that(build_uri([
    'scheme'   =&gt; 'http',
    'host'     =&gt; 'localhost',
    'path'     =&gt; '/path/to/file',
    'fragment' =&gt; 'hash',
]))-&gt;isSame('http://localhost/path/to/file#hash');
</code></pre>
</div>
    	<h4 class="fqsen-title">method		<small></small>
		<a href="ryunosuke-Functions-Package-Strings$typespace.html#ryunosuke\Functions\Package\Strings::parse_uri()">
                                    ryunosuke\Functions\Package\Strings::parse_uri		</a>	<small>($uri, $default = []) : array</small>
		</h4>
	<div class="description"><p>parse_url の仕様を少しいじったもの</p>
<p>parse_url とは下記が異なる。</p>
<ul>
<li>"単一文字列" はホスト名とみなされる（parse_url はパスとみなされる）</li>
<li>パートがなくてもキー自体は生成される（そしてその値は $default で指定したもの）</li>
<li>query は配列で返す（parse_str される）</li>
<li>パート値をスカラー値で返すことはできない（必ず8要素の配列を返す）</li>
</ul>
<p>Example:</p>
<pre><code class="language-php">// 完全指定
that(parse_uri('http://user:pass@localhost:80/path/to/file?id=1#hash'))-&gt;is([
    'scheme'   =&gt; 'http',
    'user'     =&gt; 'user',
    'pass'     =&gt; 'pass',
    'host'     =&gt; 'localhost',
    'port'     =&gt; '80',
    'path'     =&gt; '/path/to/file',
    'query'    =&gt; ['id' =&gt; 1],
    'fragment' =&gt; 'hash',
]);
// デフォルト値つき
that(parse_uri('localhost/path/to/file', [
    'scheme'   =&gt; 'http', // scheme のデフォルト値
    'user'     =&gt; 'user', // user のデフォルト値
    'port'     =&gt; '8080', // port のデフォルト値
    'host'     =&gt; 'hoge', // host のデフォルト値
]))-&gt;is([
    'scheme'   =&gt; 'http',      // scheme はないのでデフォルト値が使われている
    'user'     =&gt; 'user',      // user はないのでデフォルト値が使われている
    'pass'     =&gt; '',
    'host'     =&gt; 'localhost', // host はあるのでデフォルト値が使われていない
    'port'     =&gt; '8080',      // port はないのでデフォルト値が使われている
    'path'     =&gt; '/path/to/file',
    'query'    =&gt; [],
    'fragment' =&gt; '',
]);
</code></pre>
</div>
    	<h4 class="fqsen-title">method		<small></small>
		<a href="ryunosuke-Functions-Package-Strings$typespace.html#ryunosuke\Functions\Package\Strings::build_query()">
                                    ryunosuke\Functions\Package\Strings::build_query		</a>	<small>($data, $numeric_prefix = null, $arg_separator = null, $encoding_type = PHP_QUERY_RFC1738) : string</small>
		</h4>
	<div class="description"><p>数値キーを削除する http_build_query</p>
<p>php の世界において配列のクエリ表現は <code>var[]=1&amp;var[]=2</code> で事足りる。<br />
しかし http_build_query では数値キーでも必ず <code>var[0]=1&amp;var[1]=2</code> になる。<br />
それはそれで正しいし、他言語との連携が必要な場合はそうせざるを得ない状況もあるが、単純に php だけで配列を表したい場合は邪魔だし文字長が長くなる。<br />
この関数を使うと数値キーを削除し、<code>var[]=1&amp;var[]=2</code> のようなクエリ文字列を生成できる。</p>
<p>シグネチャは http_build_query と同じで、 $numeric_prefix に数値的文字列を与えたときのみ動作が変化する。<br />
（$numeric_prefix の意味を考えればこの引数に数値的文字列を与える意味は皆無だろうので流用している）。</p>
<ul>
<li>1 を与えると最前列を残して [] (%5B%5D) が置換される</li>
<li>2 を与えると最前列とその右を残して [] (%5B%5D) が置換される</li>
<li>要するに正数を与えると「abs(n) 個を残して [] (%5B%5D) を置換する」という指定になる</li>
<li>-1 を与えると最後尾の [] (%5B%5D) が置換される</li>
<li>-2 を与えると最後尾とその左の [] (%5B%5D) が置換される</li>
<li>要するに負数を与えると「右から abs(n) 個の [] (%5B%5D) を置換する」という指定になる</li>
</ul>
<p>この仕様は <code>v[][]=1&amp;v[][]=2</code> のようなときにおいしくないためである。<br />
これは <code>$v=[[1], [2]]</code> のような値になるが、この場合 <code>$v=[[1, 2]]</code> という値が欲しい、という事が多い。<br />
そのためには <code>v[0][]=1&amp;v[0][]=2</code> のようにする必要があるための数値指定である。</p>
</div>
    	<h4 class="fqsen-title">method		<small></small>
		<a href="ryunosuke-Functions-Package-Strings$typespace.html#ryunosuke\Functions\Package\Strings::parse_query()">
                                    ryunosuke\Functions\Package\Strings::parse_query		</a>	<small>($query) : array</small>
		</h4>
	<div class="description"><p>parse_str の返り値版</p>
<p>標準の parse_str は参照で受ける謎シグネチャなのでそれを返り値に変更したもの。</p>
</div>
    	<h4 class="fqsen-title">method		<small></small>
		<a href="ryunosuke-Functions-Package-Strings$typespace.html#ryunosuke\Functions\Package\Strings::ini_export()">
                                    ryunosuke\Functions\Package\Strings::ini_export		</a>	<small>($iniarray, $options = []) : string</small>
		</h4>
	<div class="description"><p>連想配列を INI 的文字列に変換する</p>
<p>Example:</p>
<pre><code class="language-php">that(ini_export(['a' =&gt; 1, 'b' =&gt; 'B', 'c' =&gt; PHP_SAPI]))-&gt;is('a = 1
b = "B"
c = "cli"
');
</code></pre>
</div>
    	<h4 class="fqsen-title">method		<small></small>
		<a href="ryunosuke-Functions-Package-Strings$typespace.html#ryunosuke\Functions\Package\Strings::ini_import()">
                                    ryunosuke\Functions\Package\Strings::ini_import		</a>	<small>($inistring, $options = []) : array</small>
		</h4>
	<div class="description"><p>INI 的文字列を連想配列に変換する</p>
<p>Example:</p>
<pre><code class="language-php">that(ini_import("
a = 1
b = 'B'
c = PHP_VERSION
"))-&gt;is(['a' =&gt; 1, 'b' =&gt; 'B', 'c' =&gt; PHP_VERSION]);
</code></pre>
</div>
    	<h4 class="fqsen-title">method		<small></small>
		<a href="ryunosuke-Functions-Package-Strings$typespace.html#ryunosuke\Functions\Package\Strings::csv_export()">
                                    ryunosuke\Functions\Package\Strings::csv_export		</a>	<small>($csvarrays, $options = []) : string<span class="type-separator"></span><wbr>int</small>
		</h4>
	<div class="description"><p>連想配列の配列を CSV 的文字列に変換する</p>
<p>CSV ヘッダ行は全連想配列のキーの共通項となる。<br />
順番には依存しないが、余計な要素があってもそのキーはヘッダには追加されないし、データ行にも含まれない。<br />
ただし、オプションで headers が与えられた場合はそれを使用する。<br />
この headers オプションに連想配列を与えるとヘッダ文字列変換になる（[key =&gt; header] で「key を header で吐き出し」となる）。<br />
数値配列を与えると単純に順序指定での出力指定になるが、ヘッダ行が出力されなくなる。</p>
<p>callback オプションが渡された場合は「あらゆる処理の最初」にコールされる。<br />
つまりヘッダの読み換えや文字エンコーディングの変換が行われる前の状態でコールされる。<br />
また、 false を返すとその要素はスルーされる。</p>
<p>output オプションにリソースを渡すとそこに対して書き込みが行われる（fclose はされない）。</p>
<p>Example:</p>
<pre><code class="language-php">// シンプルな実行例
$csvarrays = [
    ['a' =&gt; 'A1', 'b' =&gt; 'B1', 'c' =&gt; 'C1'],             // 普通の行
    ['c' =&gt; 'C2', 'a' =&gt; 'A2', 'b' =&gt; 'B2'],             // 順番が入れ替わっている行
    ['c' =&gt; 'C3', 'a' =&gt; 'A3', 'b' =&gt; 'B3', 'x' =&gt; 'X'], // 余計な要素が入っている行
];
that(csv_export($csvarrays))-&gt;is("a,b,c
A1,B1,C1
A2,B2,C2
A3,B3,C3
");

// ヘッダを指定できる
that(csv_export($csvarrays, [
    'headers' =&gt; ['a' =&gt; 'A', 'c' =&gt; 'C'], // a と c だけを出力＋ヘッダ文字変更
]))-&gt;is("A,C
A1,C1
A2,C2
A3,C3
");

// ヘッダ行を出さない
that(csv_export($csvarrays, [
    'headers' =&gt; ['a', 'c'], // a と c だけを出力＋ヘッダ行なし
]))-&gt;is("A1,C1
A2,C2
A3,C3
");
</code></pre>
</div>
    	<h4 class="fqsen-title">method		<small></small>
		<a href="ryunosuke-Functions-Package-Strings$typespace.html#ryunosuke\Functions\Package\Strings::csv_import()">
                                    ryunosuke\Functions\Package\Strings::csv_import		</a>	<small>($csvstring, $options = []) : array</small>
		</h4>
	<div class="description"><p>CSV 的文字列を連想配列の配列に変換する</p>
<p>1行目をヘッダ文字列とみなしてそれをキーとした連想配列の配列を返す。<br />
ただし、オプションで headers が与えられた場合はそれを使用する。<br />
この headers オプションはヘッダフィルタも兼ねる（[n =&gt; header] で「n 番目フィールドを header で取り込み」となる）。<br />
入力にヘッダがありかつ headers に連想配列が渡された場合はフィルタ兼読み換えとなる（Example を参照）。</p>
<p>callback オプションが渡された場合は「あらゆる処理の最後」にコールされる。<br />
つまりヘッダの読み換えや文字エンコーディングの変換が行われた後の状態でコールされる。<br />
また、 false を返すとその要素はスルーされる。</p>
<p>メモリ効率は意識しない（どうせ配列を返すので意識しても無駄）。</p>
<p>Example:</p>
<pre><code class="language-php">// シンプルな実行例
that(csv_import("
a,b,c
A1,B1,C1
A2,B2,C2
A3,B3,C3
"))-&gt;is([
    ['a' =&gt; 'A1', 'b' =&gt; 'B1', 'c' =&gt; 'C1'],
    ['a' =&gt; 'A2', 'b' =&gt; 'B2', 'c' =&gt; 'C2'],
    ['a' =&gt; 'A3', 'b' =&gt; 'B3', 'c' =&gt; 'C3'],
]);

// ヘッダを指定できる
that(csv_import("
A1,B1,C1
A2,B2,C2
A3,B3,C3
", [
    'headers' =&gt; [0 =&gt; 'a', 2 =&gt; 'c'], // 1がないので1番目のフィールドを読み飛ばしつつ、0, 2 は "a", "c" として取り込む
]))-&gt;is([
    ['a' =&gt; 'A1', 'c' =&gt; 'C1'],
    ['a' =&gt; 'A2', 'c' =&gt; 'C2'],
    ['a' =&gt; 'A3', 'c' =&gt; 'C3'],
]);

// ヘッダありで連想配列で指定するとキーの読み換えとなる（指定しなければ読み飛ばしも行える）
that(csv_import("
a,b,c
A1,B1,C1
A2,B2,C2
A3,B3,C3
", [
    'headers' =&gt; ['a' =&gt; 'hoge', 'c' =&gt; 'piyo'], // a は hoge, c は piyo で読み込む。 b は指定がないので飛ばされる
]))-&gt;is([
    ['hoge' =&gt; 'A1', 'piyo' =&gt; 'C1'],
    ['hoge' =&gt; 'A2', 'piyo' =&gt; 'C2'],
    ['hoge' =&gt; 'A3', 'piyo' =&gt; 'C3'],
]);
</code></pre>
</div>
    	<h4 class="fqsen-title">method		<small></small>
		<a href="ryunosuke-Functions-Package-Strings$typespace.html#ryunosuke\Functions\Package\Strings::json_export()">
                                    ryunosuke\Functions\Package\Strings::json_export		</a>	<small>($value, $options = []) : string</small>
		</h4>
	<div class="description"><p>json_encode のプロキシ関数</p>
<p>引数体系とデフォルト値を変更してある。また、エラー時に例外が飛ぶ。</p>
<p>Example:</p>
<pre><code class="language-php">// オプションはこのように [定数 =&gt; bool] で渡す。false は指定されていないとみなされる（JSON_MAX_DEPTH 以外）
that(json_export(['a' =&gt; 'A', 'b' =&gt; 'B'], [
   JSON_PRETTY_PRINT =&gt; false,
]))-&gt;is('{"a":"A","b":"B"}');
</code></pre>
</div>
    	<h4 class="fqsen-title">method		<small></small>
		<a href="ryunosuke-Functions-Package-Strings$typespace.html#ryunosuke\Functions\Package\Strings::json_import()">
                                    ryunosuke\Functions\Package\Strings::json_import		</a>	<small>($value, $options = []) : mixed</small>
		</h4>
	<div class="description"><p>json_decode のプロキシ関数</p>
<p>引数体系とデフォルト値を変更してある。また、エラー時に例外が飛ぶ。</p>
<p>JSON_ES5 に null か true を渡すと json5 としてでデコードする（null はまず json_decode で試みる、true は json5 のみ）。<br />
その場合拡張オプションとして下記がある。</p>
<ul>
<li>JSON_INT_AS_STRING: 常に整数を文字列で返す</li>
<li>JSON_FLOAT_AS_STRING: 常に小数を文字列で返す</li>
</ul>
<p>Example:</p>
<pre><code class="language-php">// オプションはこのように [定数 =&gt; bool] で渡す。false は指定されていないとみなされる（JSON_MAX_DEPTH 以外）
that(json_import('{"a":"A","b":"B"}', [
   JSON_OBJECT_AS_ARRAY =&gt; true,
]))-&gt;is(['a' =&gt; 'A', 'b' =&gt; 'B']);

// json5 が使える
that(json_import('{a: "A", b: "B", }'))-&gt;is(['a' =&gt; 'A', 'b' =&gt; 'B']);
</code></pre>
</div>
    	<h4 class="fqsen-title">method		<small></small>
		<a href="ryunosuke-Functions-Package-Strings$typespace.html#ryunosuke\Functions\Package\Strings::paml_export()">
                                    ryunosuke\Functions\Package\Strings::paml_export		</a>	<small>($pamlarray, $options = []) : string</small>
		</h4>
	<div class="description"><p>連想配列を paml 的文字列に変換する</p>
<p>paml で出力することはまずないのでおまけ（import との対称性のために定義している）。</p>
<p>Example:</p>
<pre><code class="language-php">that(paml_export([
    'n' =&gt; null,
    'f' =&gt; false,
    'i' =&gt; 123,
    'd' =&gt; 3.14,
    's' =&gt; 'this is string',
]))-&gt;isSame('n: null, f: false, i: 123, d: 3.14, s: "this is string"');
</code></pre>
</div>
    	<h4 class="fqsen-title">method		<small></small>
		<a href="ryunosuke-Functions-Package-Strings$typespace.html#ryunosuke\Functions\Package\Strings::paml_import()">
                                    ryunosuke\Functions\Package\Strings::paml_import		</a>	<small>($pamlstring, $options = []) : array</small>
		</h4>
	<div class="description"><p>paml 的文字列をパースする</p>
<p>paml とは yaml を簡易化したような独自フォーマットを指す（Php Array Markup Language）。<br />
ざっくりと下記のような特徴がある。</p>
<ul>
<li>ほとんど yaml と同じだがフロースタイルのみでキーコロンの後のスペースは不要</li>
<li>yaml のアンカーや複数ドキュメントのようなややこしい仕様はすべて未対応</li>
<li>配列を前提にしているので、トップレベルの <code>[]</code> <code>{}</code> は不要</li>
<li><code>[]</code> でいわゆる php の配列、 <code>{}</code> で stdClass を表す（オプション指定可能）</li>
<li>bare string で php の定数を表す（クラス定数も完全修飾すれば使用可能）</li>
</ul>
<p>簡易的な設定の注入に使える（yaml は標準で対応していないし、json や php 配列はクオートの必要やケツカンマ問題がある）。<br />
なお、かなり緩くパースしてるので基本的にエラーにはならない。</p>
<p>早見表：</p>
<ul>
<li>php:  <code>["n" =&gt; null, "f" =&gt; false, "i" =&gt; 123, "d" =&gt; 3.14, "s" =&gt; "this is string", "a" =&gt; [1, 2, "x" =&gt; "X"]]</code><ul>
<li>ダブルアローとキーのクオートが冗長</li>
</ul>
</li>
<li>json: <code>{"n":null, "f":false, "i":123, "d":3.14, "s":"this is string", "a":{"0": 1, "1": 2, "x": "X"}}</code><ul>
<li>キーのクオートが冗長だしケツカンマ非許容</li>
</ul>
</li>
<li>yaml: <code>{n: null, f: false, i: 123, d: 3.14, s: "this is string", a: {0: 1, 1: 2, x: X}}</code><ul>
<li>理想に近いが、コロンの後にスペースが必要だし連想配列が少々難。なにより拡張や外部ライブラリが必要</li>
</ul>
</li>
<li>paml: <code>n:null, f:false, i:123, d:3.14, s:"this is string", a:[1, 2, x:X]</code><ul>
<li>シンプルイズベスト</li>
</ul>
</li>
</ul>
<p>Example:</p>
<pre><code class="language-php">// こういったスカラー型はほとんど yaml と一緒だが、コロンの後のスペースは不要（あってもよい）
that(paml_import('n:null, f:false, i:123, d:3.14, s:"this is string"'))-&gt;isSame([
    'n' =&gt; null,
    'f' =&gt; false,
    'i' =&gt; 123,
    'd' =&gt; 3.14,
    's' =&gt; 'this is string',
]);
// 配列が使える（キーは連番なら不要）。ネストも可能
that(paml_import('a:[1,2,x:X,3], nest:[a:[b:[c:[X]]]]'))-&gt;isSame([
    'a'    =&gt; [1, 2, 'x' =&gt; 'X', 3],
    'nest' =&gt; [
        'a' =&gt; [
            'b' =&gt; [
                'c' =&gt; ['X']
            ],
        ],
    ],
]);
// bare 文字列で定数が使える。::class も特別扱いで定数とみなす
that(paml_import('pv:PHP_VERSION, ao:ArrayObject::STD_PROP_LIST, class:ArrayObject::class'))-&gt;isSame([
    'pv'    =&gt; \PHP_VERSION,
    'ao'    =&gt; \ArrayObject::STD_PROP_LIST,
    'class' =&gt; \ArrayObject::class,
]);
</code></pre>
</div>
    	<h4 class="fqsen-title">method		<small></small>
		<a href="ryunosuke-Functions-Package-Strings$typespace.html#ryunosuke\Functions\Package\Strings::ltsv_export()">
                                    ryunosuke\Functions\Package\Strings::ltsv_export		</a>	<small>($ltsvarray, $options = []) : string</small>
		</h4>
	<div class="description"><p>配列を LTSV 的文字列に変換する</p>
<p>ラベル文字列に ":" を含む場合は例外を投げる（ラベルにコロンが来るとどうしようもない）。</p>
<p>escape オプションで「LTSV 的にまずい文字」がその文字でエスケープされる（具体的には "\n" と "\t"）。<br />
デフォルトでは "\" でエスケープされるので、整合性が崩れることはない。</p>
<p>encode オプションで「文字列化できない値」が来たときのその関数を通して出力される（その場合、目印として値の両サイドに ` が付く）。<br />
デフォルトでは json_encode される。</p>
<p>エンコード機能はおまけに過ぎない（大抵の場合はそんな機能は必要ない）。<br />
ので、この実装は互換性を維持せず変更される可能性がある。</p>
<p>Example:</p>
<pre><code class="language-php">// シンプルな実行例
that(ltsv_export([
    "label1" =&gt; "value1",
    "label2" =&gt; "value2",
]))-&gt;is("label1:value1	label2:value2");

// タブや改行文字のエスケープ
that(ltsv_export([
    "label1" =&gt; "val\tue1",
    "label2" =&gt; "val\nue2",
]))-&gt;is("label1:val\\tue1	label2:val\\nue2");

// 配列のエンコード
that(ltsv_export([
    "label1" =&gt; "value1",
    "label2" =&gt; [1, 2, 3],
]))-&gt;is("label1:value1	label2:`[1,2,3]`");
</code></pre>
</div>
    	<h4 class="fqsen-title">method		<small></small>
		<a href="ryunosuke-Functions-Package-Strings$typespace.html#ryunosuke\Functions\Package\Strings::ltsv_import()">
                                    ryunosuke\Functions\Package\Strings::ltsv_import		</a>	<small>($ltsvstring, $options = []) : array</small>
		</h4>
	<div class="description"><p>LTSV 的文字列を配列に変換する</p>
<p>escape オプションで「LTSV 的にまずい文字」がその文字でエスケープされる（具体的には "\n" と "\t"）。<br />
デフォルトでは "\" でエスケープされるので、整合性が崩れることはない。</p>
<p>decode オプションで「`` で囲まれた値」が来たときのその関数を通して出力される。<br />
デフォルトでは json_decode される。</p>
<p>エンコード機能はおまけに過ぎない（大抵の場合はそんな機能は必要ない）。<br />
ので、この実装は互換性を維持せず変更される可能性がある。</p>
<p>Example:</p>
<pre><code class="language-php">// シンプルな実行例
that(ltsv_import("label1:value1	label2:value2"))-&gt;is([
    "label1" =&gt; "value1",
    "label2" =&gt; "value2",
]);

// タブや改行文字のエスケープ
that(ltsv_import("label1:val\\tue1	label2:val\\nue2"))-&gt;is([
    "label1" =&gt; "val\tue1",
    "label2" =&gt; "val\nue2",
]);

// 配列のデコード
that(ltsv_import("label1:value1	label2:`[1,2,3]`"))-&gt;is([
    "label1" =&gt; "value1",
    "label2" =&gt; [1, 2, 3],
]);
</code></pre>
</div>
    	<h4 class="fqsen-title">method		<small></small>
		<a href="ryunosuke-Functions-Package-Strings$typespace.html#ryunosuke\Functions\Package\Strings::markdown_table()">
                                    ryunosuke\Functions\Package\Strings::markdown_table		</a>	<small>($array) : string</small>
		</h4>
	<div class="description"><p>連想配列の配列を markdown テーブル文字列にする</p>
<p>見出しはキーの和集合で生成され、改行は <code>&lt;br&gt;</code> に置換される。<br />
要素が全て数値の場合は右寄せになる。</p>
<p>Example:</p>
<pre><code class="language-php">// 最初の "\n" に意味はない（ズレると見づらいので冒頭に足しているだけ）
that("\n" . markdown_table([
   ['a' =&gt; 'a1', 'b' =&gt; 'b1'],
   ['b' =&gt; 'b2', 'c' =&gt; '2'],
   ['a' =&gt; 'a3', 'c' =&gt; '3'],
]))-&gt;is("
| a   | b   |   c |
| --- | --- | --: |
| a1  | b1  |     |
|     | b2  |   2 |
| a3  |     |   3 |
");
</code></pre>
</div>
    	<h4 class="fqsen-title">method		<small></small>
		<a href="ryunosuke-Functions-Package-Strings$typespace.html#ryunosuke\Functions\Package\Strings::markdown_list()">
                                    ryunosuke\Functions\Package\Strings::markdown_list		</a>	<small>($array, $option = []) : string</small>
		</h4>
	<div class="description"><p>配列を markdown リスト文字列にする</p>
<p>Example:</p>
<pre><code class="language-php">// 最初の "\n" に意味はない（ズレると見づらいので冒頭に足しているだけ）
that("\n" . markdown_list([
    'dict'        =&gt; [
        'Key1' =&gt; 'Value1',
        'Key2' =&gt; 'Value2',
    ],
    'list'        =&gt; ['Item1', 'Item2', 'Item3'],
    'dict &amp; list' =&gt; [
        'Key' =&gt; 'Value',
        ['Item1', 'Item2', 'Item3'],
    ],
], ['separator' =&gt; ':']))-&gt;is("
- dict:
    - Key1:Value1
    - Key2:Value2
- list:
    - Item1
    - Item2
    - Item3
- dict &amp; list:
    - Key:Value
        - Item1
        - Item2
        - Item3
");
</code></pre>
</div>
    	<h4 class="fqsen-title">method		<small></small>
		<a href="ryunosuke-Functions-Package-Strings$typespace.html#ryunosuke\Functions\Package\Strings::random_string()">
                                    ryunosuke\Functions\Package\Strings::random_string		</a>	<small>($length = 8, $charlist = &quot;0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ&quot;) : string</small>
		</h4>
	<div class="description"><p>安全な乱数文字列を生成する</p>
</div>
    	<h4 class="fqsen-title">method		<small></small>
		<a href="ryunosuke-Functions-Package-Strings$typespace.html#ryunosuke\Functions\Package\Strings::unique_string()">
                                    ryunosuke\Functions\Package\Strings::unique_string		</a>	<small>($source, $initial = null, $charlist = &quot;0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ&quot;) : string</small>
		</h4>
	<div class="description"><p>文字列に含まれない文字列を生成する</p>
<p>例えば http のマルチパートバウンダリのような、「競合しない文字列」を生成する。<br />
実装は愚直に文字列を調べて存在しなければそれを返すようになっている。<br />
一応初期値や文字セットは指定可能。</p>
<p>$initial に int を与えると初期値としてその文字数分 $charlist から確保する。<br />
例えば生成後の変更が前提で、ある程度の長さを担保したいときに指定すれば最低でもその長さ以上は保証される。<br />
$initial に string を与えるとそれがそのまま初期値として使用される。<br />
例えば「ほぼ存在しない文字列」が予測できるのであればそれを指定すれば無駄な処理が省ける。</p>
<p>Example:</p>
<pre><code class="language-php">// 単純に呼ぶと生成1,2文字程度の文字列になる
that(unique_string('hello, world'))-&gt;stringLengthEqualsAny([1, 2]);
// 数値を含んでいないので候補文字に数値のみを指定すれば1文字で「存在しない文字列」となる
that(unique_string('hello, world', null, range(0, 9)))-&gt;stringLengthEquals(1);
// int を渡すと最低でもそれ以上は保証される
that(unique_string('hello, world', 5))-&gt;stringLengthEqualsAny([5, 6]);
// string を渡すとそれが初期値となる
that(unique_string('hello, world', 'prefix-'))-&gt;stringStartsWith('prefix');
</code></pre>
</div>
    	<h4 class="fqsen-title">method		<small></small>
		<a href="ryunosuke-Functions-Package-Strings$typespace.html#ryunosuke\Functions\Package\Strings::kvsprintf()">
                                    ryunosuke\Functions\Package\Strings::kvsprintf		</a>	<small>($format, $array) : string</small>
		</h4>
	<div class="description"><p>連想配列を指定できるようにした vsprintf</p>
<p>sprintf の順序指定構文('%1$d')にキーを指定できる。</p>
<p>Example:</p>
<pre><code class="language-php">that(kvsprintf('%hoge$s %fuga$d', ['hoge' =&gt; 'ThisIs', 'fuga' =&gt; '3.14']))-&gt;isSame('ThisIs 3');
</code></pre>
</div>
    	<h4 class="fqsen-title">method		<small></small>
		<a href="ryunosuke-Functions-Package-Strings$typespace.html#ryunosuke\Functions\Package\Strings::preg_matches()">
                                    ryunosuke\Functions\Package\Strings::preg_matches		</a>	<small>($pattern, $subject, $flags = 0, $offset = 0) : array</small>
		</h4>
	<div class="description"><p>複数マッチに対応した preg_match</p>
<p>要するに preg_match_all とほぼ同義だが、下記の差異がある。</p>
<ul>
<li>正規表現フラグに "g" フラグが使用できる。 "g" を指定すると preg_match_all 相当の動作になる</li>
<li>キャプチャは参照引数ではなく返り値で返す</li>
<li>「パターン全体マッチ」を表す 0 キーは返さない</li>
<li>上記2つの動作により「マッチしなかったら空配列を返す」という動作になる</li>
<li>名前付きキャプチャーに対応する数値キーは伏せられる</li>
<li>伏せられても数値キーは 0 ベースで通し連番となる</li>
</ul>
<p>Example:</p>
<pre><code class="language-php">$pattern = '#(\d{4})/(?&lt;month&gt;\d{1,2})(?:/(\d{1,2}))?#';
// 1(month)番目は名前付きキャプチャなので 1 キーとしては含まれず month というキーで返す（2 が詰められて 1 になる）
that(preg_matches($pattern, '2014/12/24'))-&gt;isSame([0 =&gt; '2014', 'month' =&gt; '12', 1 =&gt; '24']);
// 一切マッチしなければ空配列が返る
that(preg_matches($pattern, 'hoge'))-&gt;isSame([]);

// g オプションを与えると preg_match_all 相当の動作になる（flags も使える）
$pattern = '#(\d{4})/(?&lt;month&gt;\d{1,2})(?:/(\d{1,2}))?#g';
that(preg_matches($pattern, '2013/11/23, 2014/12/24', PREG_SET_ORDER))-&gt;isSame([
    [0 =&gt; '2013', 'month' =&gt; '11', 1 =&gt; '23'],
    [0 =&gt; '2014', 'month' =&gt; '12', 1 =&gt; '24'],
]);
</code></pre>
</div>
    	<h4 class="fqsen-title">method		<small></small>
		<a href="ryunosuke-Functions-Package-Strings$typespace.html#ryunosuke\Functions\Package\Strings::preg_capture()">
                                    ryunosuke\Functions\Package\Strings::preg_capture		</a>	<small>($pattern, $subject, $default) : array</small>
		</h4>
	<div class="description"><p>キャプチャを主軸においた preg_match</p>
<p>$pattern で $subject をマッチングして $default で埋めて返す。$default はフィルタも兼ねる。<br />
空文字マッチは「マッチしていない」とみなすので注意（$default が使用される）。</p>
<p>キャプチャを主軸においているので「マッチしなかった」は検出不可能。<br />
$default がそのまま返ってくる。</p>
<p>Example:</p>
<pre><code class="language-php">$pattern = '#(\d{4})/(\d{1,2})(/(\d{1,2}))?#';
$default = [1 =&gt; '2000', 2 =&gt; '1', 4 =&gt; '1'];
// 完全にマッチするのでそれぞれ返ってくる
that(preg_capture($pattern, '2014/12/24', $default))-&gt;isSame([1 =&gt; '2014', 2 =&gt; '12', 4 =&gt; '24']);
// 最後の \d{1,2} はマッチしないのでデフォルト値が使われる
that(preg_capture($pattern, '2014/12', $default))-&gt;isSame([1 =&gt; '2014', 2 =&gt; '12', 4 =&gt; '1']);
// 一切マッチしないので全てデフォルト値が使われる
that(preg_capture($pattern, 'hoge', $default))-&gt;isSame([1 =&gt; '2000', 2 =&gt; '1', 4 =&gt; '1']);
</code></pre>
</div>
    	<h4 class="fqsen-title">method		<small></small>
		<a href="ryunosuke-Functions-Package-Strings$typespace.html#ryunosuke\Functions\Package\Strings::preg_splice()">
                                    ryunosuke\Functions\Package\Strings::preg_splice		</a>	<small>($pattern, $replacement, $subject, &amp;$matches = []) : string</small>
		</h4>
	<div class="description"><p>キャプチャも行える preg_replace</p>
<p>「置換を行いつつ、キャプチャ文字列が欲しい」状況はまれによくあるはず。</p>
<p>$replacement に callable を渡すと preg_replace_callback がコールされる。<br />
callable とはいっても単純文字列 callble （"strtoupper" など）は callable とはみなされない。<br />
配列形式の callable や クロージャのみ preg_replace_callback になる。</p>
<p>Example:</p>
<pre><code class="language-php">// 数字を除去しつつその除去された数字を得る
that(preg_splice('#\\d+#', '', 'abc123', $m))-&gt;isSame('abc');
that($m)-&gt;isSame(['123']);

// callable だと preg_replace_callback が呼ばれる
that(preg_splice('#[a-z]+#', function($m){return strtoupper($m[0]);}, 'abc123', $m))-&gt;isSame('ABC123');
that($m)-&gt;isSame(['abc']);

// ただし、 文字列 callable は文字列として扱う
that(preg_splice('#[a-z]+#', 'strtoupper', 'abc123', $m))-&gt;isSame('strtoupper123');
that($m)-&gt;isSame(['abc']);
</code></pre>
</div>
    	<h4 class="fqsen-title">method		<small></small>
		<a href="ryunosuke-Functions-Package-Strings$typespace.html#ryunosuke\Functions\Package\Strings::preg_replaces()">
                                    ryunosuke\Functions\Package\Strings::preg_replaces		</a>	<small>($pattern, $replacements, $subject, $limit = -1, &amp;$count = null) : string</small>
		</h4>
	<div class="description"><p>パターン番号を指定して preg_replace する</p>
<p>パターン番号を指定してそれのみを置換する。<br />
名前付きキャプチャを使用している場合はキーに文字列も使える。<br />
値にクロージャを渡した場合はコールバックされて置換される。</p>
<p>$replacements に単一文字列を渡した場合、 <code>[1 =&gt; $replacements]</code> と等しくなる（第1キャプチャを置換）。</p>
<p>Example:</p>
<pre><code class="language-php">// a と z に囲まれた数字を XXX に置換する
that(preg_replaces('#a(\d+)z#', [1 =&gt; 'XXX'], 'a123z'))-&gt;isSame('aXXXz');
// 名前付きキャプチャも指定できる
that(preg_replaces('#a(?&lt;digit&gt;\d+)z#', ['digit' =&gt; 'XXX'], 'a123z'))-&gt;isSame('aXXXz');
// クロージャを渡すと元文字列を引数としてコールバックされる
that(preg_replaces('#a(?&lt;digit&gt;\d+)z#', ['digit' =&gt; function($src){return $src * 2;}], 'a123z'))-&gt;isSame('a246z');
// 複合的なサンプル（a タグの href と target 属性を書き換える）
that(preg_replaces('#&lt;a\s+href="(?&lt;href&gt;.*)"\s+target="(?&lt;target&gt;.*)"&gt;#', [
    'href'   =&gt; function($href){return strtoupper($href);},
    'target' =&gt; function($target){return strtoupper($target);},
], '&lt;a href="hoge" target="fuga"&gt;inner text&lt;/a&gt;'))-&gt;isSame('&lt;a href="HOGE" target="FUGA"&gt;inner text&lt;/a&gt;');
</code></pre>
</div>
    	<h4 class="fqsen-title">method		<small></small>
		<a href="ryunosuke-Functions-Package-Strings$typespace.html#ryunosuke\Functions\Package\Strings::damerau_levenshtein()">
                                    ryunosuke\Functions\Package\Strings::damerau_levenshtein		</a>	<small>($s1, $s2, $cost_ins = 1, $cost_rep = 1, $cost_del = 1, $cost_swp = 1) : int</small>
		</h4>
	<div class="description"><p>Damerau–Levenshtein 距離を返す</p>
<p>簡単に言えば「転置（入れ替え）を考慮したレーベンシュタイン」である。<br />
例えば "destroy" と "destory" は 「1挿入1削除=2」であるが、Damerau 版だと「1転置=1」となる。</p>
<p>また、マルチバイト（UTF-8 のみ）にも対応している。</p>
<p>Example:</p>
<pre><code class="language-php">// destroy と destory は普通にレーベンシュタイン距離を取ると 2 になるが・・・
that(levenshtein("destroy", "destory"))-&gt;isSame(2);
// damerau_levenshtein だと1である
that(damerau_levenshtein("destroy", "destory"))-&gt;isSame(1);
// UTF-8 でも大丈夫
that(damerau_levenshtein("あいうえお", "あいえうお"))-&gt;isSame(1);
</code></pre>
</div>
    	<h4 class="fqsen-title">method		<small></small>
		<a href="ryunosuke-Functions-Package-Strings$typespace.html#ryunosuke\Functions\Package\Strings::ngram()">
                                    ryunosuke\Functions\Package\Strings::ngram		</a>	<small>($string, $N, $encoding = &quot;UTF-8&quot;) : array</small>
		</h4>
	<div class="description"><p>N-gram 化して配列で返す</p>
<p>素朴な実装であり特記事項はない。<br />
末端要素や除去フィルタくらいは実装するかもしれない。</p>
<p>Example:</p>
<pre><code class="language-php">that(ngram("あいうえお", 1))-&gt;isSame(["あ", "い", "う", "え", "お"]);
that(ngram("あいうえお", 2))-&gt;isSame(["あい", "いう", "うえ", "えお", "お"]);
that(ngram("あいうえお", 3))-&gt;isSame(["あいう", "いうえ", "うえお", "えお", "お"]);
</code></pre>
</div>
    	<h4 class="fqsen-title">method		<small></small>
		<a href="ryunosuke-Functions-Package-Strings$typespace.html#ryunosuke\Functions\Package\Strings::str_guess()">
                                    ryunosuke\Functions\Package\Strings::str_guess		</a>	<small>($string, $candidates, &amp;$percent = null) : string<span class="type-separator"></span><wbr>array</small>
		</h4>
	<div class="description"><p>$string に最も近い文字列を返す</p>
<p>N-gram 化して類似度の高い結果を返す。<br />
$percent で一致度を受けられる。<br />
予め値が入った変数を渡すとその一致度以上の候補を高い順で配列で返す。</p>
<p>この関数の結果（内部実装）は互換性を考慮しない。</p>
<p>Example:</p>
<pre><code class="language-php">// 「あいうえお」と最も近い文字列は「あいゆえに」である
that(str_guess("あいうえお", [
    'かきくけこ', // マッチ度 0%（1文字もかすらない）
    'ぎぼあいこ', // マッチ度約 13.1%（"あい"はあるが位置が異なる）
    'あいしてる', // マッチ度約 13.8%（"あい"がマッチ）
    'かとうあい', // マッチ度約 16.7%（"あい"があり"う"の位置が等しい）
    'あいゆえに', // マッチ度約 17.4%（"あい", "え"がマッチ）
]))-&gt;isSame('あいゆえに');

// マッチ度30%以上を高い順に配列で返す
$percent = 30;
that(str_guess("destory", [
    'describe',
    'destroy',
    'destruct',
    'destiny',
    'destinate',
], $percent))-&gt;isSame([
    'destroy',
    'destiny',
    'destruct',
]);
</code></pre>
</div>
    	<h4 class="fqsen-title">method		<small></small>
		<a href="ryunosuke-Functions-Package-Strings$typespace.html#ryunosuke\Functions\Package\Strings::str_array()">
                                    ryunosuke\Functions\Package\Strings::str_array		</a>	<small>($string, $delimiter, $hashmode) : array</small>
		</h4>
	<div class="description"><p>文字列を区切り文字で区切って配列に変換する</p>
<p>典型的には http ヘッダとか sar の結果とかを配列にする。</p>
<p>Example:</p>
<pre><code class="language-php">// http response header  を ":" 区切りで連想配列にする
that(str_array("
HTTP/1.1 200 OK
Content-Type: text/html; charset=utf-8
Connection: Keep-Alive
", ':', true))-&gt;isSame([
    'HTTP/1.1 200 OK',
    'Content-Type' =&gt; 'text/html; charset=utf-8',
    'Connection'   =&gt; 'Keep-Alive',
]);

// sar の結果を " " 区切りで連想配列の配列にする
that(str_array("
13:00:01        CPU     %user     %nice   %system   %iowait    %steal     %idle
13:10:01        all      0.99      0.10      0.71      0.00      0.00     98.19
13:20:01        all      0.60      0.10      0.56      0.00      0.00     98.74
", ' ', false))-&gt;isSame([
    1 =&gt; [
        '13:00:01' =&gt; '13:10:01',
        'CPU'      =&gt; 'all',
        '%user'    =&gt; '0.99',
        '%nice'    =&gt; '0.10',
        '%system'  =&gt; '0.71',
        '%iowait'  =&gt; '0.00',
        '%steal'   =&gt; '0.00',
        '%idle'    =&gt; '98.19',
    ],
    2 =&gt; [
        '13:00:01' =&gt; '13:20:01',
        'CPU'      =&gt; 'all',
        '%user'    =&gt; '0.60',
        '%nice'    =&gt; '0.10',
        '%system'  =&gt; '0.56',
        '%iowait'  =&gt; '0.00',
        '%steal'   =&gt; '0.00',
        '%idle'    =&gt; '98.74',
    ],
]);
</code></pre>
</div>
    	<h4 class="fqsen-title">method		<small></small>
		<a href="ryunosuke-Functions-Package-Strings$typespace.html#ryunosuke\Functions\Package\Strings::mb_substr_replace()">
                                    ryunosuke\Functions\Package\Strings::mb_substr_replace		</a>	<small>($string, $replacement, $start, $length = null) : string</small>
		</h4>
	<div class="description"><p>マルチバイト対応 substr_replace</p>
<p>本家は配列を与えたりできるが、ややこしいし使う気がしないので未対応。</p>
<p>Example:</p>
<pre><code class="language-php">// 2文字目から5文字を「あいうえお」に置換する
that(mb_substr_replace('０１２３４５６７８９', 'あいうえお', 2, 5))-&gt;isSame('０１あいうえお７８９');
</code></pre>
</div>
    	<h4 class="fqsen-title">method		<small></small>
		<a href="ryunosuke-Functions-Package-Strings$typespace.html#ryunosuke\Functions\Package\Strings::mb_trim()">
                                    ryunosuke\Functions\Package\Strings::mb_trim		</a>	<small>($string) : string</small>
		</h4>
	<div class="description"><p>マルチバイト対応 trim</p>
<p>Example:</p>
<pre><code class="language-php">that(mb_trim(' 　 あああ　 　'))-&gt;isSame('あああ');
</code></pre>
</div>
    	<h4 class="fqsen-title">method		<small></small>
		<a href="ryunosuke-Functions-Package-Strings$typespace.html#ryunosuke\Functions\Package\Strings::render_template()">
                                    ryunosuke\Functions\Package\Strings::render_template		</a>	<small>($template, $vars) : string</small>
		</h4>
	<div class="description"><p>"hoge ${hoge}" 形式のレンダリング</p>
<p>ES6 のテンプレートリテラルのようなもの。</p>
<ul>
<li>埋め込みは ${var} のみで、{$var} は無効</li>
<li>${expression} は「評価結果の変数名」ではなく「評価結果」が埋め込まれる</li>
</ul>
<p>$vars に callable を渡すと元文字列とプレースホルダー部分の配列でコールバックされる（タグ付きテンプレートの模倣）。</p>
<p>実装的にはただの文字列 eval なので " はエスケープする必要がある。</p>
<p>この関数は実験的機能のため、互換性を維持せず変更される可能性がある。</p>
<p>Example:</p>
<pre><code class="language-php">that(render_template('${max($nums)}', ['nums' =&gt; [1, 9, 3]]))-&gt;isSame('9');
</code></pre>
</div>
    	<h4 class="fqsen-title">method		<small></small>
		<a href="ryunosuke-Functions-Package-Strings$typespace.html#ryunosuke\Functions\Package\Strings::render_string()">
                                    ryunosuke\Functions\Package\Strings::render_string		</a>	<small>($template, $array) : string</small>
		</h4>
	<div class="description"><p>"hoge {$hoge}" 形式のレンダリング</p>
<p>文字列を eval して "hoge {$hoge}" 形式の文字列に変数を埋め込む。<br />
基本処理は <code>eval("return '" . addslashes($template) . "';");</code> と考えて良いが、下記が異なる。</p>
<ul>
<li>数値キーが参照できる</li>
<li>クロージャは呼び出し結果が埋め込まれる。引数は (変数配列, 自身のキー文字列)</li>
<li>引数をそのまま返すだけの特殊な変数 $_ が宣言される</li>
<li>シングルクォートのエスケープは外される</li>
</ul>
<p>$<em> が宣言されるのは変数配列に '</em>' を含んでいないときのみ（上書きを防止するため）。<br />
この $_ は php の埋め込み変数の闇を利用するととんでもないことが出来たりする（サンプルやテストコードを参照）。</p>
<p>ダブルクオートはエスケープされるので文字列からの脱出はできない。<br />
また、 <code>{$_(syntax(""))}</code> のように {$_()} 構文で " も使えなくなるので \' を使用しなければならない。</p>
<p>Example:</p>
<pre><code class="language-php">// 数値キーが参照できる
that(render_string('${0}', ['number']))-&gt;isSame('number');
// クロージャは呼び出し結果が埋め込まれる
that(render_string('$c', ['c' =&gt; function($vars, $k){return $k . '-closure';}]))-&gt;isSame('c-closure');
// 引数をそのまま返すだけの特殊な変数 $_ が宣言される
that(render_string('{$_(123 + 456)}', []))-&gt;isSame('579');
// 要するに '$_()' の中に php の式が書けるようになる
that(render_string('{$_(implode(\',\', $strs))}', ['strs' =&gt; ['a', 'n', 'z']]))-&gt;isSame('a,n,z');
that(render_string('{$_(max($nums))}', ['nums' =&gt; [1, 9, 3]]))-&gt;isSame('9');
</code></pre>
</div>
    	<h4 class="fqsen-title">method		<small></small>
		<a href="ryunosuke-Functions-Package-Strings$typespace.html#ryunosuke\Functions\Package\Strings::render_file()">
                                    ryunosuke\Functions\Package\Strings::render_file		</a>	<small>($template_file, $array) : string</small>
		</h4>
	<div class="description"><p>"hoge {$hoge}" 形式のレンダリングのファイル版</p>
</div>
    	<h4 class="fqsen-title">method		<small></small>
		<a href="ryunosuke-Functions-Package-Strings$typespace.html#ryunosuke\Functions\Package\Strings::ob_include()">
                                    ryunosuke\Functions\Package\Strings::ob_include		</a>	<small>($include_file, $array = []) : string</small>
		</h4>
	<div class="description"><p>変数を extract して include する</p>
<p>Example:</p>
<pre><code class="language-php">// このようなテンプレートファイルを用意すると
file_put_contents(sys_get_temp_dir() . '/template.php', '
This is plain text.
This is &lt;?= $var ?&gt;.
This is &lt;?php echo strtoupper($var) ?&gt;.
');
// このようにレンダリングできる
that(ob_include(sys_get_temp_dir() . '/template.php', ['var' =&gt; 'hoge']))-&gt;isSame('
This is plain text.
This is hoge.
This is HOGE.
');
</code></pre>
</div>
    	<h4 class="fqsen-title">method		<small></small>
		<a href="ryunosuke-Functions-Package-Strings$typespace.html#ryunosuke\Functions\Package\Strings::include_string()">
                                    ryunosuke\Functions\Package\Strings::include_string		</a>	<small>($template, $array = []) : string</small>
		</h4>
	<div class="description"><p>変数を extract して include する（文字列指定）</p>
</div>
            	<h4 class="fqsen-title">class		<small></small>
		<a href="ryunosuke-Functions-Package-Syntax$typespace.html#ryunosuke\Functions\Package\Syntax">
                                    ryunosuke\Functions\Package::Syntax		</a>	</h4>
	<div class="description"><p>構文関連のユーティリティ</p>
</div>
        	<h4 class="fqsen-title">classconstant		<small>integer</small>
		<a href="ryunosuke-Functions-Package-Syntax$typespace.html#ryunosuke\Functions\Package\Syntax::TOKEN_NAME">
                                    ryunosuke\Functions\Package\Syntax::TOKEN_NAME		</a>	</h4>
	<div class="description"><p>parse_php 関数でトークン名変換をするか</p>
</div>
            	<h4 class="fqsen-title">method		<small></small>
		<a href="ryunosuke-Functions-Package-Syntax$typespace.html#ryunosuke\Functions\Package\Syntax::evaluate()">
                                    ryunosuke\Functions\Package\Syntax::evaluate		</a>	<small>($phpcode, $contextvars = [], $cachesize = 256) : mixed</small>
		</h4>
	<div class="description"><p>eval のプロキシ関数</p>
<p>一度ファイルに吐いてから require した方が opcache が効くので抜群に速い。<br />
また、素の eval は ParseError が起こったときの表示がわかりにくすぎるので少し見やすくしてある。</p>
<p>関数化してる以上 eval におけるコンテキストの引き継ぎはできない。<br />
ただし、引数で変数配列を渡せるようにしてあるので get_defined_vars を併用すれば基本的には同じ（$this はどうしようもない）。</p>
<p>短いステートメントだと opcode が少ないのでファイルを経由せず直接 eval したほうが速いことに留意。<br />
一応引数で指定できるようにはしてある。</p>
<p>Example:</p>
<pre><code class="language-php">$a = 1;
$b = 2;
$phpcode = ';
$c = $a + $b;
return $c * 3;
';
that(evaluate($phpcode, get_defined_vars()))-&gt;isSame(9);
</code></pre>
</div>
    	<h4 class="fqsen-title">method		<small></small>
		<a href="ryunosuke-Functions-Package-Syntax$typespace.html#ryunosuke\Functions\Package\Syntax::parse_php()">
                                    ryunosuke\Functions\Package\Syntax::parse_php		</a>	<small>($phpcode, $option = []) : array</small>
		</h4>
	<div class="description"><p>php のコード断片をパースする</p>
<p>結果配列は token_get_all したものだが、「字句の場合に文字列で返す」仕様は適用されずすべて配列で返す。<br />
つまり必ず <code>[TOKENID, TOKEN, LINE, POS]</code> で返す。</p>
</div>
    	<h4 class="fqsen-title">method		<small></small>
		<a href="ryunosuke-Functions-Package-Syntax$typespace.html#ryunosuke\Functions\Package\Syntax::strip_php()">
                                    ryunosuke\Functions\Package\Syntax::strip_php		</a>	<small>($phtml, $replacer = &quot;&quot;, &amp;$mapping = []) : string</small>
		</h4>
	<div class="description"><p>文字列から php コードを取り除く</p>
<p>正確には $replacer で指定したものに置換される（デフォルト空文字なので削除になる）。<br />
$replacer にクロージャを渡すと(phpコード, 出現番号) が渡ってくるので、それに応じて値を返せばそれに置換される。<br />
文字列を指定すると自動で出現番号が付与される。</p>
<p>$mapping 配列には「どれをどのように」と言った変換表が格納される。<br />
典型的には strtr に渡して php コードを復元させるのに使用する。</p>
<p>Example:</p>
<pre><code class="language-php">$phtml = 'begin php code &lt;?php echo 123 ?&gt; end';
// php コードが消えている
that(strip_php($phtml))-&gt;is('begin php code  end');
// $mapping を使用すると元の文字列に復元できる
$html = strip_php($phtml, null, $mapping);
that(strtr($html, $mapping))-&gt;is($phtml);
</code></pre>
</div>
    	<h4 class="fqsen-title">method		<small></small>
		<a href="ryunosuke-Functions-Package-Syntax$typespace.html#ryunosuke\Functions\Package\Syntax::indent_php()">
                                    ryunosuke\Functions\Package\Syntax::indent_php		</a>	<small>($phpcode, $options = []) : string</small>
		</h4>
	<div class="description"><p>php のコードのインデントを調整する</p>
<p>baseline で基準インデント位置を指定する。<br />
その基準インデントを削除した後、指定したインデントレベルでインデントするようなイメージ。</p>
<p>Example:</p>
<pre><code class="language-php">$phpcode = '
    echo 123;

    if (true) {
        echo 456;
    }
';
// 数値指定は空白換算
that(indent_php($phpcode, 8))-&gt;isSame('
        echo 123;

        if (true) {
            echo 456;
        }
');
// 文字列を指定すればそれが使用される
that(indent_php($phpcode, "  "))-&gt;isSame('
  echo 123;

  if (true) {
      echo 456;
  }
');
// オプション指定
that(indent_php($phpcode, [
    'baseline'  =&gt; 1,    // 基準インデントの行番号（負数で下からの指定になる）
    'indent'    =&gt; 4,    // インデント指定（上記の数値・文字列指定はこれの糖衣構文）
    'trimempty' =&gt; true, // 空行を trim するか
    'heredoc'   =&gt; true, // php7.3 の Flexible Heredoc もインデントするか
]))-&gt;isSame('
    echo 123;

    if (true) {
        echo 456;
    }
');
</code></pre>
</div>
    	<h4 class="fqsen-title">method		<small></small>
		<a href="ryunosuke-Functions-Package-Syntax$typespace.html#ryunosuke\Functions\Package\Syntax::highlight_php()">
                                    ryunosuke\Functions\Package\Syntax::highlight_php		</a>	<small>($phpcode, $options = []) : string</small>
		</h4>
	<div class="description"><p>php のコードをハイライトする</p>
<p>SAPI に応じて自動でハイライトする（html タグだったり ASCII color だったり）。<br />
highlight_string の CLI 対応版とも言える。</p>
</div>
    	<h4 class="fqsen-title">method		<small></small>
		<a href="ryunosuke-Functions-Package-Syntax$typespace.html#ryunosuke\Functions\Package\Syntax::optional()">
                                    ryunosuke\Functions\Package\Syntax::optional		</a>	<small>($object, $expected = null) : object</small>
		</h4>
	<div class="description"><p>オブジェクトならそれを、オブジェクトでないなら NullObject を返す</p>
<p>null を返すかもしれないステートメントを一時変数を介さずワンステートメントで呼ぶことが可能になる。</p>
<p>NullObject は 基本的に null を返すが、return type が規約されている場合は null 以外を返すこともある。<br />
取得系呼び出しを想定しているので、設定系呼び出しは行うべきではない。<br />
__set のような明らかに設定が意図されているものは例外が飛ぶ。</p>
<p>Example:</p>
<pre><code class="language-php">// null を返すかもしれないステートメント
$getobject = function () {return null;};
// メソッド呼び出しは null を返す
that(optional($getobject())-&gt;method())-&gt;isSame(null);
// プロパティアクセスは null を返す
that(optional($getobject())-&gt;property)-&gt;isSame(null);
// empty は true を返す
that(empty(optional($getobject())-&gt;nothing))-&gt;isSame(true);
// __isset は false を返す
that(isset(optional($getobject())-&gt;nothing))-&gt;isSame(false);
// __toString は '' を返す
that(strval(optional($getobject())))-&gt;isSame('');
// __invoke は null を返す
that(call_user_func(optional($getobject())))-&gt;isSame(null);
// 配列アクセスは null を返す
that(optional($getobject())['hoge'])-&gt;isSame(null);
// 空イテレータを返す
that(iterator_to_array(optional($getobject())))-&gt;isSame([]);

// $expected を与えるとその型以外は NullObject を返す（\ArrayObject はオブジェクトだが stdClass ではない）
that(optional(new \ArrayObject([1]), 'stdClass')-&gt;count())-&gt;isSame(null);
</code></pre>
</div>
    	<h4 class="fqsen-title">method		<small></small>
		<a href="ryunosuke-Functions-Package-Syntax$typespace.html#ryunosuke\Functions\Package\Syntax::chain()">
                                    ryunosuke\Functions\Package\Syntax::chain		</a>	<small>($source = null) : <a href="ChainObject$typespace.html#ChainObject" class="fqsen ">ChainObject</a></small>
		</h4>
	<div class="description"><p>関数をメソッドチェーンできるオブジェクトを返す</p>
<p>ChainObject という関数をチェーンできるオブジェクトを返す。<br />
ChainObject は大抵のグローバル関数がアノテーションされており、コード補完することが出来る（利便性のためであり、IDE がエラーなどを出しても呼び出し自体は可能）。<br />
呼び出しは「第1引数に現在の値が適用」されて実行される（下記の func1 コールで任意の位置に適用されることもできる）。</p>
<p>下記の特殊ルールにより、特殊な呼び出し方ができる。</p>
<ul>
<li>array_XXX, str_XXX は省略して XXX で呼び出せる<ul>
<li>省略した結果、他の関数と被るようであれば短縮呼び出しは出来ない（array_優先でコールされる）</li>
<li>ini に 'rfunc.chain_overload' 定義されていれば型で分岐させることができる</li>
</ul>
</li>
<li>funcE で eval される文字列のクロージャを呼べる<ul>
<li>変数名は <code>$_</code> 固定だが、 <code>$_</code> が無いときに限り 最左に自動付与される</li>
</ul>
</li>
<li>funcP で配列指定オペレータのクロージャを呼べる<ul>
<li>複数指定した場合は順次呼ばれる。つまり map はともかく filter 用途では使えない</li>
</ul>
</li>
<li>func1 で「引数1（0 ベースなので要は2番目）に適用して func を呼び出す」ことができる<ul>
<li>func2, func3 等も呼び出し可能</li>
</ul>
</li>
<li>引数が1つの呼び出しは () を省略できる</li>
</ul>
<p>この特殊ルールは普通に使う分にはそこまで気にしなくて良い。<br />
map や filter を駆使しようとすると必要になるが、イテレーション目的ではなく文字列のチェインなどが目的であればほぼ使うことはない。</p>
<p>特殊なメソッドとして下記がある。</p>
<ul>
<li>apply($callback, ...$cbargs): 任意のコールバックを現在の値に適用する</li>
</ul>
<p>上記を含むメソッド呼び出しはすべて自分自身を返すので、最終結果を得たい場合は <code>invoke</code> を実行する必要がある。<br />
ただし、 IteratorAggregate が実装されているので、配列の場合に限り foreach で直接回すことができる。<br />
さらに、 __toString も実装されているので、文字列的値の場合に限り自動で文字列化される。</p>
<p>用途は配列のイテレーションを想定しているが、あくまで「チェイン可能にする」が目的なので、ソースが文字列だろうとオブジェクトだろうと何でも呼び出しが可能。<br />
ただし、遅延評価も最適化も何もしていないので、 chain するだけでも動作は相当遅くなることに注意。</p>
<p>なお、最初の引数を省略するとスタックモードになり、一切の処理が適用されなくなる。<br />
その代わり <code>invoke</code> で遅延的に値を渡すことができるようになる。<br />
「処理の流れだけ決めておいて後で適用する」イメージ。</p>
<p>Example:</p>
<pre><code class="language-php"># 1～9 のうち「5以下を抽出」して「値を2倍」して「合計」を出すシチュエーション
$n1_9 = range(1, 9);
// 素の php で処理したもの。パッと見で何してるか分からないし、処理の順番が思考と逆なので混乱する
that(array_sum(array_map(function ($v) { return $v * 2; }, array_filter($n1_9, function ($v) { return $v &lt;= 5; }))))-&gt;isSame(30);
// chain でクロージャを渡したもの。処理の順番が思考どおりだが、 function(){} が微妙にうざい（array_ は省略できるので filter, map, sum のような呼び出しができている）
that(chain($n1_9)-&gt;filter(function ($v) { return $v &lt;= 5; })-&gt;map(function ($v) { return $v * 2; })-&gt;sum()())-&gt;isSame(30);
// funcP を介して function(){} をなくしたもの。ここまで来ると若干読みやすい
that(chain($n1_9)-&gt;filterP(['&lt;=' =&gt; 5])-&gt;mapP(['*' =&gt; 2])-&gt;sum()())-&gt;isSame(30);
// funcE を介したもの。かなり直感的だが eval なので少し不安
that(chain($n1_9)-&gt;filterE('&lt;= 5')-&gt;mapE('* 2')-&gt;sum()())-&gt;isSame(30);

# "hello   world" を「" " で分解」して「空文字を除去」してそれぞれに「ucfirst」して「"/" で結合」して「rot13」して「md5」して「大文字化」するシチュエーション
$string = 'hello   world';
// 素の php で処理したもの。もはやなにがなんだか分からない
that(strtoupper(md5(str_rot13(implode('/', array_map('ucfirst', array_filter(explode(' ', $string))))))))-&gt;isSame('10AF4DAF67D0D666FCEA0A8C6EF57EE7');
// chain だとかなりそれっぽくできる。 explode/implode の第1引数は区切り文字なので func1 構文を使用している。また、 rot13 以降は引数がないので () を省略している
that(chain($string)-&gt;explode1(' ')-&gt;filter()-&gt;map('ucfirst')-&gt;implode1('/')-&gt;rot13-&gt;md5-&gt;strtoupper()())-&gt;isSame('10AF4DAF67D0D666FCEA0A8C6EF57EE7');

 # よくある DB レコードをあれこれするシチュエーション
$rows = [
    ['id' =&gt; 1, 'name' =&gt; 'hoge', 'sex' =&gt; 'F', 'age' =&gt; 17, 'salary' =&gt; 230000],
    ['id' =&gt; 3, 'name' =&gt; 'fuga', 'sex' =&gt; 'M', 'age' =&gt; 43, 'salary' =&gt; 480000],
    ['id' =&gt; 7, 'name' =&gt; 'piyo', 'sex' =&gt; 'M', 'age' =&gt; 21, 'salary' =&gt; 270000],
    ['id' =&gt; 9, 'name' =&gt; 'hage', 'sex' =&gt; 'F', 'age' =&gt; 30, 'salary' =&gt; 320000],
];
// e.g. 男性の平均給料
that(chain($rows)-&gt;whereP('sex', ['===' =&gt; 'M'])-&gt;column('salary')-&gt;mean()())-&gt;isSame(375000);
// e.g. 女性の平均年齢
that(chain($rows)-&gt;whereE('sex', '=== "F"')-&gt;column('age')-&gt;mean()())-&gt;isSame(23.5);
// e.g. 30歳以上の平均給料
that(chain($rows)-&gt;whereP('age', ['&gt;=' =&gt; 30])-&gt;column('salary')-&gt;mean()())-&gt;isSame(400000);
// e.g. 20～30歳の平均給料
that(chain($rows)-&gt;whereP('age', ['&gt;=' =&gt; 20])-&gt;whereE('age', '&lt;= 30')-&gt;column('salary')-&gt;mean()())-&gt;isSame(295000);
// e.g. 男性の最小年齢
that(chain($rows)-&gt;whereP('sex', ['===' =&gt; 'M'])-&gt;column('age')-&gt;min()())-&gt;isSame(21);
// e.g. 女性の最大給料
that(chain($rows)-&gt;whereE('sex', '=== "F"')-&gt;column('salary')-&gt;max()())-&gt;isSame(320000);

# 上記の引数遅延モード（結果は同じなのでいくつかピックアップ）
that(chain()-&gt;whereP('sex', ['===' =&gt; 'M'])-&gt;column('salary')-&gt;mean()($rows))-&gt;isSame(375000);
that(chain()-&gt;whereP('age', ['&gt;=' =&gt; 30])-&gt;column('salary')-&gt;mean()($rows))-&gt;isSame(400000);
that(chain()-&gt;whereP('sex', ['===' =&gt; 'M'])-&gt;column('age')-&gt;min()($rows))-&gt;isSame(21);
</code></pre>
</div>
    	<h4 class="fqsen-title">method		<small></small>
		<a href="ryunosuke-Functions-Package-Syntax$typespace.html#ryunosuke\Functions\Package\Syntax::throws()">
                                    ryunosuke\Functions\Package\Syntax::throws		</a>	<small>($ex) : mixed</small>
		</h4>
	<div class="description"><p>throw の関数版</p>
<p>hoge() or throw などしたいことがまれによくあるはず。</p>
<p>Example:</p>
<pre><code class="language-php">try {
    throws(new \Exception('throws'));
}
catch (\Exception $ex) {
    that($ex-&gt;getMessage())-&gt;isSame('throws');
}
</code></pre>
</div>
    	<h4 class="fqsen-title">method		<small></small>
		<a href="ryunosuke-Functions-Package-Syntax$typespace.html#ryunosuke\Functions\Package\Syntax::throw_if()">
                                    ryunosuke\Functions\Package\Syntax::throw_if		</a>	<small>($flag, $ex, ...$ex_args) : void</small>
		</h4>
	<div class="description"><p>条件付き throw</p>
<p>第1引数が true 相当のときに例外を投げる。</p>
<p>Example:</p>
<pre><code class="language-php">// 投げない
throw_if(false, new \Exception());
// 投げる
try{throw_if(true, new \Exception());}catch(\Exception $ex){}
// クラス指定で投げる
try{throw_if(true, \Exception::class, 'message', 123);}catch(\Exception $ex){}
</code></pre>
</div>
    	<h4 class="fqsen-title">method		<small></small>
		<a href="ryunosuke-Functions-Package-Syntax$typespace.html#ryunosuke\Functions\Package\Syntax::blank_if()">
                                    ryunosuke\Functions\Package\Syntax::blank_if		</a>	<small>($var, $default = null) : mixed</small>
		</h4>
	<div class="description"><p>値が空なら null を返す</p>
<p><code>is_empty($value) ? $value : null</code> とほぼ同じ。<br />
言ってしまえば「falsy な値を null に変換する」とも言える。</p>
<p>ここでいう falsy とは php 標準の <code>empty</code> ではなく本ライブラリの <code>is_empty</code> であることに留意（"0" は空ではない）。<br />
さらに利便性のため 0, 0.0 も空ではない判定をする（strpos や array_search などで「0 は意味のある値」という事が多いので）。<br />
乱暴に言えば「仮に文字列化したとき、情報量がゼロ」が falsy になる。</p>
<ul>
<li>「 <code>$var ?: 'default'</code> で十分なんだけど "0" が…」</li>
<li>「 <code>$var ?? 'default'</code> で十分なんだけど false が…」</li>
</ul>
<p>という状況はまれによくあるはず。</p>
<p>?? との親和性のため null を返す動作がデフォルトだが、そのデフォルト値は引数で渡すこともできる。<br />
用途は Example を参照。</p>
<p>Example:</p>
<pre><code class="language-php">// falsy な値は null を返すので null 合体演算子でデフォルト値が得られる
that(blank_if(null) ?? 'default')-&gt;isSame('default');
that(blank_if('')   ?? 'default')-&gt;isSame('default');
// falsy じゃない値の場合は引数をそのまま返すので null 合体演算子には反応しない
that(blank_if(0)   ?? 'default')-&gt;isSame(0);   // 0 は空ではない
that(blank_if('0') ?? 'default')-&gt;isSame('0'); // "0" は空ではない
that(blank_if(1)   ?? 'default')-&gt;isSame(1);
that(blank_if('X') ?? 'default')-&gt;isSame('X');
// 第2引数で返る値を指定できるので下記も等価となる。ただし、php の仕様上第2引数が必ず評価されるため、関数呼び出しなどだと無駄な処理となる
that(blank_if(null, 'default'))-&gt;isSame('default');
that(blank_if('',   'default'))-&gt;isSame('default');
that(blank_if(0,    'default'))-&gt;isSame(0);
that(blank_if('0',  'default'))-&gt;isSame('0');
that(blank_if(1,    'default'))-&gt;isSame(1);
that(blank_if('X',  'default'))-&gt;isSame('X');
// 第2引数の用途は少し短く書けることと演算子の優先順位のつらみの回避程度（`??` は結構優先順位が低い。下記を参照）
that(0 &lt; blank_if(null) ?? 1)-&gt;isFalse();  // (0 &lt; null) ?? 1 となるので false
that(0 &lt; blank_if(null, 1))-&gt;isTrue();     // 0 &lt; 1 となるので true
that(0 &lt; (blank_if(null) ?? 1))-&gt;isTrue(); // ?? で同じことしたいならこのように括弧が必要

# ここから下は既存言語機構との比較（愚痴っぽいので読まなくてもよい）

// エルビス演算子は "0" にも反応するので正直言って使いづらい（php における falsy の定義は広すぎる）
that(null ?: 'default')-&gt;isSame('default');
that(''   ?: 'default')-&gt;isSame('default');
that(1    ?: 'default')-&gt;isSame(1);
that('0'  ?: 'default')-&gt;isSame('default'); // こいつが反応してしまう
that('X'  ?: 'default')-&gt;isSame('X');
// 逆に null 合体演算子は null にしか反応しないので微妙に使い勝手が悪い（php の標準関数が false を返したりするし）
that(null ?? 'default')-&gt;isSame('default'); // こいつしか反応しない
that(''   ?? 'default')-&gt;isSame('');
that(1    ?? 'default')-&gt;isSame(1);
that('0'  ?? 'default')-&gt;isSame('0');
that('X'  ?? 'default')-&gt;isSame('X');
// 恣意的な例だが、 substr は false も '0' も返し得るので ?: は使えない。 null を返すこともないので ?? も使えない（エラーも吐かない）
that(substr('000', 1, 1) ?: 'default')-&gt;isSame('default'); // '0' を返すので 'default' になる
that(substr('xxx', 9, 1) ?: 'default')-&gt;isSame('default'); // （文字数が足りなくて）false を返すので 'default' になる
that(substr('000', 1, 1) ?? 'default')-&gt;isSame('0');   // substr が null を返すことはないので 'default' になることはない
that(substr('xxx', 9, 1) ?? 'default')-&gt;isSame(false); // substr が null を返すことはないので 'default' になることはない
// 要するに単に「false が返ってきた場合に 'default' としたい」だけなんだが、下記のようにめんどくさいことをせざるを得ない
that(substr('xxx', 9, 1) === false ? 'default' : substr('xxx', 9, 1))-&gt;isSame('default'); // 3項演算子で2回呼ぶ
that(($tmp = substr('xxx', 9, 1) === false) ? 'default' : $tmp)-&gt;isSame('default');       // 一時変数を使用する（あるいは if 文）
// このように書きたかった
that(blank_if(substr('xxx', 9, 1)) ?? 'default')-&gt;isSame('default'); // null 合体演算子版
that(blank_if(substr('xxx', 9, 1), 'default'))-&gt;isSame('default');   // 第2引数版

// 恣意的な例その2。 0 は空ではないので array_search などにも応用できる（見つからない場合に false を返すので ?? はできないし、 false 相当を返し得るので ?: もできない）
that(array_search('x', ['a', 'b', 'c']) ?? 'default')-&gt;isSame(false);     // 見つからないので 'default' としたいが false になってしまう
that(array_search('a', ['a', 'b', 'c']) ?: 'default')-&gt;isSame('default'); // 見つかったのに 0 に反応するので 'default' になってしまう
that(blank_if(array_search('x', ['a', 'b', 'c'])) ?? 'default')-&gt;isSame('default'); // このように書きたかった
that(blank_if(array_search('a', ['a', 'b', 'c'])) ?? 'default')-&gt;isSame(0);         // このように書きたかった
</code></pre>
</div>
    	<h4 class="fqsen-title">method		<small></small>
		<a href="ryunosuke-Functions-Package-Syntax$typespace.html#ryunosuke\Functions\Package\Syntax::call_if()">
                                    ryunosuke\Functions\Package\Syntax::call_if		</a>	<small>($condition, $callable, ...$arguments) : mixed</small>
		</h4>
	<div class="description"><p>条件を満たしたときにコールバックを実行する</p>
<p><code>if ($condition) $callable(...$arguments);</code> と（$condition はクロージャを受け入れるけど）ほぼ同じ。<br />
ただし、 $condition に数値を与えると「指定回数呼ばれたあとに実行する」という意味になる。<br />
主に「ループ内でデバッグ出力したいけど、毎回だと少しうざい」というデバッグ用途。</p>
<p>$condition が正数だと「指定回数呼ばれた次のみ」負数だと「指定回数呼ばれた次以降」実行される。<br />
0 のときは無条件で実行される。</p>
<p>Example:</p>
<pre><code class="language-php">$output = [];
$debug_print = function ($debug) use (&amp;$output) { $output[] = $debug; };
for ($i=0; $i&lt;4; $i++) {
    call_if($i == 1, $debug_print, '$i == 1のとき呼ばれた');
    call_if(2, $debug_print, '2回呼ばれた');
    call_if(-2, $debug_print, '2回以上呼ばれた');
}
that($output)-&gt;isSame([
    '$i == 1のとき呼ばれた',
    '2回呼ばれた',
    '2回以上呼ばれた',
    '2回以上呼ばれた',
]);
</code></pre>
</div>
    	<h4 class="fqsen-title">method		<small></small>
		<a href="ryunosuke-Functions-Package-Syntax$typespace.html#ryunosuke\Functions\Package\Syntax::switchs()">
                                    ryunosuke\Functions\Package\Syntax::switchs		</a>	<small>($value, $cases, $default = null) : mixed</small>
		</h4>
	<div class="description"><p>switch 構文の関数版</p>
<p>case にクロージャを与えると実行して返す。<br />
つまり、クロージャを返すことは出来ないので注意。</p>
<p>$default を与えないとマッチしなかったときに例外を投げる。</p>
<p>Example:</p>
<pre><code class="language-php">$cases = [
    1 =&gt; 'value is 1',
    2 =&gt; function(){return 'value is 2';},
];
that(switchs(1, $cases))-&gt;isSame('value is 1');
that(switchs(2, $cases))-&gt;isSame('value is 2');
that(switchs(3, $cases, 'undefined'))-&gt;isSame('undefined');
</code></pre>
</div>
    	<h4 class="fqsen-title">method		<small></small>
		<a href="ryunosuke-Functions-Package-Syntax$typespace.html#ryunosuke\Functions\Package\Syntax::try_null()">
                                    ryunosuke\Functions\Package\Syntax::try_null		</a>	<small>($try, ...$variadic) : mixed</small>
		</h4>
	<div class="description"><p>例外を握りつぶす try 構文</p>
<p>例外機構構文が冗長なことがまれによくあるはず。</p>
<p>Example:</p>
<pre><code class="language-php">// 例外が飛ばない場合は平和極まりない
$try = function($a, $b, $c){return [$a, $b, $c];};
that(try_null($try, 1, 2, 3))-&gt;isSame([1, 2, 3]);
// 例外が飛ぶ場合は null が返ってくる
$try = function(){throw new \Exception('tried');};
that(try_null($try))-&gt;isSame(null);
</code></pre>
</div>
    	<h4 class="fqsen-title">method		<small></small>
		<a href="ryunosuke-Functions-Package-Syntax$typespace.html#ryunosuke\Functions\Package\Syntax::try_return()">
                                    ryunosuke\Functions\Package\Syntax::try_return		</a>	<small>($try, ...$variadic) : mixed</small>
		</h4>
	<div class="description"><p>例外が飛んだら例外オブジェクトを返す</p>
<p>例外機構構文が冗長なことがまれによくあるはず。</p>
<p>Example:</p>
<pre><code class="language-php">// 例外が飛ばない場合は平和極まりない
$try = function($a, $b, $c){return [$a, $b, $c];};
that(try_return($try, 1, 2, 3))-&gt;isSame([1, 2, 3]);
// 例外が飛ぶ場合は例外オブジェクトが返ってくる
$try = function(){throw new \Exception('tried');};
that(try_return($try))-&gt;IsInstanceOf(\Exception::class);
</code></pre>
</div>
    	<h4 class="fqsen-title">method		<small></small>
		<a href="ryunosuke-Functions-Package-Syntax$typespace.html#ryunosuke\Functions\Package\Syntax::try_catch()">
                                    ryunosuke\Functions\Package\Syntax::try_catch		</a>	<small>($try, $catch = null, ...$variadic) : <a href="http://php.net/manual/ja/class.exception.php" class="fqsen" target="_blank">\Exception</a><span class="type-separator"></span><wbr>mixed</small>
		</h4>
	<div class="description"><p>try ～ catch 構文の関数版</p>
<p>例外機構構文が冗長なことがまれによくあるはず。</p>
<p>Example:</p>
<pre><code class="language-php">// 例外が飛ばない場合は平和極まりない
$try = function($a, $b, $c){return [$a, $b, $c];};
that(try_catch($try, null, 1, 2, 3))-&gt;isSame([1, 2, 3]);
// 例外が飛ぶ場合は特殊なことをしなければ例外オブジェクトが返ってくる
$try = function(){throw new \Exception('tried');};
that(try_catch($try)-&gt;getMessage())-&gt;isSame('tried');
</code></pre>
</div>
    	<h4 class="fqsen-title">method		<small></small>
		<a href="ryunosuke-Functions-Package-Syntax$typespace.html#ryunosuke\Functions\Package\Syntax::try_finally()">
                                    ryunosuke\Functions\Package\Syntax::try_finally		</a>	<small>($try, $finally = null, ...$variadic) : <a href="http://php.net/manual/ja/class.exception.php" class="fqsen" target="_blank">\Exception</a><span class="type-separator"></span><wbr>mixed</small>
		</h4>
	<div class="description"><p>try ～ finally 構文の関数版</p>
<p>例外は投げっぱなす。例外機構構文が冗長なことがまれによくあるはず。</p>
<p>Example:</p>
<pre><code class="language-php">$finally_count = 0;
$finally = function()use(&amp;$finally_count){$finally_count++;};
// 例外が飛ぼうと飛ぶまいと $finally は実行される
$try = function($a, $b, $c){return [$a, $b, $c];};
that(try_finally($try, $finally, 1, 2, 3))-&gt;isSame([1, 2, 3]);
that($finally_count)-&gt;isSame(1); // 呼ばれている
// 例外は投げっぱなすが、 $finally は実行される
$try = function(){throw new \Exception('tried');};
try {try_finally($try, $finally, 1, 2, 3);} catch(\Exception $e){}
that($finally_count)-&gt;isSame(2); // 呼ばれている
</code></pre>
</div>
    	<h4 class="fqsen-title">method		<small></small>
		<a href="ryunosuke-Functions-Package-Syntax$typespace.html#ryunosuke\Functions\Package\Syntax::try_catch_finally()">
                                    ryunosuke\Functions\Package\Syntax::try_catch_finally		</a>	<small>($try, $catch = null, $finally = null, ...$variadic) : <a href="http://php.net/manual/ja/class.exception.php" class="fqsen" target="_blank">\Exception</a><span class="type-separator"></span><wbr>mixed</small>
		</h4>
	<div class="description"><p>try ～ catch ～ finally 構文の関数版</p>
<p>例外機構構文が冗長なことがまれによくあるはず。</p>
<p>Example:</p>
<pre><code class="language-php">$finally_count = 0;
$finally = function()use(&amp;$finally_count){$finally_count++;};
// 例外が飛ぼうと飛ぶまいと $finally は実行される
$try = function($a, $b, $c){return [$a, $b, $c];};
that(try_catch_finally($try, null, $finally, 1, 2, 3))-&gt;isSame([1, 2, 3]);
that($finally_count)-&gt;isSame(1); // 呼ばれている
// 例外を投げるが、 $catch で握りつぶす
$try = function(){throw new \Exception('tried');};
that(try_catch_finally($try, null, $finally, 1, 2, 3)-&gt;getMessage())-&gt;isSame('tried');
that($finally_count)-&gt;isSame(2); // 呼ばれている
</code></pre>
</div>
            	<h4 class="fqsen-title">class		<small></small>
		<a href="ryunosuke-Functions-Package-Utility$typespace.html#ryunosuke\Functions\Package\Utility">
                                    ryunosuke\Functions\Package::Utility		</a>	</h4>
	<div class="description"><p>汎用的なユーティリティ</p>
</div>
                	<h4 class="fqsen-title">method		<small></small>
		<a href="ryunosuke-Functions-Package-Utility$typespace.html#ryunosuke\Functions\Package\Utility::ini_sets()">
                                    ryunosuke\Functions\Package\Utility::ini_sets		</a>	<small>($values) : callable</small>
		</h4>
	<div class="description"><p>複数の php.ini の設定をまとめて設定する</p>
<p>返り値として「もとに戻すためのクロージャ」を返すので、復元するためにはそのクロージャを呼ぶだけで良い。</p>
</div>
    	<h4 class="fqsen-title">method		<small></small>
		<a href="ryunosuke-Functions-Package-Utility$typespace.html#ryunosuke\Functions\Package\Utility::get_uploaded_files()">
                                    ryunosuke\Functions\Package\Utility::get_uploaded_files		</a>	<small>($files = null) : array</small>
		</h4>
	<div class="description"><p>$_FILES の構造を組み替えて $_POST などと同じにする</p>
<p>$_FILES の配列構造はバグとしか思えないのでそれを是正する関数。<br />
第1引数 $files は指定可能だが、大抵は $_FILES であり、指定するのはテスト用。</p>
<p>サンプルを書くと長くなるので例は<tag_source data-fqsen='ryunosuke\Test\Package\UtilityTest::test_get_uploaded_files()' data-description='テストファイル'>テストファイル</tag_source>を参照。</p>
</div>
    	<h4 class="fqsen-title">method		<small></small>
		<a href="ryunosuke-Functions-Package-Utility$typespace.html#ryunosuke\Functions\Package\Utility::number_serial()">
                                    ryunosuke\Functions\Package\Utility::number_serial		</a>	<small>($numbers, $step = 1, $separator = null, $doSort = true) : array</small>
		</h4>
	<div class="description"><p>連続した数値の配列を縮めて返す</p>
<p>例えば <code>[1, 2, 4, 6, 7, 9]</code> が <code>['1~2', 4, '6~7', 9]</code> になる。<br />
結合法則は指定可能（上記は "~" を指定したもの）。<br />
null を与えると配列の配列で返すことも可能。</p>
<p>Example:</p>
<pre><code class="language-php">// 単純に文字列指定
that(number_serial([1, 2, 4, 6, 7, 9], 1, '~'))-&gt;is(['1~2', 4, '6~7', 9]);
// null を与えると from, to の配列で返す
that(number_serial([1, 2, 4, 6, 7, 9], 1, null))-&gt;is([[1, 2], [4, 4], [6, 7], [9, 9]]);
// $step は負数・小数・逆順も対応している（正負でよしなにソートされる）
that(number_serial([-9, 0.2, 0.5, -0.3, 0.1, 0, -0.2, 9], -0.1, '~'))-&gt;is([9, 0.5, '0.2~0', '-0.2~-0.3', -9]);
</code></pre>
</div>
    	<h4 class="fqsen-title">method		<small></small>
		<a href="ryunosuke-Functions-Package-Utility$typespace.html#ryunosuke\Functions\Package\Utility::cacheobject()">
                                    ryunosuke\Functions\Package\Utility::cacheobject		</a>	<small>($directory) : <a href="Psr-SimpleCache-CacheInterface$typespace.html#Psr\SimpleCache\CacheInterface" class="fqsen "><small>Psr\SimpleCache\</small><wbr>CacheInterface</a></small>
		</h4>
	<div class="description"><p>psr-16 を実装したキャッシュオブジェクトを返す</p>
<p>このオブジェクトはあくまで「他のパッケージに依存したくない」場合のデフォルト実装としての使用を想定している。</p>
<ul>
<li>キャッシュはファイルシステムに保存される</li>
<li>キャッシュキーの . はディレクトリ区切りとして使用される</li>
<li>TTL を指定しなかったときのデフォルト値は約100年（実質無期限だろう）</li>
<li>clear するとディレクトリ自体を吹き飛ばすのでそのディレクトリはキャッシュ以外の用途に使用してはならない</li>
</ul>
<p>psr-16 は依存に含めていないので別途 composer require psr/simple-cache が必要。</p>
</div>
    	<h4 class="fqsen-title">method		<small></small>
		<a href="ryunosuke-Functions-Package-Utility$typespace.html#ryunosuke\Functions\Package\Utility::cachedir()">
                                    ryunosuke\Functions\Package\Utility::cachedir		</a>	<small>($dirname = null) : string</small>
		</h4>
	<div class="description"><p>本ライブラリで使用するキャッシュディレクトリを設定する</p>
</div>
    	<h4 class="fqsen-title">method		<small></small>
		<a href="ryunosuke-Functions-Package-Utility$typespace.html#ryunosuke\Functions\Package\Utility::cache()">
                                    ryunosuke\Functions\Package\Utility::cache		</a>	<small>($key, $provider, $namespace = null) : mixed</small>
		</h4>
	<div class="description"><p>シンプルにキャッシュする</p>
<p>この関数は get/set/delete を兼ねる。<br />
キャッシュがある場合はそれを返し、ない場合は $provider を呼び出してその結果をキャッシュしつつそれを返す。</p>
<p>$provider に null を与えるとキャッシュの削除となる。</p>
<p>Example:</p>
<pre><code class="language-php">$provider = function(){return rand();};
// 乱数を返す処理だが、キャッシュされるので同じ値になる
$rand1 = cache('rand', $provider);
$rand2 = cache('rand', $provider);
that($rand1)-&gt;isSame($rand2);
// $provider に null を与えると削除される
cache('rand', null);
$rand3 = cache('rand', $provider);
that($rand1)-&gt;isNotSame($rand3);
</code></pre>
</div>
    	<h4 class="fqsen-title">method		<small></small>
		<a href="ryunosuke-Functions-Package-Utility$typespace.html#ryunosuke\Functions\Package\Utility::parse_namespace()">
                                    ryunosuke\Functions\Package\Utility::parse_namespace		</a>	<small>($filename) : array</small>
		</h4>
	<div class="description"><p>php ファイルをパースして名前空間配列を返す</p>
<p>ファイル内で use/use const/use function していたり、シンボルを定義していたりする箇所を検出して名前空間単位で返す。</p>
<p>Example:</p>
<pre><code class="language-php">// このような php ファイルをパースすると・・・
file_set_contents(sys_get_temp_dir() . '/namespace.php', '
&lt;?php
namespace NS1;
use ArrayObject as AO;
use function strlen as SL;
function InnerFunc(){}
class InnerClass{}

namespace NS2;
use RuntimeException as RE;
use const COUNT_RECURSIVE as CR;
class InnerClass{}
const InnerConst = 123;
');
// このような名前空間配列が得られる
that(parse_namespace(sys_get_temp_dir() . '/namespace.php'))-&gt;isSame([
    'NS1' =&gt; [
        'const'    =&gt; [],
        'function' =&gt; [
            'SL'        =&gt; 'strlen',
            'InnerFunc' =&gt; 'NS1\\InnerFunc',
        ],
        'alias'    =&gt; [
            'AO'         =&gt; 'ArrayObject',
            'InnerClass' =&gt; 'NS1\\InnerClass',
        ],
    ],
    'NS2' =&gt; [
        'const'    =&gt; [
            'CR'         =&gt; 'COUNT_RECURSIVE',
            'InnerConst' =&gt; 'NS2\\InnerConst',
        ],
        'function' =&gt; [],
        'alias'    =&gt; [
            'RE'         =&gt; 'RuntimeException',
            'InnerClass' =&gt; 'NS2\\InnerClass',
        ],
    ],
]);
</code></pre>
</div>
    	<h4 class="fqsen-title">method		<small></small>
		<a href="ryunosuke-Functions-Package-Utility$typespace.html#ryunosuke\Functions\Package\Utility::resolve_symbol()">
                                    ryunosuke\Functions\Package\Utility::resolve_symbol		</a>	<small>($shortname, $nsfiles, $targets = [&quot;const&quot;, &quot;function&quot;, &quot;alias&quot;]) : string<span class="type-separator"></span><wbr>null</small>
		</h4>
	<div class="description"><p>エイリアス名を完全修飾名に解決する</p>
<p>例えばあるファイルのある名前空間で <code>use Hoge\Fuga\Piyo;</code> してるときの <code>Piyo</code> を <code>Hoge\Fuga\Piyo</code> に解決する。</p>
<p>Example:</p>
<pre><code class="language-php">// このような php ファイルがあるとして・・・
file_set_contents(sys_get_temp_dir() . '/symbol.php', '
&lt;?php
namespace vendor\NS;

use ArrayObject as AO;
use function strlen as SL;

function InnerFunc(){}
class InnerClass{}
');
// 下記のように解決される
that(resolve_symbol('AO', sys_get_temp_dir() . '/symbol.php'))-&gt;isSame('ArrayObject');
that(resolve_symbol('SL', sys_get_temp_dir() . '/symbol.php'))-&gt;isSame('strlen');
that(resolve_symbol('InnerFunc', sys_get_temp_dir() . '/symbol.php'))-&gt;isSame('vendor\\NS\\InnerFunc');
that(resolve_symbol('InnerClass', sys_get_temp_dir() . '/symbol.php'))-&gt;isSame('vendor\\NS\\InnerClass');
</code></pre>
</div>
    	<h4 class="fqsen-title">method		<small></small>
		<a href="ryunosuke-Functions-Package-Utility$typespace.html#ryunosuke\Functions\Package\Utility::parse_annotation()">
                                    ryunosuke\Functions\Package\Utility::parse_annotation		</a>	<small>($annotation, $schema = [], $nsfiles = []) : array</small>
		</h4>
	<div class="description"><p>アノテーションっぽい文字列をそれっぽくパースして返す</p>
<p>$annotation にはリフレクションオブジェクトも渡せる。<br />
その場合、getDocComment や getFilename, getNamespaceName などを用いてある程度よしなに名前解決する。<br />
もっとも、@Class(args) 形式を使わないのであれば特に意味はない。</p>
<p>$schame で「どのように取得するか？」のスキーマ定義が渡せる。<br />
ただし、現実装では「そのまま文字列で返すか？」の bool 値とクロージャしか渡すことはできない。</p>
<p>アノテーションの仕様は下記（すべて $schema が false であるとする）。</p>
<ul>
<li>@から行末まで（1行に複数のアノテーションは含められない）<ul>
<li>ただし行末が <code>({[</code> のいずれかであれば次の <code>]})</code> までブロックを記載する機会が与えられる</li>
<li>ブロックを見つけたときは本来値となるべき値がキーに、ブロックが値となり、結果は必ず配列化される</li>
</ul>
</li>
<li>同じアノテーションを複数見つけたときは配列化される</li>
<li><code>@hogera</code>: 値なしは null を返す</li>
<li><code>@hogera v1 "v2 v3"</code>: ["v1", "v2 v3"] という配列として返す</li>
<li><code>@hogera {key: 123}</code>: ["key" =&gt; 123] という（連想）配列として返す</li>
<li><code>@hogera [123, 456]</code>: [123, 456] という連番配列として返す</li>
<li><code>@hogera ("2019/12/23")</code>: hogera で解決できるクラス名で new して返す（$filename 引数の指定が必要）</li>
<li>下3つの形式はアノテーション区切りのスペースはあってもなくても良い</li>
</ul>
<p>$schema が true だと上記のような変換は一切行わず、素朴な文字列で返す。<br />
あくまで簡易実装であり、本格的に何かをしたいなら専用のパッケージを導入したほうが良い。</p>
<p>Example:</p>
<pre><code class="language-php">$annotations = parse_annotation('
冒頭の - に意味はない
- @noval
- @single this is value
- @closure this is value
- @array this is value
- @hash {key: 123}
- @list [1, 2, 3]
- @ArrayObject([1, 2, 3])
- @block message {
      this is message1
      this is message2
  }
- @same this is same value1
- @same this is same value2
- @same this is same value3
', [
    'single'  =&gt; true,
    'closure' =&gt; function ($value) { return explode(' ', strtoupper($value)); },
]);
that($annotations)-&gt;is([
    'noval'       =&gt; null,                        // 値なしは null になる
    'single'      =&gt; 'this is value',             // $schema 指定してるので文字列になる
    'closure'     =&gt; ['THIS', 'IS', 'VALUE'],     // $schema 指定してそれがクロージャだとコールバックされる
    'array'       =&gt; ['this', 'is', 'value'],     // $schema 指定していないので配列になる
    'hash'        =&gt; ['key' =&gt; '123'],            // 連想配列になる
    'list'        =&gt; [1, 2, 3],                   // 連番配列になる
    'ArrayObject' =&gt; new \ArrayObject([1, 2, 3]), // new されてインスタンスになる
    "block"       =&gt; [                            // ブロックはブロック外をキーとした連想配列になる（複数指定でキーは指定できるイメージ）
        "message" =&gt; ["this is message1\n      this is message2"],
    ],
    'same'        =&gt; [                            // 複数あるのでそれぞれの配列になる
        ['this', 'is', 'same', 'value1'],
        ['this', 'is', 'same', 'value2'],
        ['this', 'is', 'same', 'value3'],
    ],
]);
</code></pre>
</div>
    	<h4 class="fqsen-title">method		<small></small>
		<a href="ryunosuke-Functions-Package-Utility$typespace.html#ryunosuke\Functions\Package\Utility::is_ansi()">
                                    ryunosuke\Functions\Package\Utility::is_ansi		</a>	<small>($stream) : bool</small>
		</h4>
	<div class="description"><p>リソースが ansi color に対応しているか返す</p>
<p>パイプしたりリダイレクトしていると false を返す。</p>
</div>
    	<h4 class="fqsen-title">method		<small></small>
		<a href="ryunosuke-Functions-Package-Utility$typespace.html#ryunosuke\Functions\Package\Utility::ansi_colorize()">
                                    ryunosuke\Functions\Package\Utility::ansi_colorize		</a>	<small>($string, $color) : string</small>
		</h4>
	<div class="description"><p>文字列に ANSI Color エスケープシーケンスを埋め込む</p>
<ul>
<li>"blue" のような小文字色名は文字色</li>
<li>"BLUE" のような大文字色名は背景色</li>
<li>"bold" のようなスタイル名は装飾</li>
</ul>
<p>となる。その区切り文字は現在のところ厳密に定めていない（<code>fore+back|bold</code> のような形式で定めることも考えたけどメリットがない）。<br />
つまり、アルファベット以外で分割するので、</p>
<ul>
<li><code>blue|WHITE@bold</code>: 文字青・背景白・太字</li>
<li><code>blue WHITE bold underscore</code>: 文字青・背景白・太字・下線</li>
<li><code>italic|bold,blue+WHITE  </code>: 文字青・背景白・太字・斜体</li>
</ul>
<p>という動作になる（記号で区切られていれば形式はどうでも良いということ）。<br />
ただ、この指定方法は変更が入る可能性が高いのでスペースあたりで区切っておくのがもっとも無難。</p>
</div>
    	<h4 class="fqsen-title">method		<small></small>
		<a href="ryunosuke-Functions-Package-Utility$typespace.html#ryunosuke\Functions\Package\Utility::process()">
                                    ryunosuke\Functions\Package\Utility::process		</a>	<small>($command, $args = [], $stdin = &quot;&quot;, &amp;$stdout = &quot;&quot;, &amp;$stderr = &quot;&quot;, $cwd = null, $env = null) : int</small>
		</h4>
	<div class="description"><p>proc_open ～ proc_close の一連の処理を行う</p>
<p>標準入出力は文字列で受け渡しできるが、決め打ち実装なのでいわゆる対話型なプロセスは起動できない。<br />
また、標準入出力はリソース型を渡すこともできる。</p>
<p>Example:</p>
<pre><code class="language-php">// サンプル実行用ファイルを用意
$phpfile = sys_get_temp_dir() . '/rf-sample.php';
file_put_contents($phpfile, "&lt;?php
    fwrite(STDOUT, fgets(STDIN));
    fwrite(STDERR, 'err');
    exit((int) ini_get('max_file_uploads'));
");
// 引数と標準入出力エラーを使った単純な例
$rc = process(PHP_BINARY, [
    '-d' =&gt; 'max_file_uploads=123',
    $phpfile,
], 'out', $stdout, $stderr);
that($rc)-&gt;isSame(123); // -d で与えた max_file_uploads で exit してるので 123
that($stdout)-&gt;isSame('out'); // 標準出力に標準入力を書き込んでいるので "out" が格納される
that($stderr)-&gt;isSame('err'); // 標準エラーに書き込んでいるので "err" が格納される
</code></pre>
</div>
    	<h4 class="fqsen-title">method		<small></small>
		<a href="ryunosuke-Functions-Package-Utility$typespace.html#ryunosuke\Functions\Package\Utility::arguments()">
                                    ryunosuke\Functions\Package\Utility::arguments		</a>	<small>($rule, $argv = null) : array</small>
		</h4>
	<div class="description"><p>コマンドライン引数をパースして引数とオプションを返す</p>
<p>少しリッチな <tag_link data-kind='uri' data-type='http://php.net/manual/function.getopt.php' data-description='getopt'>getopt</tag_link> として使える（shell 由来のオプション構文(a:b::)はどうも馴染みにくい）。<br />
ただし「値が必須なオプション」はサポートしない。<br />
もっとも、オプションとして空文字が来ることはほぼ無いのでデフォルト値を空文字にすることで対応可能。</p>
<p>$rule に従って <code>--noval filename --opt optval</code> のような文字列・配列をパースする。<br />
$rule 配列の仕様は下記。</p>
<ul>
<li>キーは「オプション名」を指定する。ただし・・・<ul>
<li>数値キーは「引数」を意味する</li>
<li>スペースの後に「ショート名」を与えられる</li>
</ul>
</li>
<li>値は「デフォルト値」を指定する。ただし・・・<ul>
<li><code>[]</code> は「複数値オプション」を意味する（配列にしない限り同オプションの多重指定は許されない）</li>
<li><code>null</code> は「値なしオプション」を意味する（スイッチングオプション）</li>
</ul>
</li>
<li>空文字キーは解釈自体のオプションを与える<ul>
<li>今のところ throw のみの実装。配列ではなく bool を与えられる</li>
</ul>
</li>
</ul>
<p>上記の仕様でパースして「引数は数値連番、オプションはオプション名をキーとした配列」を返す。<br />
なお、いわゆる「引数」はどこに来ても良い（前オプション、後オプションの区別がない）。</p>
<p>$argv には配列や文字列が与えられるが、ほとんどテスト用に近く、普通は未指定で $argv を使うはず。</p>
<p>Example:</p>
<pre><code class="language-php">// いくつか織り交ぜたスタンダードな例
$rule = [
    'opt'       =&gt; 'def',    // 基本的には「デフォルト値」を表す
    'longopt l' =&gt; '',       // スペース区切りで「ショート名」を意味する
    1           =&gt; 'defarg', // 数値キーは「引数」を意味する
];
that(arguments($rule, '--opt optval arg1 -l longval'))-&gt;isSame([
    'opt'     =&gt; 'optval',  // optval と指定している
    'longopt' =&gt; 'longval', // ショート名指定でも本来の名前で返ってくる
    'arg1',   // いわゆるコマンドライン引数（optval は opt に飲まれるので含まれない）
    'defarg', // いわゆるコマンドライン引数（与えられていないが、ルールの 1 =&gt; 'defarg' が活きている）
]);

// 「値なしオプション」と「複数値オプション」の例
$rule = [
    'noval1 l'  =&gt; null, // null は「値なしオプション」を意味する（指定されていれば true されていなければ false を返す）
    'noval2 m'  =&gt; null, // 同上
    'noval3 n'  =&gt; null, // 同上
    'opts o' =&gt; [],      // 配列を与えると「複数値オプション」を表す
];
that(arguments($rule, '--opts o1 -ln arg1 -o o2 arg2 --opts o3'))-&gt;isSame([
    'noval1' =&gt; true,  // -ln で同時指定されているので true
    'noval2' =&gt; false, // -ln で同時指定されてないので false
    'noval3' =&gt; true,  // -ln の同時指定されているので true
    'opts'   =&gt; ['o1', 'o2', 'o3'], // ロング、ショート混在でも OK
    'arg1', // 一見 -ln のオプション値に見えるが、 noval は値なしなので引数として得られる
    'arg2', // 前オプション、後オプションの区別はないのでどこに居ようと引数として得られる
]);

// 空文字で解釈自体のオプションを与える
$rule = [
    ''  =&gt; false, // 定義されていないオプションが来ても例外を投げずに引数として処理する
];
that(arguments($rule, '--long A -short B'))-&gt;isSame([
    '--long', // 明らかにオプション指定に見えるが、 long というオプションは定義されていないので引数として解釈される
    'A',      // 同上。long のオプション値に見えるが、ただの引数
    '-short', // 同上。short というオプションは定義されていない
    'B',      // 同上。short のオプション値に見えるが、ただの引数
]);
</code></pre>
</div>
    	<h4 class="fqsen-title">method		<small></small>
		<a href="ryunosuke-Functions-Package-Utility$typespace.html#ryunosuke\Functions\Package\Utility::stacktrace()">
                                    ryunosuke\Functions\Package\Utility::stacktrace		</a>	<small>($traces = null, $option = []) : string<span class="type-separator"></span><wbr>array</small>
		</h4>
	<div class="description"><p>スタックトレースを文字列で返す</p>
<p><code>(new \Exception())-&gt;getTraceAsString()</code> と実質的な役割は同じ。<br />
ただし、 getTraceAsString は引数が Array になったりクラス名しか取れなかったり微妙に使い勝手が悪いのでもうちょっと情報量を増やしたもの。</p>
<p>第1引数 $traces はトレース的配列を受け取る（<code>(new \Exception())-&gt;getTrace()</code> とか）。<br />
未指定時は debug_backtrace() で採取する。</p>
<p>第2引数 $option は文字列化する際の設定を指定する。<br />
情報量が増える分、機密も含まれる可能性があるため、 mask オプションで塗りつぶすキーや引数名を指定できる（クロージャの引数までは手出ししないため留意）。<br />
limit と format は比較的指定頻度が高いかつ互換性維持のため配列オプションではなく直に渡すことが可能になっている。</p>
</div>
    	<h4 class="fqsen-title">method		<small></small>
		<a href="ryunosuke-Functions-Package-Utility$typespace.html#ryunosuke\Functions\Package\Utility::backtrace()">
                                    ryunosuke\Functions\Package\Utility::backtrace		</a>	<small>($flags = DEBUG_BACKTRACE_PROVIDE_OBJECT, $options = []) : array</small>
		</h4>
	<div class="description"><p>特定条件までのバックトレースを取得する</p>
<p>第2引数 $options を満たすトレース以降を返す。<br />
$options は ['$trace の key' =&gt; "条件"] を渡す。<br />
条件は文字列かクロージャで、文字列の場合は緩い一致、クロージャの場合は true を返した場合にそれ以降を返す。</p>
<p>Example:</p>
<pre><code class="language-php">function f001 () {return backtrace(0, ['function' =&gt; __NAMESPACE__ . '\\f002', 'limit' =&gt; 2]);}
function f002 () {return f001();}
function f003 () {return f002();}
$traces = f003();
// limit 指定してるので2個
that($traces)-&gt;count(2);
// 「function が f002 以降」を返す
that($traces[0])-&gt;arraySubset([
    'function' =&gt; __NAMESPACE__ . '\\f002'
]);
that($traces[1])-&gt;arraySubset([
    'function' =&gt; __NAMESPACE__ . '\\f003'
]);
</code></pre>
</div>
    	<h4 class="fqsen-title">method		<small></small>
		<a href="ryunosuke-Functions-Package-Utility$typespace.html#ryunosuke\Functions\Package\Utility::profiler()">
                                    ryunosuke\Functions\Package\Utility::profiler		</a>	<small>($options = []) : <a href="http://php.net/manual/ja/class.traversable.php" class="fqsen" target="_blank">\Traversable</a><span class="type-separator"></span><wbr>callable</small>
		</h4>
	<div class="description"><p>外部ツールに頼らない pure php なプロファイラを返す</p>
<p>file プロトコル上書きと ticks と debug_backtrace によるかなり無理のある実装なので動かない環境・コードは多い。<br />
その分お手軽だが下記の注意点がある。</p>
<ul>
<li>file プロトコルを上書きするので、既に読み込み済みのファイルは計上されない</li>
<li>tick されないステートメントは計上されない<ul>
<li>1行メソッドなどでありがち</li>
</ul>
</li>
<li>A-&gt;B-&gt;C という呼び出しで C が 3秒、B が 2秒、A が1秒かかった場合、 A は 6 秒、B は 5秒、C は 3 秒といて計上される<ul>
<li>つまり、配下の呼び出しも重複して計上される</li>
</ul>
</li>
</ul>
<p>この関数を呼んだ時点で計測は始まる。<br />
返り値としてイテレータを返すので、foreach で回せばコールスタック・回数・時間などが取得できる。<br />
配列で欲しい場合は直に呼べば良い。</p>
</div>
    	<h4 class="fqsen-title">method		<small></small>
		<a href="ryunosuke-Functions-Package-Utility$typespace.html#ryunosuke\Functions\Package\Utility::error()">
                                    ryunosuke\Functions\Package\Utility::error		</a>	<small>($message, $destination = null) : int</small>
		</h4>
	<div class="description"><p>エラー出力する</p>
<p>第1引数 $message はそれらしく文字列化されて出力される。基本的にはあらゆる型を与えて良い。</p>
<p>第2引数 $destination で出力対象を指定する。省略すると error_log 設定に従う。<br />
文字列を与えるとファイル名とみなし、ファイルに追記される。<br />
ファイルを開くが、<strong>ファイルは閉じない</strong>。閉じ処理は php の終了処理に身を任せる。<br />
したがって閉じる必要がある場合はファイルポインタを渡す必要がある。</p>
</div>
    	<h4 class="fqsen-title">method		<small></small>
		<a href="ryunosuke-Functions-Package-Utility$typespace.html#ryunosuke\Functions\Package\Utility::add_error_handler()">
                                    ryunosuke\Functions\Package\Utility::add_error_handler		</a>	<small>($handler, $error_types = 32767) : callable<span class="type-separator"></span><wbr>null</small>
		</h4>
	<div class="description"><p>エラーハンドラを追加する</p>
<p>追加したエラーハンドラが false を返すと標準のエラーハンドラではなく、直近の設定されていたエラーハンドラに移譲される。<br />
（直近にエラーハンドラが設定されていなかったら標準ハンドラになる）。</p>
<p>「局所的にエラーハンドラを変更したいけど特定の状況は設定済みハンドラへ流したい」という状況はまれによくあるはず。</p>
<p>Example:</p>
<pre><code class="language-php">// @ 付きなら元々のハンドラに移譲、@ なしなら何らかのハンドリングを行う例
add_error_handler(function () {
    if (error_reporting() === 0) {
        // この false はマニュアルにある「この関数が FALSE を返した場合は、通常のエラーハンドラが処理を引き継ぎます」ではなく、
        // 「さっきまで設定されていたエラーハンドラが処理を引き継ぎます」という意味になる
        return false;
    }
    // do something
});
// false の扱いが異なるだけでその他の挙動はすべて set_error_handler と同じなので restore_error_handler で戻せる
restore_error_handler();
</code></pre>
</div>
    	<h4 class="fqsen-title">method		<small></small>
		<a href="ryunosuke-Functions-Package-Utility$typespace.html#ryunosuke\Functions\Package\Utility::timer()">
                                    ryunosuke\Functions\Package\Utility::timer		</a>	<small>($callable, $count = 1) : float</small>
		</h4>
	<div class="description"><p>処理時間を計測する</p>
<p>第1引数 $callable を $count 回回してその処理時間を返す。</p>
<p>Example:</p>
<pre><code class="language-php">// 0.01 秒を 10 回回すので 0.1 秒は超える
that(timer(function(){usleep(10 * 1000);}, 10))-&gt;greaterThan(0.1);
</code></pre>
</div>
    	<h4 class="fqsen-title">method		<small></small>
		<a href="ryunosuke-Functions-Package-Utility$typespace.html#ryunosuke\Functions\Package\Utility::benchmark()">
                                    ryunosuke\Functions\Package\Utility::benchmark		</a>	<small>($suite, $args = [], $millisec = 1000, $output = true) : array</small>
		</h4>
	<div class="description"><p>簡易ベンチマークを取る</p>
<p>「指定ミリ秒内で何回コールできるか？」でベンチする。</p>
<p>$suite は ['表示名' =&gt; $callable] 形式の配列。<br />
表示名が与えられていない場合、それらしい名前で表示する。</p>
<p>Example:</p>
<pre><code class="language-php">// intval と int キャストはどちらが早いか調べる
benchmark([
    'intval',
    'intcast' =&gt; function($v){return (int)$v;},
], ['12345'], 10);
</code></pre>
</div>
            	<h4 class="fqsen-title">class		<small></small>
		<a href="ryunosuke-Functions-Package-Vars$typespace.html#ryunosuke\Functions\Package\Vars">
                                    ryunosuke\Functions\Package::Vars		</a>	</h4>
	<div class="description"><p>変数関連のユーティリティ</p>
</div>
        	<h4 class="fqsen-title">classconstant		<small>array</small>
		<a href="ryunosuke-Functions-Package-Vars$typespace.html#ryunosuke\Functions\Package\Vars::SI_UNITS">
                                    ryunosuke\Functions\Package\Vars::SI_UNITS		</a>	</h4>
	<div class="description"><p>SI 接頭辞</p>
</div>
    	<h4 class="fqsen-title">classconstant		<small>integer</small>
		<a href="ryunosuke-Functions-Package-Vars$typespace.html#ryunosuke\Functions\Package\Vars::SORT_STRICT">
                                    ryunosuke\Functions\Package\Vars::SORT_STRICT		</a>	</h4>
	<div class="description"><p>SORT_XXX 定数の厳密版</p>
</div>
            	<h4 class="fqsen-title">method		<small></small>
		<a href="ryunosuke-Functions-Package-Vars$typespace.html#ryunosuke\Functions\Package\Vars::stringify()">
                                    ryunosuke\Functions\Package\Vars::stringify		</a>	<small>($var) : string</small>
		</h4>
	<div class="description"><p>値を何とかして文字列化する</p>
<p>この関数の出力は互換性を考慮しない。頻繁に変更される可能性がある。</p>
</div>
    	<h4 class="fqsen-title">method		<small></small>
		<a href="ryunosuke-Functions-Package-Vars$typespace.html#ryunosuke\Functions\Package\Vars::numberify()">
                                    ryunosuke\Functions\Package\Vars::numberify		</a>	<small>($var, $decimal = false) : int<span class="type-separator"></span><wbr>float</small>
		</h4>
	<div class="description"><p>値を何とかして数値化する</p>
<ul>
<li>配列は要素数</li>
<li>int/float はそのまま（ただし $decimal に応じた型にキャストされる）</li>
<li>resource はリソースID（php 標準の int キャスト）</li>
<li>null/bool はその int 値（php 標準の int キャストだが $decimal を見る）</li>
<li>それ以外（文字列・オブジェクト）は文字列表現から数値以外を取り除いたもの</li>
</ul>
<p>文字列・オブジェクト以外の変換は互換性を考慮しない。頻繁に変更される可能性がある（特に配列）。</p>
<p>-記号は受け入れるが+記号は受け入れない。</p>
<p>Example:</p>
<pre><code class="language-php">// 配列は要素数となる
that(numberify([1, 2, 3]))-&gt;isSame(3);
// int/float は基本的にそのまま
that(numberify(123))-&gt;isSame(123);
that(numberify(123.45))-&gt;isSame(123);
that(numberify(123.45, true))-&gt;isSame(123.45);
// 文字列は数値抽出
that(numberify('a1b2c3'))-&gt;isSame(123);
that(numberify('a1b2.c3', true))-&gt;isSame(12.3);
</code></pre>
</div>
    	<h4 class="fqsen-title">method		<small></small>
		<a href="ryunosuke-Functions-Package-Vars$typespace.html#ryunosuke\Functions\Package\Vars::numval()">
                                    ryunosuke\Functions\Package\Vars::numval		</a>	<small>($var, $base = 10) : int<span class="type-separator"></span><wbr>float</small>
		</h4>
	<div class="description"><p>値を数値化する</p>
<p>int か float ならそのまま返す。<br />
文字列の場合、一言で言えば「.を含むなら float、含まないなら int」を返す。<br />
int でも float でも stringable でもない場合は実装依存（ただの int キャスト）。</p>
<p>Example:</p>
<pre><code class="language-php">that(numval(3.14))-&gt;isSame(3.14);   // int や float はそのまま返す
that(numval('3.14'))-&gt;isSame(3.14); // . を含む文字列は float を返す
that(numval('11', 8))-&gt;isSame(9);   // 基数が指定できる
</code></pre>
</div>
    	<h4 class="fqsen-title">method		<small></small>
		<a href="ryunosuke-Functions-Package-Vars$typespace.html#ryunosuke\Functions\Package\Vars::arrayval()">
                                    ryunosuke\Functions\Package\Vars::arrayval		</a>	<small>($var, $recursive = true) : array</small>
		</h4>
	<div class="description"><p>array キャストの関数版</p>
<p>intval とか strval とかの array 版。<br />
ただキャストするだけだが、関数なのでコールバックとして使える。</p>
<p>$recursive を true にすると再帰的に適用する（デフォルト）。<br />
入れ子オブジェクトを配列化するときなどに使える。</p>
<p>Example:</p>
<pre><code class="language-php">// キャストなので基本的には配列化される
that(arrayval(123))-&gt;isSame([123]);
that(arrayval('str'))-&gt;isSame(['str']);
that(arrayval([123]))-&gt;isSame([123]); // 配列は配列のまま

// $recursive = false にしない限り再帰的に適用される
$stdclass = stdclass(['key' =&gt; 'val']);
that(arrayval([$stdclass], true))-&gt;isSame([['key' =&gt; 'val']]); // true なので中身も配列化される
that(arrayval([$stdclass], false))-&gt;isSame([$stdclass]);       // false なので中身は変わらない
</code></pre>
</div>
    	<h4 class="fqsen-title">method		<small></small>
		<a href="ryunosuke-Functions-Package-Vars$typespace.html#ryunosuke\Functions\Package\Vars::phpval()">
                                    ryunosuke\Functions\Package\Vars::phpval		</a>	<small>($var, $contextvars = []) : mixed</small>
		</h4>
	<div class="description"><p>文字列を php の式として評価して値を返す</p>
<p>実質的には <code>eval("return $var;")</code> とほぼ同義。<br />
ただ、 eval するまでもない式はそのまま返し、bare な文字列はそのまま文字列として返す（7.2 以前の未定義定数のような動作）。</p>
<p>Example:</p>
<pre><code class="language-php">that(phpval('strtoupper($var)', ['var' =&gt; 'string']))-&gt;isSame('STRING');
that(phpval('bare string'))-&gt;isSame('bare string');
</code></pre>
</div>
    	<h4 class="fqsen-title">method		<small></small>
		<a href="ryunosuke-Functions-Package-Vars$typespace.html#ryunosuke\Functions\Package\Vars::arrayable_key_exists()">
                                    ryunosuke\Functions\Package\Vars::arrayable_key_exists		</a>	<small>($key, $arrayable) : bool</small>
		</h4>
	<div class="description"><p>配列・ArrayAccess にキーがあるか調べる</p>
<p>配列が与えられた場合は array_key_exists と同じ。<br />
ArrayAccess は一旦 isset で確認した後 null の場合は実際にアクセスして試みる。</p>
<p>Example:</p>
<pre><code class="language-php">$array = [
    'k' =&gt; 'v',
    'n' =&gt; null,
];
// 配列は array_key_exists と同じ
that(arrayable_key_exists('k', $array))-&gt;isTrue();  // もちろん存在する
that(arrayable_key_exists('n', $array))-&gt;isTrue();  // isset ではないので null も true
that(arrayable_key_exists('x', $array))-&gt;isFalse(); // 存在しないので false
that(isset($array['n']))-&gt;isFalse();                // isset だと null が false になる（参考）

$object = new \ArrayObject($array);
// ArrayAccess は isset + 実際に取得を試みる
that(arrayable_key_exists('k', $object))-&gt;isTrue();  // もちろん存在する
that(arrayable_key_exists('n', $object))-&gt;isTrue();  // isset ではないので null も true
that(arrayable_key_exists('x', $object))-&gt;isFalse(); // 存在しないので false
that(isset($object['n']))-&gt;isFalse();                // isset だと null が false になる（参考）
</code></pre>
</div>
    	<h4 class="fqsen-title">method		<small></small>
		<a href="ryunosuke-Functions-Package-Vars$typespace.html#ryunosuke\Functions\Package\Vars::attr_exists()">
                                    ryunosuke\Functions\Package\Vars::attr_exists		</a>	<small>($key, $value) : bool</small>
		</h4>
	<div class="description"><p>配列・オブジェクトを問わずキーやプロパティの存在を確認する</p>
<p>配列が与えられた場合は array_key_exists と同じ。<br />
オブジェクトは一旦 isset で確認した後 null の場合は実際にアクセスして試みる。</p>
<p>Example:</p>
<pre><code class="language-php">$array = [
    'k' =&gt; 'v',
    'n' =&gt; null,
];
// 配列は array_key_exists と同じ
that(attr_exists('k', $array))-&gt;isTrue();  // もちろん存在する
that(attr_exists('n', $array))-&gt;isTrue();  // isset ではないので null も true
that(attr_exists('x', $array))-&gt;isFalse(); // 存在しないので false

$object = (object) $array;
// オブジェクトでも使える
that(attr_exists('k', $object))-&gt;isTrue();  // もちろん存在する
that(attr_exists('n', $object))-&gt;isTrue();  // isset ではないので null も true
that(attr_exists('x', $object))-&gt;isFalse(); // 存在しないので false
</code></pre>
</div>
    	<h4 class="fqsen-title">method		<small></small>
		<a href="ryunosuke-Functions-Package-Vars$typespace.html#ryunosuke\Functions\Package\Vars::attr_get()">
                                    ryunosuke\Functions\Package\Vars::attr_get		</a>	<small>($key, $value, $default = null) : mixed</small>
		</h4>
	<div class="description"><p>配列・オブジェクトを問わずキーやプロパティの値を取得する</p>
<p>配列が与えられた場合は array_key_exists でチェック。<br />
オブジェクトは一旦 isset で確認した後 null の場合は実際にアクセスして取得する。</p>
<p>Example:</p>
<pre><code class="language-php">$array = [
    'k' =&gt; 'v',
    'n' =&gt; null,
];
that(attr_get('k', $array))-&gt;isSame('v');                  // もちろん存在する
that(attr_get('n', $array))-&gt;isSame(null);                 // isset ではないので null も true
that(attr_get('x', $array, 'default'))-&gt;isSame('default'); // 存在しないのでデフォルト値

$object = (object) $array;
// オブジェクトでも使える
that(attr_get('k', $object))-&gt;isSame('v');                  // もちろん存在する
that(attr_get('n', $object))-&gt;isSame(null);                 // isset ではないので null も true
that(attr_get('x', $object, 'default'))-&gt;isSame('default'); // 存在しないのでデフォルト値
</code></pre>
</div>
    	<h4 class="fqsen-title">method		<small></small>
		<a href="ryunosuke-Functions-Package-Vars$typespace.html#ryunosuke\Functions\Package\Vars::si_prefix()">
                                    ryunosuke\Functions\Package\Vars::si_prefix		</a>	<small>($var, $unit = 1000, $format = &quot;%.3f %s&quot;) : string<span class="type-separator"></span><wbr>array</small>
		</h4>
	<div class="description"><p>数値に SI 接頭辞を付与する</p>
<p>値は 1 &lt;= $var &lt; 1000(1024) の範囲内に収められる。<br />
ヨクト（10^24）～ヨタ（1024）まで。整数だとしても 64bit の範囲を超えるような値の精度は保証しない。</p>
<p>Example:</p>
<pre><code class="language-php">// シンプルに k をつける
that(si_prefix(12345))-&gt;isSame('12.345 k');
// シンプルに m をつける
that(si_prefix(0.012345))-&gt;isSame('12.345 m');
// 書式フォーマットを指定できる
that(si_prefix(12345, 1000, '%d%s'))-&gt;isSame('12k');
that(si_prefix(0.012345, 1000, '%d%s'))-&gt;isSame('12m');
// ファイルサイズを byte で表示する
that(si_prefix(12345, 1000, '%d %sbyte'))-&gt;isSame('12 kbyte');
// ファイルサイズを byte で表示する（1024）
that(si_prefix(10240, 1024, '%.3f %sbyte'))-&gt;isSame('10.000 kbyte');
// フォーマットに null を与えると sprintf せずに配列で返す
that(si_prefix(12345, 1000, null))-&gt;isSame([12.345, 'k']);
// フォーマットにクロージャを与えると実行して返す
that(si_prefix(12345, 1000, function ($v, $u) {
    return number_format($v, 2) . $u;
}))-&gt;isSame('12.35k');
</code></pre>
</div>
    	<h4 class="fqsen-title">method		<small></small>
		<a href="ryunosuke-Functions-Package-Vars$typespace.html#ryunosuke\Functions\Package\Vars::si_unprefix()">
                                    ryunosuke\Functions\Package\Vars::si_unprefix		</a>	<small>($var, $unit = 1000) : int<span class="type-separator"></span><wbr>float</small>
		</h4>
	<div class="description"><p>SI 接頭辞が付与された文字列を数値化する</p>
<p>典型的な用途は ini_get で得られた値を数値化したいとき。<br />
ただし、 ini は 1m のように小文字で指定することもあるので大文字化する必要はある。</p>
<p>Example:</p>
<pre><code class="language-php">// 1k = 1000
that(si_unprefix('1k'))-&gt;isSame(1000);
// 1k = 1024
that(si_unprefix('1k', 1024))-&gt;isSame(1024);
// m はメガではなくミリ
that(si_unprefix('1m'))-&gt;isSame(0.001);
// M がメガ
that(si_unprefix('1M'))-&gt;isSame(1000000);
// K だけは特別扱いで大文字小文字のどちらでもキロになる
that(si_unprefix('1K'))-&gt;isSame(1000);
</code></pre>
</div>
    	<h4 class="fqsen-title">method		<small></small>
		<a href="ryunosuke-Functions-Package-Vars$typespace.html#ryunosuke\Functions\Package\Vars::is_empty()">
                                    ryunosuke\Functions\Package\Vars::is_empty		</a>	<small>($var, $empty_stdClass = false) : bool</small>
		</h4>
	<div class="description"><p>値が空か検査する</p>
<p><code>empty</code> とほぼ同じ。ただし</p>
<ul>
<li>string: "0"</li>
<li>countable でない object</li>
<li>countable である object で count() &gt; 0</li>
</ul>
<p>は false 判定する。<br />
ただし、 $empty_stcClass に true を指定すると「フィールドのない stdClass」も true を返すようになる。<br />
これは stdClass の立ち位置はかなり特殊で「フィールドアクセスできる組み込み配列」のような扱いをされることが多いため。<br />
（例えば <code>json_decode('{}')</code> は stdClass を返すが、このような状況は空判定したいことが多いだろう）。</p>
<p>なお、関数の仕様上、未定義変数を true 判定することはできない。<br />
未定義変数をチェックしたい状況は大抵の場合コードが悪いが <code>$array['key1']['key2']</code> を調べたいことはある。<br />
そういう時には使えない（?? する必要がある）。</p>
<p>「 <code>if ($var) {}</code> で十分なんだけど "0" が…」という状況はまれによくあるはず。</p>
<p>Example:</p>
<pre><code class="language-php">// この辺は empty と全く同じ
that(is_empty(null))-&gt;isTrue();
that(is_empty(false))-&gt;isTrue();
that(is_empty(0))-&gt;isTrue();
that(is_empty(''))-&gt;isTrue();
// この辺だけが異なる
that(is_empty('0'))-&gt;isFalse();
// 第2引数に true を渡すと空の stdClass も empty 判定される
$stdclass = new \stdClass();
that(is_empty($stdclass, true))-&gt;isTrue();
// フィールドがあれば empty ではない
$stdclass-&gt;hoge = 123;
that(is_empty($stdclass, true))-&gt;isFalse();
</code></pre>
</div>
    	<h4 class="fqsen-title">method		<small></small>
		<a href="ryunosuke-Functions-Package-Vars$typespace.html#ryunosuke\Functions\Package\Vars::is_primitive()">
                                    ryunosuke\Functions\Package\Vars::is_primitive		</a>	<small>($var) : bool</small>
		</h4>
	<div class="description"><p>値が複合型でないか検査する</p>
<p>「複合型」とはオブジェクトと配列のこと。<br />
つまり</p>
<ul>
<li>is_scalar($var) || is_null($var) || is_resource($var)</li>
</ul>
<p>と同義（!is_array($var) &amp;&amp; !is_object($var) とも言える）。</p>
<p>Example:</p>
<pre><code class="language-php">that(is_primitive(null))-&gt;isTrue();
that(is_primitive(false))-&gt;isTrue();
that(is_primitive(123))-&gt;isTrue();
that(is_primitive(STDIN))-&gt;isTrue();
that(is_primitive(new \stdClass))-&gt;isFalse();
that(is_primitive(['array']))-&gt;isFalse();
</code></pre>
</div>
    	<h4 class="fqsen-title">method		<small></small>
		<a href="ryunosuke-Functions-Package-Vars$typespace.html#ryunosuke\Functions\Package\Vars::is_recursive()">
                                    ryunosuke\Functions\Package\Vars::is_recursive		</a>	<small>($var) : bool</small>
		</h4>
	<div class="description"><p>変数が再帰参照を含むか調べる</p>
<p>Example:</p>
<pre><code class="language-php">// 配列の再帰
$array = [];
$array['recursive'] = &amp;$array;
that(is_recursive($array))-&gt;isTrue();
// オブジェクトの再帰
$object = new \stdClass();
$object-&gt;recursive = $object;
that(is_recursive($object))-&gt;isTrue();
</code></pre>
</div>
    	<h4 class="fqsen-title">method		<small></small>
		<a href="ryunosuke-Functions-Package-Vars$typespace.html#ryunosuke\Functions\Package\Vars::is_stringable()">
                                    ryunosuke\Functions\Package\Vars::is_stringable		</a>	<small>($var) : bool</small>
		</h4>
	<div class="description"><p>変数が文字列化できるか調べる</p>
<p>「配列」「__toString を持たないオブジェクト」が false になる。<br />
（厳密に言えば配列は "Array" になるので文字列化できるといえるがここでは考えない）。</p>
<p>Example:</p>
<pre><code class="language-php">// こいつらは true
that(is_stringable(null))-&gt;isTrue();
that(is_stringable(true))-&gt;isTrue();
that(is_stringable(3.14))-&gt;isTrue();
that(is_stringable(STDOUT))-&gt;isTrue();
that(is_stringable(new \Exception()))-&gt;isTrue();
// こいつらは false
that(is_stringable(new \ArrayObject()))-&gt;isFalse();
that(is_stringable([1, 2, 3]))-&gt;isFalse();
</code></pre>
</div>
    	<h4 class="fqsen-title">method		<small></small>
		<a href="ryunosuke-Functions-Package-Vars$typespace.html#ryunosuke\Functions\Package\Vars::is_arrayable()">
                                    ryunosuke\Functions\Package\Vars::is_arrayable		</a>	<small>($var) : bool</small>
		</h4>
	<div class="description"><p>変数が配列アクセス可能か調べる</p>
<p>Example:</p>
<pre><code class="language-php">that(is_arrayable([]))-&gt;isTrue();
that(is_arrayable(new \ArrayObject()))-&gt;isTrue();
that(is_arrayable(new \stdClass()))-&gt;isFalse();
</code></pre>
</div>
    	<h4 class="fqsen-title">method		<small></small>
		<a href="ryunosuke-Functions-Package-Vars$typespace.html#ryunosuke\Functions\Package\Vars::is_countable()">
                                    ryunosuke\Functions\Package\Vars::is_countable		</a>	<small>($var) : bool</small>
		</h4>
	<div class="description"><p>変数が count でカウントできるか調べる</p>
<p>要するに <tag_link data-kind='uri' data-type='http://php.net/manual/function.is-countable.php' data-description='is_countable'>is_countable</tag_link> の polyfill。</p>
<p>Example:</p>
<pre><code class="language-php">that(is_countable([1, 2, 3]))-&gt;isTrue();
that(is_countable(new \ArrayObject()))-&gt;isTrue();
that(is_countable((function () { yield 1; })()))-&gt;isFalse();
that(is_countable(1))-&gt;isFalse();
that(is_countable(new \stdClass()))-&gt;isFalse();
</code></pre>
</div>
    	<h4 class="fqsen-title">method		<small></small>
		<a href="ryunosuke-Functions-Package-Vars$typespace.html#ryunosuke\Functions\Package\Vars::encrypt()">
                                    ryunosuke\Functions\Package\Vars::encrypt		</a>	<small>($plaindata, $password, $cipher = &quot;aes-256-cbc&quot;, &amp;$tag = &quot;&quot;) : string</small>
		</h4>
	<div class="description"><p>指定されたパスワードとアルゴリズムで暗号化する</p>
<p>データは json を経由して base64（URL セーフ） して返す。<br />
$tag を与えると認証タグが設定される。</p>
<p>Example:</p>
<pre><code class="language-php">$plaindata = ['a', 'b', 'c'];
$encrypted = encrypt($plaindata, 'password');
$decrypted = decrypt($encrypted, 'password');
// 暗号化されて base64 の文字列になる
that($encrypted)-&gt;isString();
// 復号化されて元の配列になる
that($decrypted)-&gt;isSame(['a', 'b', 'c']);
// password が異なれば失敗して null を返す
that(decrypt($encrypted, 'invalid'))-&gt;isSame(null);

$encrypted = encrypt($plaindata, 'password', 'aes-256-gcm', $tag);
// タグが設定される
that($tag)-&gt;isString();
// タグが正しければ復号化されて元の配列になる
that(decrypt($encrypted, 'password', 'aes-256-gcm', $tag))-&gt;isSame(['a', 'b', 'c']);
// タグが不正なら失敗して null を返す
that(decrypt($encrypted, 'password', 'aes-256-gcm', 'invalid'))-&gt;isSame(null);
</code></pre>
</div>
    	<h4 class="fqsen-title">method		<small></small>
		<a href="ryunosuke-Functions-Package-Vars$typespace.html#ryunosuke\Functions\Package\Vars::decrypt()">
                                    ryunosuke\Functions\Package\Vars::decrypt		</a>	<small>($cipherdata, $password, $cipher = &quot;aes-256-cbc&quot;, $tag = &quot;&quot;) : mixed</small>
		</h4>
	<div class="description"><p>指定されたパスワードとアルゴリズムで復号化する</p>
<p>$cipher は配列で複数与えることができる。<br />
複数与えた場合、順に試みて複合できた段階でその値を返す。</p>
<p>復号に失敗すると null を返す。<br />
単体で使うことはないと思うので詳細は encrypt を参照。</p>
</div>
    	<h4 class="fqsen-title">method		<small></small>
		<a href="ryunosuke-Functions-Package-Vars$typespace.html#ryunosuke\Functions\Package\Vars::varcmp()">
                                    ryunosuke\Functions\Package\Vars::varcmp		</a>	<small>($a, $b, $mode = null, $precision = null) : int</small>
		</h4>
	<div class="description"><p>php7 の <code>&lt;=&gt;</code> の関数版</p>
<p>引数で大文字小文字とか自然順とか型モードとかが指定できる。<br />
さらに追加で SORT_STRICT という厳密比較フラグを渡すことができる。</p>
<p>Example:</p>
<pre><code class="language-php">// 'a' と 'z' なら 'z' の方が大きい
that(varcmp('z', 'a') &gt; 0)-&gt;isTrue();
that(varcmp('a', 'z') &lt; 0)-&gt;isTrue();
that(varcmp('a', 'a') === 0)-&gt;isTrue();

// 'a' と 'Z' なら 'a' の方が大きい…が SORT_FLAG_CASE なので 'Z' のほうが大きい
that(varcmp('Z', 'a', SORT_FLAG_CASE) &gt; 0)-&gt;isTrue();
that(varcmp('a', 'Z', SORT_FLAG_CASE) &lt; 0)-&gt;isTrue();
that(varcmp('a', 'A', SORT_FLAG_CASE) === 0)-&gt;isTrue();

// '2' と '12' なら '2' の方が大きい…が SORT_NATURAL なので '12' のほうが大きい
that(varcmp('12', '2', SORT_NATURAL) &gt; 0)-&gt;isTrue();
that(varcmp('2', '12', SORT_NATURAL) &lt; 0)-&gt;isTrue();

// SORT_STRICT 定数が使える（下記はすべて宇宙船演算子を使うと 0 になる）
that(varcmp(['a' =&gt; 'A', 'b' =&gt; 'B'], ['b' =&gt; 'B', 'a' =&gt; 'A'], SORT_STRICT) &lt; 0)-&gt;isTrue();
that(varcmp((object) ['a'], (object) ['a'], SORT_STRICT) &lt; 0)-&gt;isTrue();
</code></pre>
</div>
    	<h4 class="fqsen-title">method		<small></small>
		<a href="ryunosuke-Functions-Package-Vars$typespace.html#ryunosuke\Functions\Package\Vars::var_type()">
                                    ryunosuke\Functions\Package\Vars::var_type		</a>	<small>($var, $valid_name = false) : string</small>
		</h4>
	<div class="description"><p>値の型を取得する（gettype + get_class）</p>
<p>プリミティブ型（gettype で得られるやつ）はそのまま、オブジェクトのときのみクラス名を返す。<br />
ただし、オブジェクトの場合は先頭に '\' が必ず付く。<br />
また、 $valid_name を true にするとタイプヒントとして正当な名前を返す（integer -&gt; int, double -&gt; float など）。<br />
互換性のためデフォルト false になっているが、将来的にこの引数は削除されるかデフォルト true に変更される。</p>
<p>無名クラスの場合は extends, implements の優先順位でその名前を使う。<br />
継承も実装もされていない場合は標準の get_class の結果を返す。</p>
<p>Example:</p>
<pre><code class="language-php">// プリミティブ型は gettype と同義
that(var_type(false))-&gt;isSame('boolean');
that(var_type(123))-&gt;isSame('integer');
that(var_type(3.14))-&gt;isSame('double');
that(var_type([1, 2, 3]))-&gt;isSame('array');
// オブジェクトは型名を返す
that(var_type(new \stdClass))-&gt;isSame('\\stdClass');
that(var_type(new \Exception()))-&gt;isSame('\\Exception');
// 無名クラスは継承元の型名を返す（インターフェース実装だけのときはインターフェース名）
that(var_type(new class extends \Exception{}))-&gt;isSame('\\Exception');
that(var_type(new class implements \JsonSerializable{
    public function jsonSerialize() { return ''; }
}))-&gt;isSame('\\JsonSerializable');
</code></pre>
</div>
    	<h4 class="fqsen-title">method		<small></small>
		<a href="ryunosuke-Functions-Package-Vars$typespace.html#ryunosuke\Functions\Package\Vars::var_apply()">
                                    ryunosuke\Functions\Package\Vars::var_apply		</a>	<small>($var, $callback, ...$args) : mixed<span class="type-separator"></span><wbr>array</small>
		</h4>
	<div class="description"><p>値にコールバックを適用する</p>
<p>普通のスカラー値であれば <code>$callback($var)</code> と全く同じ。<br />
この関数は「$var が配列だったら中身に適用して返す（再帰）」という点で上記とは異なる。</p>
<p>「配列が与えられたら要素に適用して配列で返す、配列じゃないなら直に適用してそれを返す」という状況はまれによくあるはず。</p>
<p>Example:</p>
<pre><code class="language-php">// 素の値は素の呼び出しと同じ
that(var_apply(' x ', 'trim'))-&gt;isSame('x');
// 配列は中身に適用して配列で返す（再帰）
that(var_apply([' x ', ' y ', [' z ']], 'trim'))-&gt;isSame(['x', 'y', ['z']]);
// 第3引数以降は残り引数を意味する
that(var_apply(['!x!', '!y!'], 'trim', '!'))-&gt;isSame(['x', 'y']);
// 「まれによくある」の具体例
that(var_apply(['&lt;x&gt;', ['&lt;y&gt;']], 'htmlspecialchars', ENT_QUOTES, 'utf-8'))-&gt;isSame(['&amp;lt;x&amp;gt;', ['&amp;lt;y&amp;gt;']]);
</code></pre>
</div>
    	<h4 class="fqsen-title">method		<small></small>
		<a href="ryunosuke-Functions-Package-Vars$typespace.html#ryunosuke\Functions\Package\Vars::var_applys()">
                                    ryunosuke\Functions\Package\Vars::var_applys		</a>	<small>($var, $callback, ...$args) : mixed<span class="type-separator"></span><wbr>array</small>
		</h4>
	<div class="description"><p>配列にコールバックを適用する</p>
<p>配列であれば <code>$callback($var)</code> と全く同じ。<br />
この関数は「$var がスカラー値だったら配列化して適用してスカラーで返す」という点で上記とは異なる。</p>
<p>「配列を受け取って配列を返す関数があるが、手元にスカラー値しか無い」という状況はまれによくあるはず。</p>
<p>Example:</p>
<pre><code class="language-php">// 配列を受け取って中身を大文字化して返すクロージャ
$upper = function($array){return array_map('strtoupper', $array);};
// 普通はこうやって使うが・・・
that($upper(['a', 'b', 'c']))-&gt;isSame(['A', 'B', 'C']);
// 手元に配列ではなくスカラー値しか無いときはこうせざるをえない
that($upper(['a'])[0])-&gt;isSame('A');
// var_applys を使うと配列でもスカラーでも統一的に記述することができる
that(var_applys(['a', 'b', 'c'], $upper))-&gt;isSame(['A', 'B', 'C']);
that(var_applys('a', $upper))-&gt;isSame('A');
# 要するに「大文字化したい」だけなわけだが、$upper が配列を前提としているので、「大文字化」部分を得るには配列化しなければならなくなっている
# 「strtoupper だけ切り出せばよいのでは？」と思うかもしれないが、「（外部ライブラリなどで）手元に配列しか受け取ってくれない処理しかない」状況がまれによくある
</code></pre>
</div>
    	<h4 class="fqsen-title">method		<small></small>
		<a href="ryunosuke-Functions-Package-Vars$typespace.html#ryunosuke\Functions\Package\Vars::var_export2()">
                                    ryunosuke\Functions\Package\Vars::var_export2		</a>	<small>($value, $return = false) : string<span class="type-separator"></span><wbr>null</small>
		</h4>
	<div class="description"><p>組み込みの var_export をいい感じにしたもの</p>
<p>下記の点が異なる。</p>
<ul>
<li>配列は 5.4 以降のショートシンタックス（[]）で出力</li>
<li>インデントは 4 固定</li>
<li>ただの配列は1行（[1, 2, 3]）でケツカンマなし、連想配列は桁合わせインデントでケツカンマあり</li>
<li>文字列はダブルクオート</li>
<li>null は null（小文字）</li>
<li>再帰構造を渡しても警告がでない（さらに NULL ではなく <code>'*RECURSION*'</code> という文字列になる）</li>
<li>配列の再帰構造の出力が異なる（Example参照）</li>
</ul>
<p>Example:</p>
<pre><code class="language-php">// 単純なエクスポート
that(var_export2(['array' =&gt; [1, 2, 3], 'hash' =&gt; ['a' =&gt; 'A', 'b' =&gt; 'B', 'c' =&gt; 'C']], true))-&gt;isSame('[
    "array" =&gt; [1, 2, 3],
    "hash"  =&gt; [
        "a" =&gt; "A",
        "b" =&gt; "B",
        "c" =&gt; "C",
    ],
]');
// 再帰構造を含むエクスポート（標準の var_export は形式が異なる。 var_export すれば分かる）
$rarray = [];
$rarray['a']['b']['c'] = &amp;$rarray;
$robject = new \stdClass();
$robject-&gt;a = new \stdClass();
$robject-&gt;a-&gt;b = new \stdClass();
$robject-&gt;a-&gt;b-&gt;c = $robject;
that(var_export2(compact('rarray', 'robject'), true))-&gt;isSame('[
    "rarray"  =&gt; [
        "a" =&gt; [
            "b" =&gt; [
                "c" =&gt; "*RECURSION*",
            ],
        ],
    ],
    "robject" =&gt; stdClass::__set_state([
        "a" =&gt; stdClass::__set_state([
            "b" =&gt; stdClass::__set_state([
                "c" =&gt; "*RECURSION*",
            ]),
        ]),
    ]),
]');
</code></pre>
</div>
    	<h4 class="fqsen-title">method		<small></small>
		<a href="ryunosuke-Functions-Package-Vars$typespace.html#ryunosuke\Functions\Package\Vars::var_export3()">
                                    ryunosuke\Functions\Package\Vars::var_export3		</a>	<small>($value, $return = false) : string</small>
		</h4>
	<div class="description"><p>var_export を色々と出力できるようにしたもの</p>
<p>php のコードに落とし込むことで serialize と比較してかなり高速に動作する。ただし、要 php7.4.</p>
<p>各種オブジェクトやクロージャ、循環参照を含む配列など様々なものが出力できる。<br />
ただし、下記は不可能あるいは復元不可（今度も対応するかは未定）。</p>
<ul>
<li>無名クラス</li>
<li>Generator クラス</li>
<li>特定の内部クラス（PDO など）</li>
<li>リソース</li>
<li>php7.4 以降のアロー関数によるクロージャ</li>
</ul>
<p>オブジェクトは「リフレクションを用いてコンストラクタなしで生成してプロパティを代入する」という手法で復元する。<br />
のでクラスによってはおかしな状態で復元されることがある（大体はリソース型のせいだが…）。<br />
sleep, wakeup, Serializable などが実装されているとそれはそのまま機能する。<br />
set_state だけは呼ばれないので注意。</p>
<p>クロージャはコード自体を引っ張ってきて普通に function (){} として埋め込む。<br />
クラス名のエイリアスや use, $this バインドなど可能な限り復元するが、おそらくあまりに複雑なことをしてると失敗する。</p>
<p>軽くベンチを取ったところ、オブジェクトを含まない純粋な配列の場合、serialize の 200 倍くらいは速い（それでも var_export の方が速いが…）。<br />
オブジェクトを含めば含むほど遅くなり、全要素がオブジェクトになると serialize と同程度になる。<br />
大体 var_export:var_export3:serialize が 1:5:1000 くらい。</p>
</div>
    	<h4 class="fqsen-title">method		<small></small>
		<a href="ryunosuke-Functions-Package-Vars$typespace.html#ryunosuke\Functions\Package\Vars::var_html()">
                                    ryunosuke\Functions\Package\Vars::var_html		</a>	<small>($value) : void</small>
		</h4>
	<div class="description"><p>var_export2 を html コンテキストに特化させたようなもの</p>
<p>下記のような出力になる。</p>
<ul>
<li><code>&lt;pre class='var_html'&gt; ～ &lt;/pre&gt;</code> で囲まれる</li>
<li>php 構文なのでハイライトされて表示される</li>
<li>Content-Type が強制的に text/html になる</li>
</ul>
<p>この関数の出力は互換性を考慮しない。頻繁に変更される可能性がある。</p>
</div>
    	<h4 class="fqsen-title">method		<small></small>
		<a href="ryunosuke-Functions-Package-Vars$typespace.html#ryunosuke\Functions\Package\Vars::var_pretty()">
                                    ryunosuke\Functions\Package\Vars::var_pretty		</a>	<small>($value, $context = null, $return = false) : string</small>
		</h4>
	<div class="description"><p>var_dump の出力を見やすくしたもの</p>
<p>var_dump はとても縦に長い上見づらいので色や改行・空白を調整して見やすくした。<br />
sapi に応じて自動で色分けがなされる（$context で指定もできる）。<br />
また、 xdebug のように呼び出しファイル:行数が先頭に付与される。</p>
<p>この関数の出力は互換性を考慮しない。頻繁に変更される可能性がある。</p>
<p>Example:</p>
<pre><code class="language-php">// 下記のように出力される（実際は色付きで出力される）
$using = 123;
var_pretty([
    "array"   =&gt; [1, 2, 3],
    "hash"    =&gt; [
        "a" =&gt; "A",
        "b" =&gt; "B",
        "c" =&gt; "C",
    ],
    "object"  =&gt; new \Exception(),
    "closure" =&gt; function () use($using) { },
]);
?&gt;
{
  array: [1, 2, 3],
  hash: {
    a: 'A',
    b: 'B',
    c: 'C',
  },
  object: Exception#1 {
    message: '',
    string: '',
    code: 0,
    file: '...',
    line: 19,
    trace: [],
    previous: null,
  },
  closure: Closure#0(static) use {
    using: 123,
  },
}
&lt;?php
</code></pre>
</div>
    	<h4 class="fqsen-title">method		<small></small>
		<a href="ryunosuke-Functions-Package-Vars$typespace.html#ryunosuke\Functions\Package\Vars::console_log()">
                                    ryunosuke\Functions\Package\Vars::console_log		</a>	<small>(...$values) : void</small>
		</h4>
	<div class="description"><p>js の console に値を吐き出す</p>
<p>script タグではなく X-ChromeLogger-Data を使用する。<br />
したがってヘッダ送信前に呼ぶ必要がある。</p>
</div>
    	<h4 class="fqsen-title">method		<small></small>
		<a href="ryunosuke-Functions-Package-Vars$typespace.html#ryunosuke\Functions\Package\Vars::hashvar()">
                                    ryunosuke\Functions\Package\Vars::hashvar		</a>	<small>(...$vars) : array</small>
		</h4>
	<div class="description"><p>変数指定をできるようにした compact</p>
<p>名前空間指定の呼び出しは未対応。use して関数名だけで呼び出す必要がある。</p>
<p>Example:</p>
<pre><code class="language-php">$hoge = 'HOGE';
$fuga = 'FUGA';
that(hashvar($hoge, $fuga))-&gt;isSame(['hoge' =&gt; 'HOGE', 'fuga' =&gt; 'FUGA']);
</code></pre>
</div>
                
    
                    
    
                    
    </div>
</body>
</html>
